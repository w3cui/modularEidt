/******/ (function(modules) { // webpackBootstrap
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
/******/ 		if(typeof XMLHttpRequest === "undefined")
/******/ 			return callback(new Error("No browser support"));
/******/ 		try {
/******/ 			var request = new XMLHttpRequest();
/******/ 			var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 			request.open("GET", requestPath, true);
/******/ 			request.timeout = 10000;
/******/ 			request.send(null);
/******/ 		} catch(err) {
/******/ 			return callback(err);
/******/ 		}
/******/ 		request.onreadystatechange = function() {
/******/ 			if(request.readyState !== 4) return;
/******/ 			if(request.status === 0) {
/******/ 				// timeout
/******/ 				callback(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 			} else if(request.status === 404) {
/******/ 				// no update available
/******/ 				callback();
/******/ 			} else if(request.status !== 200 && request.status !== 304) {
/******/ 				// other failure
/******/ 				callback(new Error("Manifest request to " + requestPath + " failed."));
/******/ 			} else {
/******/ 				// success
/******/ 				try {
/******/ 					var update = JSON.parse(request.responseText);
/******/ 				} catch(e) {
/******/ 					callback(e);
/******/ 					return;
/******/ 				}
/******/ 				callback(null, update);
/******/ 			}
/******/ 		};
/******/ 	}

/******/ 	
/******/ 	
/******/ 	// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js
/******/ 	var canDefineProperty = false;
/******/ 	try {
/******/ 		Object.defineProperty({}, "x", {
/******/ 			get: function() {}
/******/ 		});
/******/ 		canDefineProperty = true;
/******/ 	} catch(x) {
/******/ 		// IE will fail on defineProperty
/******/ 	}
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "3808ff64916b8e60c351"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					if(me.children.indexOf(request) < 0)
/******/ 						me.children.push(request);
/******/ 				} else hotCurrentParents = [moduleId];
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {
/******/ 				if(canDefineProperty) {
/******/ 					Object.defineProperty(fn, name, (function(name) {
/******/ 						return {
/******/ 							configurable: true,
/******/ 							enumerable: true,
/******/ 							get: function() {
/******/ 								return __webpack_require__[name];
/******/ 							},
/******/ 							set: function(value) {
/******/ 								__webpack_require__[name] = value;
/******/ 							}
/******/ 						};
/******/ 					}(name)));
/******/ 				} else {
/******/ 					fn[name] = __webpack_require__[name];
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		function ensure(chunkId, callback) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			__webpack_require__.e(chunkId, function() {
/******/ 				try {
/******/ 					callback.call(null, fn);
/******/ 				} finally {
/******/ 					finishChunkLoading();
/******/ 				}
/******/ 	
/******/ 				function finishChunkLoading() {
/******/ 					hotChunksLoading--;
/******/ 					if(hotStatus === "prepare") {
/******/ 						if(!hotWaitingFilesMap[chunkId]) {
/******/ 							hotEnsureUpdateChunk(chunkId);
/******/ 						}
/******/ 						if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 							hotUpdateDownloaded();
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		}
/******/ 		if(canDefineProperty) {
/******/ 			Object.defineProperty(fn, "e", {
/******/ 				enumerable: true,
/******/ 				value: ensure
/******/ 			});
/******/ 		} else {
/******/ 			fn.e = ensure;
/******/ 		}
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback;
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback;
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "number")
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 				else
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailibleFilesMap = {};
/******/ 	var hotCallback;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply, callback) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		if(typeof apply === "function") {
/******/ 			hotApplyOnUpdate = false;
/******/ 			callback = apply;
/******/ 		} else {
/******/ 			hotApplyOnUpdate = apply;
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 		hotSetStatus("check");
/******/ 		hotDownloadManifest(function(err, update) {
/******/ 			if(err) return callback(err);
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				callback(null, null);
/******/ 				return;
/******/ 			}
/******/ 	
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotAvailibleFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			for(var i = 0; i < update.c.length; i++)
/******/ 				hotAvailibleFilesMap[update.c[i]] = true;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			hotCallback = callback;
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailibleFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var callback = hotCallback;
/******/ 		hotCallback = null;
/******/ 		if(!callback) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate, callback);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			callback(null, outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options, callback) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		if(typeof options === "function") {
/******/ 			callback = options;
/******/ 			options = {};
/******/ 		} else if(options && typeof options === "object") {
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		} else {
/******/ 			options = {};
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function getAffectedStuff(module) {
/******/ 			var outdatedModules = [module];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice();
/******/ 			while(queue.length > 0) {
/******/ 				var moduleId = queue.pop();
/******/ 				var module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return new Error("Aborted because of self decline: " + moduleId);
/******/ 				}
/******/ 				if(moduleId === 0) {
/******/ 					return;
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push(parentId);
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return [outdatedModules, outdatedDependencies];
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				var moduleId = toModuleId(id);
/******/ 				var result = getAffectedStuff(moduleId);
/******/ 				if(!result) {
/******/ 					if(options.ignoreUnaccepted)
/******/ 						continue;
/******/ 					hotSetStatus("abort");
/******/ 					return callback(new Error("Aborted because " + moduleId + " is not accepted"));
/******/ 				}
/******/ 				if(result instanceof Error) {
/******/ 					hotSetStatus("abort");
/******/ 					return callback(result);
/******/ 				}
/******/ 				appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 				addAllToSet(outdatedModules, result[0]);
/******/ 				for(var moduleId in result[1]) {
/******/ 					if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
/******/ 						if(!outdatedDependencies[moduleId])
/******/ 							outdatedDependencies[moduleId] = [];
/******/ 						addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(var i = 0; i < outdatedModules.length; i++) {
/******/ 			var moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			var moduleId = queue.pop();
/******/ 			var module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(var j = 0; j < disposeHandlers.length; j++) {
/******/ 				var cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(var j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				var idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 					var dependency = moduleOutdatedDependencies[j];
/******/ 					var idx = module.children.indexOf(dependency);
/******/ 					if(idx >= 0) module.children.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(var moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					var dependency = moduleOutdatedDependencies[i];
/******/ 					var cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(var i = 0; i < callbacks.length; i++) {
/******/ 					var cb = callbacks[i];
/******/ 					try {
/******/ 						cb(outdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			var moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else if(!error)
/******/ 					error = err;
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return callback(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		callback(null, outdatedModules);
/******/ 	}

/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: hotCurrentParents,
/******/ 			children: []
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";

/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };

/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(2);
	__webpack_require__(75);
	module.exports = __webpack_require__(77);


/***/ }),
/* 1 */,
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__resourceQuery) {var url = __webpack_require__(3);
	var SockJS = __webpack_require__(11);
	var stripAnsi = __webpack_require__(73);
	var scriptElements = document.getElementsByTagName("script");
	var scriptHost = scriptElements[scriptElements.length-1].getAttribute("src").replace(/\/[^\/]+$/, "");

	// If this bundle is inlined, use the resource query to get the correct url.
	// Else, get the url from the <script> this file was called with.
	var urlParts = url.parse( true ?
		__resourceQuery.substr(1) :
		(scriptHost ? scriptHost : "/")
	);

	var sock = null;
	var hot = false;
	var initial = true;
	var currentHash = "";

	var onSocketMsg = {
		hot: function() {
			hot = true;
			console.log("[WDS] Hot Module Replacement enabled.");
		},
		invalid: function() {
			console.log("[WDS] App updated. Recompiling...");
		},
		hash: function(hash) {
			currentHash = hash;
		},
		"still-ok": function() {
			console.log("[WDS] Nothing changed.")
		},
		ok: function() {
			if(initial) return initial = false;
			reloadApp();
		},
		warnings: function(warnings) {
			console.log("[WDS] Warnings while compiling.");
			for(var i = 0; i < warnings.length; i++)
				console.warn(stripAnsi(warnings[i]));
			if(initial) return initial = false;
			reloadApp();
		},
		errors: function(errors) {
			console.log("[WDS] Errors while compiling.");
			for(var i = 0; i < errors.length; i++)
				console.error(stripAnsi(errors[i]));
			if(initial) return initial = false;
			reloadApp();
		},
		"proxy-error": function(errors) {
			console.log("[WDS] Proxy error.");
			for(var i = 0; i < errors.length; i++)
				console.error(stripAnsi(errors[i]));
			if(initial) return initial = false;
			reloadApp();
		}
	};

	var newConnection = function() {
		sock = new SockJS(url.format({
			protocol: urlParts.protocol,
			auth: urlParts.auth,
			hostname: (urlParts.hostname === '0.0.0.0') ? window.location.hostname : urlParts.hostname,
			port: urlParts.port,
			pathname: urlParts.path === '/' ? "/sockjs-node" : urlParts.path
		}));

		sock.onclose = function() {
			console.error("[WDS] Disconnected!");

			// Try to reconnect.
			sock = null;
			setTimeout(function () {
				newConnection();
			}, 2000);
		};

		sock.onmessage = function(e) {
			// This assumes that all data sent via the websocket is JSON.
			var msg = JSON.parse(e.data);
			onSocketMsg[msg.type](msg.data);
		};
	};

	newConnection();

	function reloadApp() {
		if(hot) {
			console.log("[WDS] App hot update...");
			window.postMessage("webpackHotUpdate" + currentHash, "*");
		} else {
			console.log("[WDS] App updated. Reloading...");
			window.location.reload();
		}
	}

	/* WEBPACK VAR INJECTION */}.call(exports, "?http://localhost:8188"))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var punycode = __webpack_require__(4);
	var util = __webpack_require__(7);

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,


	// Special case for a simple path URL
	simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


	// RFC 2396: characters reserved for delimiting URLs.
	// We actually just auto-escape these.
	delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


	// RFC 2396: characters not allowed for various reasons.
	unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


	// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	autoEscape = ['\''].concat(unwise),

	// Characters that are never ever allowed in a hostname.
	// Note that any invalid chars are also handled, but these
	// are the ones that are *expected* to be seen, so we fast-path
	// them.
	nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

	// protocols that can allow "unsafe" and "unwise" chars.
	unsafeProtocol = {
	  'javascript': true,
	  'javascript:': true
	},

	// protocols that never have a hostname.
	hostlessProtocol = {
	  'javascript': true,
	  'javascript:': true
	},

	// protocols that always contain a // bit.
	slashedProtocol = {
	  'http': true,
	  'https': true,
	  'ftp': true,
	  'gopher': true,
	  'file': true,
	  'http:': true,
	  'https:': true,
	  'ftp:': true,
	  'gopher:': true,
	  'file:': true
	},
	    querystring = __webpack_require__(8);

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && util.isObject(url) && url instanceof Url) return url;

	  var u = new Url();
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
	  if (!util.isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + (typeof url === 'undefined' ? 'undefined' : _typeof(url)));
	  }

	  // Copy chrome, IE, opera backslash-handling behavior.
	  // Back slashes before the query string get converted to forward slashes
	  // See: https://code.google.com/p/chromium/issues/detail?id=25916
	  var queryIndex = url.indexOf('?'),
	      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
	      uSplit = url.split(splitter),
	      slashRegex = /\\/g;
	  uSplit[0] = uSplit[0].replace(slashRegex, '/');
	  url = uSplit.join(splitter);

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  if (!slashesDenoteHost && url.split('#').length === 1) {
	    // Try fast path regexp
	    var simplePath = simplePathPattern.exec(rest);
	    if (simplePath) {
	      this.path = rest;
	      this.href = rest;
	      this.pathname = simplePath[1];
	      if (simplePath[2]) {
	        this.search = simplePath[2];
	        if (parseQueryString) {
	          this.query = querystring.parse(this.search.substr(1));
	        } else {
	          this.query = this.search.substr(1);
	        }
	      } else if (parseQueryString) {
	        this.search = '';
	        this.query = {};
	      }
	      return this;
	    }
	  }

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1) hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a punycoded representation of "domain".
	      // It only converts parts of the domain name that
	      // have non-ASCII characters, i.e. it doesn't matter if
	      // you call it with a domain that already is ASCII-only.
	      this.hostname = punycode.toASCII(this.hostname);
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      if (rest.indexOf(ae) === -1) continue;
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }

	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (util.isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function () {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || query && '?' + query || '';

	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function (match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function (relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function (relative) {
	  if (util.isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  var tkeys = Object.keys(this);
	  for (var tk = 0; tk < tkeys.length; tk++) {
	    var tkey = tkeys[tk];
	    result[tkey] = this[tkey];
	  }

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    var rkeys = Object.keys(relative);
	    for (var rk = 0; rk < rkeys.length; rk++) {
	      var rkey = rkeys[rk];
	      if (rkey !== 'protocol') result[rkey] = relative[rkey];
	    }

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      var keys = Object.keys(relative);
	      for (var v = 0; v < keys.length; v++) {
	        var k = keys[v];
	        result[k] = relative[k];
	      }
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift())) {}
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
	      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
	      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = relative.host || relative.host === '' ? relative.host : result.host;
	    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!util.isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especially happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last === '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especially happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || result.host && srcPath.length;

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function () {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/*! https://mths.be/punycode v1.4.1 by @mathias */
	;(function (root) {

		/** Detect free variables */
		var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
		var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
		var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
			root = freeGlobal;
		}

		/**
	  * The `punycode` object.
	  * @name punycode
	  * @type Object
	  */
		var punycode,


		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647,
		    // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		    tMin = 1,
		    tMax = 26,
		    skew = 38,
		    damp = 700,
		    initialBias = 72,
		    initialN = 128,
		    // 0x80
		delimiter = '-',
		    // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		    regexNonASCII = /[^\x20-\x7E]/,
		    // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
		    // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},


		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		    floor = Math.floor,
		    stringFromCharCode = String.fromCharCode,


		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
	  * A generic error utility function.
	  * @private
	  * @param {String} type The error type.
	  * @returns {Error} Throws a `RangeError` with the applicable error message.
	  */
		function error(type) {
			throw new RangeError(errors[type]);
		}

		/**
	  * A generic `Array#map` utility function.
	  * @private
	  * @param {Array} array The array to iterate over.
	  * @param {Function} callback The function that gets called for every array
	  * item.
	  * @returns {Array} A new array of values returned by the callback function.
	  */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
	  * A simple `Array#map`-like wrapper to work with domain name strings or email
	  * addresses.
	  * @private
	  * @param {String} domain The domain name or email address.
	  * @param {Function} callback The function that gets called for every
	  * character.
	  * @returns {Array} A new string of characters returned by the callback
	  * function.
	  */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
	  * Creates an array containing the numeric code points of each Unicode
	  * character in the string. While JavaScript uses UCS-2 internally,
	  * this function will convert a pair of surrogate halves (each of which
	  * UCS-2 exposes as separate characters) into a single code point,
	  * matching UTF-16.
	  * @see `punycode.ucs2.encode`
	  * @see <https://mathiasbynens.be/notes/javascript-encoding>
	  * @memberOf punycode.ucs2
	  * @name decode
	  * @param {String} string The Unicode input string (UCS-2).
	  * @returns {Array} The new array of code points.
	  */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) {
						// low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
	  * Creates a string based on an array of numeric code points.
	  * @see `punycode.ucs2.decode`
	  * @memberOf punycode.ucs2
	  * @name encode
	  * @param {Array} codePoints The array of numeric code points.
	  * @returns {String} The new Unicode string (UCS-2).
	  */
		function ucs2encode(array) {
			return map(array, function (value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
	  * Converts a basic code point into a digit/integer.
	  * @see `digitToBasic()`
	  * @private
	  * @param {Number} codePoint The basic numeric code point value.
	  * @returns {Number} The numeric value of a basic code point (for use in
	  * representing integers) in the range `0` to `base - 1`, or `base` if
	  * the code point does not represent a value.
	  */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
	  * Converts a digit/integer into a basic code point.
	  * @see `basicToDigit()`
	  * @private
	  * @param {Number} digit The numeric value of a basic code point.
	  * @returns {Number} The basic code point whose value (when used for
	  * representing integers) is `digit`, which needs to be in the range
	  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	  * used; else, the lowercase form is used. The behavior is undefined
	  * if `flag` is non-zero and `digit` has no uppercase form.
	  */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
	  * Bias adaptation function as per section 3.4 of RFC 3492.
	  * https://tools.ietf.org/html/rfc3492#section-3.4
	  * @private
	  */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
	  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	  * symbols.
	  * @memberOf punycode
	  * @param {String} input The Punycode string of ASCII-only symbols.
	  * @returns {String} The resulting string of Unicode symbols.
	  */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,

			/** Cached calculation results */
			baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;
				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
			}

			return ucs2encode(output);
		}

		/**
	  * Converts a string of Unicode symbols (e.g. a domain name label) to a
	  * Punycode string of ASCII-only symbols.
	  * @memberOf punycode
	  * @param {String} input The string of Unicode symbols.
	  * @returns {String} The resulting Punycode string of ASCII-only symbols.
	  */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],

			/** `inputLength` will hold the number of code points in `input`. */
			inputLength,

			/** Cached calculation results */
			handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base;; /* no condition */k += base) {
							t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;
			}
			return output.join('');
		}

		/**
	  * Converts a Punycode string representing a domain name or an email address
	  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	  * it doesn't matter if you call it on a string that has already been
	  * converted to Unicode.
	  * @memberOf punycode
	  * @param {String} input The Punycoded domain name or email address to
	  * convert to Unicode.
	  * @returns {String} The Unicode representation of the given Punycode
	  * string.
	  */
		function toUnicode(input) {
			return mapDomain(input, function (string) {
				return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
			});
		}

		/**
	  * Converts a Unicode string representing a domain name or an email address to
	  * Punycode. Only the non-ASCII parts of the domain name will be converted,
	  * i.e. it doesn't matter if you call it with a domain that's already in
	  * ASCII.
	  * @memberOf punycode
	  * @param {String} input The domain name or email address to convert, as a
	  * Unicode string.
	  * @returns {String} The Punycode representation of the given domain name or
	  * email address.
	  */
		function toASCII(input) {
			return mapDomain(input, function (string) {
				return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
	   * A string representing the current Punycode.js version number.
	   * @memberOf punycode
	   * @type String
	   */
			'version': '1.4.1',
			/**
	   * An object of methods to convert from JavaScript's internal character
	   * representation (UCS-2) to Unicode code points, and back.
	   * @see <https://mathiasbynens.be/notes/javascript-encoding>
	   * @memberOf punycode
	   * @type Object
	   */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if ("function" == 'function' && _typeof(__webpack_require__(6)) == 'object' && __webpack_require__(6)) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) {
				// in Node.js, io.js, or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.punycode = punycode;
		}
	})(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)(module), (function() { return this; }())))

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	module.exports = {
	  isString: function isString(arg) {
	    return typeof arg === 'string';
	  },
	  isObject: function isObject(arg) {
	    return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
	  },
	  isNull: function isNull(arg) {
	    return arg === null;
	  },
	  isNullOrUndefined: function isNullOrUndefined(arg) {
	    return arg == null;
	  }
	};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(9);
	exports.encode = exports.stringify = __webpack_require__(10);

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function (qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr,
	        vstr,
	        k,
	        v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var stringifyPrimitive = function stringifyPrimitive(v) {
	  switch (typeof v === 'undefined' ? 'undefined' : _typeof(v)) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function (obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    return Object.keys(obj).map(function (k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function (v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
	};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var transportList = __webpack_require__(12);

	module.exports = __webpack_require__(57)(transportList);

	// TODO can't get rid of this until all servers do
	if ('_sockjs_onload' in global) {
	  setTimeout(global._sockjs_onload, 1);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = [
	// streaming transports
	__webpack_require__(13), __webpack_require__(29), __webpack_require__(39), __webpack_require__(41), __webpack_require__(44)(__webpack_require__(41))

	// polling transports
	, __webpack_require__(50), __webpack_require__(44)(__webpack_require__(50)), __webpack_require__(52), __webpack_require__(53), __webpack_require__(44)(__webpack_require__(52)), __webpack_require__(54)];

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var utils = __webpack_require__(15),
	    urlUtils = __webpack_require__(18),
	    inherits = __webpack_require__(25),
	    EventEmitter = __webpack_require__(26).EventEmitter,
	    WebsocketDriver = __webpack_require__(28);

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:websocket');
	}

	function WebSocketTransport(transUrl, ignore, options) {
	  if (!WebSocketTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }

	  EventEmitter.call(this);
	  debug('constructor', transUrl);

	  var self = this;
	  var url = urlUtils.addPath(transUrl, '/websocket');
	  if (url.slice(0, 5) === 'https') {
	    url = 'wss' + url.slice(5);
	  } else {
	    url = 'ws' + url.slice(4);
	  }
	  this.url = url;

	  this.ws = new WebsocketDriver(this.url, [], options);
	  this.ws.onmessage = function (e) {
	    debug('message event', e.data);
	    self.emit('message', e.data);
	  };
	  // Firefox has an interesting bug. If a websocket connection is
	  // created after onunload, it stays alive even when user
	  // navigates away from the page. In such situation let's lie -
	  // let's not open the ws connection at all. See:
	  // https://github.com/sockjs/sockjs-client/issues/28
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
	  this.unloadRef = utils.unloadAdd(function () {
	    debug('unload');
	    self.ws.close();
	  });
	  this.ws.onclose = function (e) {
	    debug('close event', e.code, e.reason);
	    self.emit('close', e.code, e.reason);
	    self._cleanup();
	  };
	  this.ws.onerror = function (e) {
	    debug('error event', e);
	    self.emit('close', 1006, 'WebSocket connection broken');
	    self._cleanup();
	  };
	}

	inherits(WebSocketTransport, EventEmitter);

	WebSocketTransport.prototype.send = function (data) {
	  var msg = '[' + data + ']';
	  debug('send', msg);
	  this.ws.send(msg);
	};

	WebSocketTransport.prototype.close = function () {
	  debug('close');
	  var ws = this.ws;
	  this._cleanup();
	  if (ws) {
	    ws.close();
	  }
	};

	WebSocketTransport.prototype._cleanup = function () {
	  debug('_cleanup');
	  var ws = this.ws;
	  if (ws) {
	    ws.onmessage = ws.onclose = ws.onerror = null;
	  }
	  utils.unloadDel(this.unloadRef);
	  this.unloadRef = this.ws = null;
	  this.removeAllListeners();
	};

	WebSocketTransport.enabled = function () {
	  debug('enabled');
	  return !!WebsocketDriver;
	};
	WebSocketTransport.transportName = 'websocket';

	// In theory, ws should require 1 round trip. But in chrome, this is
	// not very stable over SSL. Most likely a ws connection requires a
	// separate SSL connection, in which case 2 round trips are an
	// absolute minumum.
	WebSocketTransport.roundTrips = 2;

	module.exports = WebSocketTransport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	'use strict';

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) {
	    return [];
	};

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var random = __webpack_require__(16);

	var onUnload = {},
	    afterUnload = false
	// detect google chrome packaged apps because they don't allow the 'unload' event
	,
	    isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime;

	module.exports = {
	  attachEvent: function attachEvent(event, listener) {
	    if (typeof global.addEventListener !== 'undefined') {
	      global.addEventListener(event, listener, false);
	    } else if (global.document && global.attachEvent) {
	      // IE quirks.
	      // According to: http://stevesouders.com/misc/test-postmessage.php
	      // the message gets delivered only to 'document', not 'window'.
	      global.document.attachEvent('on' + event, listener);
	      // I get 'window' for ie8.
	      global.attachEvent('on' + event, listener);
	    }
	  },

	  detachEvent: function detachEvent(event, listener) {
	    if (typeof global.addEventListener !== 'undefined') {
	      global.removeEventListener(event, listener, false);
	    } else if (global.document && global.detachEvent) {
	      global.document.detachEvent('on' + event, listener);
	      global.detachEvent('on' + event, listener);
	    }
	  },

	  unloadAdd: function unloadAdd(listener) {
	    if (isChromePackagedApp) {
	      return null;
	    }

	    var ref = random.string(8);
	    onUnload[ref] = listener;
	    if (afterUnload) {
	      setTimeout(this.triggerUnloadCallbacks, 0);
	    }
	    return ref;
	  },

	  unloadDel: function unloadDel(ref) {
	    if (ref in onUnload) {
	      delete onUnload[ref];
	    }
	  },

	  triggerUnloadCallbacks: function triggerUnloadCallbacks() {
	    for (var ref in onUnload) {
	      onUnload[ref]();
	      delete onUnload[ref];
	    }
	  }
	};

	var unloadTriggered = function unloadTriggered() {
	  if (afterUnload) {
	    return;
	  }
	  afterUnload = true;
	  module.exports.triggerUnloadCallbacks();
	};

	// 'unload' alone is not reliable in opera within an iframe, but we
	// can't use `beforeunload` as IE fires it on javascript: links.
	if (!isChromePackagedApp) {
	  module.exports.attachEvent('unload', unloadTriggered);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	/* global crypto:true */

	var crypto = __webpack_require__(17);

	// This string has length 32, a power of 2, so the modulus doesn't introduce a
	// bias.
	var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
	module.exports = {
	  string: function string(length) {
	    var max = _randomStringChars.length;
	    var bytes = crypto.randomBytes(length);
	    var ret = [];
	    for (var i = 0; i < length; i++) {
	      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
	    }
	    return ret.join('');
	  },

	  number: function number(max) {
	    return Math.floor(Math.random() * max);
	  },

	  numberString: function numberString(max) {
	    var t = ('' + (max - 1)).length;
	    var p = new Array(t + 1).join('0');
	    return (p + this.number(max)).slice(-t);
	  }
	};

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	if (global.crypto && global.crypto.getRandomValues) {
	  module.exports.randomBytes = function (length) {
	    var bytes = new Uint8Array(length);
	    global.crypto.getRandomValues(bytes);
	    return bytes;
	  };
	} else {
	  module.exports.randomBytes = function (length) {
	    var bytes = new Array(length);
	    for (var i = 0; i < length; i++) {
	      bytes[i] = Math.floor(Math.random() * 256);
	    }
	    return bytes;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var URL = __webpack_require__(19);

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:utils:url');
	}

	module.exports = {
	  getOrigin: function getOrigin(url) {
	    if (!url) {
	      return null;
	    }

	    var p = new URL(url);
	    if (p.protocol === 'file:') {
	      return null;
	    }

	    var port = p.port;
	    if (!port) {
	      port = p.protocol === 'https:' ? '443' : '80';
	    }

	    return p.protocol + '//' + p.hostname + ':' + port;
	  },

	  isOriginEqual: function isOriginEqual(a, b) {
	    var res = this.getOrigin(a) === this.getOrigin(b);
	    debug('same', a, b, res);
	    return res;
	  },

	  isSchemeEqual: function isSchemeEqual(a, b) {
	    return a.split(':')[0] === b.split(':')[0];
	  },

	  addPath: function addPath(url, path) {
	    var qs = url.split('?');
	    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
	  },

	  addQuery: function addQuery(url, q) {
	    return url + (url.indexOf('?') === -1 ? '?' + q : '&' + q);
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var required = __webpack_require__(20),
	    qs = __webpack_require__(21),
	    protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i,
	    slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

	/**
	 * These are the parse rules for the URL parser, it informs the parser
	 * about:
	 *
	 * 0. The char it Needs to parse, if it's a string it should be done using
	 *    indexOf, RegExp using exec and NaN means set as current value.
	 * 1. The property we should set when parsing this value.
	 * 2. Indication if it's backwards or forward parsing, when set as number it's
	 *    the value of extra chars that should be split off.
	 * 3. Inherit from location if non existing in the parser.
	 * 4. `toLowerCase` the resulting value.
	 */
	var rules = [['#', 'hash'], // Extract from the back.
	['?', 'query'], // Extract from the back.
	['/', 'pathname'], // Extract from the back.
	['@', 'auth', 1], // Extract from the front.
	[NaN, 'host', undefined, 1, 1], // Set left over value.
	[/:(\d+)$/, 'port', undefined, 1], // RegExp the back.
	[NaN, 'hostname', undefined, 1, 1] // Set left over.
	];

	/**
	 * These properties should not be copied or inherited from. This is only needed
	 * for all non blob URL's as a blob URL does not include a hash, only the
	 * origin.
	 *
	 * @type {Object}
	 * @private
	 */
	var ignore = { hash: 1, query: 1 };

	/**
	 * The location object differs when your code is loaded through a normal page,
	 * Worker or through a worker using a blob. And with the blobble begins the
	 * trouble as the location object will contain the URL of the blob, not the
	 * location of the page where our code is loaded in. The actual origin is
	 * encoded in the `pathname` so we can thankfully generate a good "default"
	 * location from it so we can generate proper relative URL's again.
	 *
	 * @param {Object|String} loc Optional default location object.
	 * @returns {Object} lolcation object.
	 * @api public
	 */
	function lolcation(loc) {
	  loc = loc || global.location || {};

	  var finaldestination = {},
	      type = typeof loc === 'undefined' ? 'undefined' : _typeof(loc),
	      key;

	  if ('blob:' === loc.protocol) {
	    finaldestination = new URL(unescape(loc.pathname), {});
	  } else if ('string' === type) {
	    finaldestination = new URL(loc, {});
	    for (key in ignore) {
	      delete finaldestination[key];
	    }
	  } else if ('object' === type) {
	    for (key in loc) {
	      if (key in ignore) continue;
	      finaldestination[key] = loc[key];
	    }

	    if (finaldestination.slashes === undefined) {
	      finaldestination.slashes = slashes.test(loc.href);
	    }
	  }

	  return finaldestination;
	}

	/**
	 * @typedef ProtocolExtract
	 * @type Object
	 * @property {String} protocol Protocol matched in the URL, in lowercase.
	 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
	 * @property {String} rest Rest of the URL that is not part of the protocol.
	 */

	/**
	 * Extract protocol information from a URL with/without double slash ("//").
	 *
	 * @param {String} address URL we want to extract from.
	 * @return {ProtocolExtract} Extracted information.
	 * @api private
	 */
	function extractProtocol(address) {
	  var match = protocolre.exec(address);

	  return {
	    protocol: match[1] ? match[1].toLowerCase() : '',
	    slashes: !!match[2],
	    rest: match[3]
	  };
	}

	/**
	 * Resolve a relative URL pathname against a base URL pathname.
	 *
	 * @param {String} relative Pathname of the relative URL.
	 * @param {String} base Pathname of the base URL.
	 * @return {String} Resolved pathname.
	 * @api private
	 */
	function resolve(relative, base) {
	  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/')),
	      i = path.length,
	      last = path[i - 1],
	      unshift = false,
	      up = 0;

	  while (i--) {
	    if (path[i] === '.') {
	      path.splice(i, 1);
	    } else if (path[i] === '..') {
	      path.splice(i, 1);
	      up++;
	    } else if (up) {
	      if (i === 0) unshift = true;
	      path.splice(i, 1);
	      up--;
	    }
	  }

	  if (unshift) path.unshift('');
	  if (last === '.' || last === '..') path.push('');

	  return path.join('/');
	}

	/**
	 * The actual URL instance. Instead of returning an object we've opted-in to
	 * create an actual constructor as it's much more memory efficient and
	 * faster and it pleases my OCD.
	 *
	 * @constructor
	 * @param {String} address URL we want to parse.
	 * @param {Object|String} location Location defaults for relative paths.
	 * @param {Boolean|Function} parser Parser for the query string.
	 * @api public
	 */
	function URL(address, location, parser) {
	  if (!(this instanceof URL)) {
	    return new URL(address, location, parser);
	  }

	  var relative,
	      extracted,
	      parse,
	      instruction,
	      index,
	      key,
	      instructions = rules.slice(),
	      type = typeof location === 'undefined' ? 'undefined' : _typeof(location),
	      url = this,
	      i = 0;

	  //
	  // The following if statements allows this module two have compatibility with
	  // 2 different API:
	  //
	  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
	  //    where the boolean indicates that the query string should also be parsed.
	  //
	  // 2. The `URL` interface of the browser which accepts a URL, object as
	  //    arguments. The supplied object will be used as default values / fall-back
	  //    for relative paths.
	  //
	  if ('object' !== type && 'string' !== type) {
	    parser = location;
	    location = null;
	  }

	  if (parser && 'function' !== typeof parser) parser = qs.parse;

	  location = lolcation(location);

	  //
	  // Extract protocol information before running the instructions.
	  //
	  extracted = extractProtocol(address || '');
	  relative = !extracted.protocol && !extracted.slashes;
	  url.slashes = extracted.slashes || relative && location.slashes;
	  url.protocol = extracted.protocol || location.protocol || '';
	  address = extracted.rest;

	  //
	  // When the authority component is absent the URL starts with a path
	  // component.
	  //
	  if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];

	  for (; i < instructions.length; i++) {
	    instruction = instructions[i];
	    parse = instruction[0];
	    key = instruction[1];

	    if (parse !== parse) {
	      url[key] = address;
	    } else if ('string' === typeof parse) {
	      if (~(index = address.indexOf(parse))) {
	        if ('number' === typeof instruction[2]) {
	          url[key] = address.slice(0, index);
	          address = address.slice(index + instruction[2]);
	        } else {
	          url[key] = address.slice(index);
	          address = address.slice(0, index);
	        }
	      }
	    } else if (index = parse.exec(address)) {
	      url[key] = index[1];
	      address = address.slice(0, index.index);
	    }

	    url[key] = url[key] || (relative && instruction[3] ? location[key] || '' : '');

	    //
	    // Hostname, host and protocol should be lowercased so they can be used to
	    // create a proper `origin`.
	    //
	    if (instruction[4]) url[key] = url[key].toLowerCase();
	  }

	  //
	  // Also parse the supplied query string in to an object. If we're supplied
	  // with a custom parser as function use that instead of the default build-in
	  // parser.
	  //
	  if (parser) url.query = parser(url.query);

	  //
	  // If the URL is relative, resolve the pathname against the base URL.
	  //
	  if (relative && location.slashes && url.pathname.charAt(0) !== '/' && (url.pathname !== '' || location.pathname !== '')) {
	    url.pathname = resolve(url.pathname, location.pathname);
	  }

	  //
	  // We should not add port numbers if they are already the default port number
	  // for a given protocol. As the host also contains the port number we're going
	  // override it with the hostname which contains no port number.
	  //
	  if (!required(url.port, url.protocol)) {
	    url.host = url.hostname;
	    url.port = '';
	  }

	  //
	  // Parse down the `auth` for the username and password.
	  //
	  url.username = url.password = '';
	  if (url.auth) {
	    instruction = url.auth.split(':');
	    url.username = instruction[0] || '';
	    url.password = instruction[1] || '';
	  }

	  url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol + '//' + url.host : 'null';

	  //
	  // The href is just the compiled result.
	  //
	  url.href = url.toString();
	}

	/**
	 * This is convenience method for changing properties in the URL instance to
	 * insure that they all propagate correctly.
	 *
	 * @param {String} part          Property we need to adjust.
	 * @param {Mixed} value          The newly assigned value.
	 * @param {Boolean|Function} fn  When setting the query, it will be the function
	 *                               used to parse the query.
	 *                               When setting the protocol, double slash will be
	 *                               removed from the final url if it is true.
	 * @returns {URL}
	 * @api public
	 */
	function set(part, value, fn) {
	  var url = this;

	  switch (part) {
	    case 'query':
	      if ('string' === typeof value && value.length) {
	        value = (fn || qs.parse)(value);
	      }

	      url[part] = value;
	      break;

	    case 'port':
	      url[part] = value;

	      if (!required(value, url.protocol)) {
	        url.host = url.hostname;
	        url[part] = '';
	      } else if (value) {
	        url.host = url.hostname + ':' + value;
	      }

	      break;

	    case 'hostname':
	      url[part] = value;

	      if (url.port) value += ':' + url.port;
	      url.host = value;
	      break;

	    case 'host':
	      url[part] = value;

	      if (/:\d+$/.test(value)) {
	        value = value.split(':');
	        url.port = value.pop();
	        url.hostname = value.join(':');
	      } else {
	        url.hostname = value;
	        url.port = '';
	      }

	      break;

	    case 'protocol':
	      url.protocol = value.toLowerCase();
	      url.slashes = !fn;
	      break;

	    case 'pathname':
	    case 'hash':
	      if (value) {
	        var char = part === 'pathname' ? '/' : '#';
	        url[part] = value.charAt(0) !== char ? char + value : value;
	      } else {
	        url[part] = value;
	      }
	      break;

	    default:
	      url[part] = value;
	  }

	  for (var i = 0; i < rules.length; i++) {
	    var ins = rules[i];

	    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
	  }

	  url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol + '//' + url.host : 'null';

	  url.href = url.toString();

	  return url;
	}

	/**
	 * Transform the properties back in to a valid and full URL string.
	 *
	 * @param {Function} stringify Optional query stringify function.
	 * @returns {String}
	 * @api public
	 */
	function toString(stringify) {
	  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

	  var query,
	      url = this,
	      protocol = url.protocol;

	  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

	  var result = protocol + (url.slashes ? '//' : '');

	  if (url.username) {
	    result += url.username;
	    if (url.password) result += ':' + url.password;
	    result += '@';
	  }

	  result += url.host + url.pathname;

	  query = 'object' === _typeof(url.query) ? stringify(url.query) : url.query;
	  if (query) result += '?' !== query.charAt(0) ? '?' + query : query;

	  if (url.hash) result += url.hash;

	  return result;
	}

	URL.prototype = { set: set, toString: toString };

	//
	// Expose the URL parser and some additional properties that might be useful for
	// others or testing.
	//
	URL.extractProtocol = extractProtocol;
	URL.location = lolcation;
	URL.qs = qs;

	module.exports = URL;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Check if we're required to add a port number.
	 *
	 * @see https://url.spec.whatwg.org/#default-port
	 * @param {Number|String} port Port number we need to check
	 * @param {String} protocol Protocol we need to check against.
	 * @returns {Boolean} Is it a default port for the given protocol
	 * @api private
	 */

	module.exports = function required(port, protocol) {
	  protocol = protocol.split(':')[0];
	  port = +port;

	  if (!port) return false;

	  switch (protocol) {
	    case 'http':
	    case 'ws':
	      return port !== 80;

	    case 'https':
	    case 'wss':
	      return port !== 443;

	    case 'ftp':
	      return port !== 21;

	    case 'gopher':
	      return port !== 70;

	    case 'file':
	      return false;
	  }

	  return port !== 0;
	};

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	'use strict';

	var has = Object.prototype.hasOwnProperty;

	/**
	 * Decode a URI encoded string.
	 *
	 * @param {String} input The URI encoded string.
	 * @returns {String} The decoded string.
	 * @api private
	 */
	function decode(input) {
	  return decodeURIComponent(input.replace(/\+/g, ' '));
	}

	/**
	 * Simple query string parser.
	 *
	 * @param {String} query The query string that needs to be parsed.
	 * @returns {Object}
	 * @api public
	 */
	function querystring(query) {
	  var parser = /([^=?&]+)=?([^&]*)/g,
	      result = {},
	      part;

	  //
	  // Little nifty parsing hack, leverage the fact that RegExp.exec increments
	  // the lastIndex property so we can continue executing this loop until we've
	  // parsed all results.
	  //
	  for (; part = parser.exec(query); result[decode(part[1])] = decode(part[2])) {}

	  return result;
	}

	/**
	 * Transform a query string to an object.
	 *
	 * @param {Object} obj Object that should be transformed.
	 * @param {String} prefix Optional prefix.
	 * @returns {String}
	 * @api public
	 */
	function querystringify(obj, prefix) {
	  prefix = prefix || '';

	  var pairs = [];

	  //
	  // Optionally prefix with a '?' if needed
	  //
	  if ('string' !== typeof prefix) prefix = '?';

	  for (var key in obj) {
	    if (has.call(obj, key)) {
	      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));
	    }
	  }

	  return pairs.length ? prefix + pairs.join('&') : '';
	}

	//
	// Expose the module.
	//
	exports.stringify = querystringify;
	exports.parse = querystring;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(23);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

	/**
	 * Colors.
	 */

	exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	    return true;
	  }

	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
	  // is firebug? http://stackoverflow.com/a/398120/376773
	  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
	  // is firefox >= v31?
	  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
	  // double check webkit in userAgent just in case we are in a worker
	  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function (v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};

	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs(args) {
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

	  if (!useColors) return;

	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit');

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function (match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch (e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch (e) {}

	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (!r && typeof process !== 'undefined' && 'env' in process) {
	    r = process.env.DEBUG;
	  }

	  return r;
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(24);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */

	exports.formatters = {};

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */

	function selectColor(namespace) {
	  var hash = 0,
	      i;

	  for (i in namespace) {
	    hash = (hash << 5) - hash + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }

	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function createDebug(namespace) {

	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;

	    var self = debug;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);

	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }

	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);

	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }

	  return debug;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  exports.names = [];
	  exports.skips = [];

	  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}

/***/ }),
/* 24 */
/***/ (function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function (val, options) {
	  options = options || {};
	  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) {
	    return;
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name;
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}

/***/ }),
/* 25 */
/***/ (function(module, exports) {

	'use strict';

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function TempCtor() {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var inherits = __webpack_require__(25),
	    EventTarget = __webpack_require__(27);

	function EventEmitter() {
	  EventTarget.call(this);
	}

	inherits(EventEmitter, EventTarget);

	EventEmitter.prototype.removeAllListeners = function (type) {
	  if (type) {
	    delete this._listeners[type];
	  } else {
	    this._listeners = {};
	  }
	};

	EventEmitter.prototype.once = function (type, listener) {
	  var self = this,
	      fired = false;

	  function g() {
	    self.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  this.on(type, g);
	};

	EventEmitter.prototype.emit = function () {
	  var type = arguments[0];
	  var listeners = this._listeners[type];
	  if (!listeners) {
	    return;
	  }
	  // equivalent of Array.prototype.slice.call(arguments, 1);
	  var l = arguments.length;
	  var args = new Array(l - 1);
	  for (var ai = 1; ai < l; ai++) {
	    args[ai - 1] = arguments[ai];
	  }
	  for (var i = 0; i < listeners.length; i++) {
	    listeners[i].apply(this, args);
	  }
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
	EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

	module.exports.EventEmitter = EventEmitter;

/***/ }),
/* 27 */
/***/ (function(module, exports) {

	'use strict';

	/* Simplified implementation of DOM2 EventTarget.
	 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
	 */

	function EventTarget() {
	  this._listeners = {};
	}

	EventTarget.prototype.addEventListener = function (eventType, listener) {
	  if (!(eventType in this._listeners)) {
	    this._listeners[eventType] = [];
	  }
	  var arr = this._listeners[eventType];
	  // #4
	  if (arr.indexOf(listener) === -1) {
	    // Make a copy so as not to interfere with a current dispatchEvent.
	    arr = arr.concat([listener]);
	  }
	  this._listeners[eventType] = arr;
	};

	EventTarget.prototype.removeEventListener = function (eventType, listener) {
	  var arr = this._listeners[eventType];
	  if (!arr) {
	    return;
	  }
	  var idx = arr.indexOf(listener);
	  if (idx !== -1) {
	    if (arr.length > 1) {
	      // Make a copy so as not to interfere with a current dispatchEvent.
	      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
	    } else {
	      delete this._listeners[eventType];
	    }
	    return;
	  }
	};

	EventTarget.prototype.dispatchEvent = function () {
	  var event = arguments[0];
	  var t = event.type;
	  // equivalent of Array.prototype.slice.call(arguments, 0);
	  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
	  // TODO: This doesn't match the real behavior; per spec, onfoo get
	  // their place in line from the /first/ time they're set from
	  // non-null. Although WebKit bumps it to the end every time it's
	  // set.
	  if (this['on' + t]) {
	    this['on' + t].apply(this, args);
	  }
	  if (t in this._listeners) {
	    // Grab a reference to the listeners list. removeEventListener may alter the list.
	    var listeners = this._listeners[t];
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i].apply(this, args);
	    }
	  }
	};

	module.exports = EventTarget;

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var Driver = global.WebSocket || global.MozWebSocket;
	if (Driver) {
		module.exports = function WebSocketBrowserDriver(url) {
			return new Driver(url);
		};
	} else {
		module.exports = undefined;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var inherits = __webpack_require__(25),
	    AjaxBasedTransport = __webpack_require__(30),
	    XhrReceiver = __webpack_require__(34),
	    XHRCorsObject = __webpack_require__(35),
	    XHRLocalObject = __webpack_require__(37),
	    browser = __webpack_require__(38);

	function XhrStreamingTransport(transUrl) {
	  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
	}

	inherits(XhrStreamingTransport, AjaxBasedTransport);

	XhrStreamingTransport.enabled = function (info) {
	  if (info.nullOrigin) {
	    return false;
	  }
	  // Opera doesn't support xhr-streaming #60
	  // But it might be able to #92
	  if (browser.isOpera()) {
	    return false;
	  }

	  return XHRCorsObject.enabled;
	};

	XhrStreamingTransport.transportName = 'xhr-streaming';
	XhrStreamingTransport.roundTrips = 2; // preflight, ajax

	// Safari gets confused when a streaming ajax request is started
	// before onload. This causes the load indicator to spin indefinetely.
	// Only require body when used in a browser
	XhrStreamingTransport.needBody = !!global.document;

	module.exports = XhrStreamingTransport;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var inherits = __webpack_require__(25),
	    urlUtils = __webpack_require__(18),
	    SenderReceiver = __webpack_require__(31);

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:ajax-based');
	}

	function createAjaxSender(AjaxObject) {
	  return function (url, payload, callback) {
	    debug('create ajax sender', url, payload);
	    var opt = {};
	    if (typeof payload === 'string') {
	      opt.headers = { 'Content-type': 'text/plain' };
	    }
	    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
	    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
	    xo.once('finish', function (status) {
	      debug('finish', status);
	      xo = null;

	      if (status !== 200 && status !== 204) {
	        return callback(new Error('http status ' + status));
	      }
	      callback();
	    });
	    return function () {
	      debug('abort');
	      xo.close();
	      xo = null;

	      var err = new Error('Aborted');
	      err.code = 1000;
	      callback(err);
	    };
	  };
	}

	function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
	  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
	}

	inherits(AjaxBasedTransport, SenderReceiver);

	module.exports = AjaxBasedTransport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var inherits = __webpack_require__(25),
	    urlUtils = __webpack_require__(18),
	    BufferedSender = __webpack_require__(32),
	    Polling = __webpack_require__(33);

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:sender-receiver');
	}

	function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
	  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
	  debug(pollUrl);
	  var self = this;
	  BufferedSender.call(this, transUrl, senderFunc);

	  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
	  this.poll.on('message', function (msg) {
	    debug('poll message', msg);
	    self.emit('message', msg);
	  });
	  this.poll.once('close', function (code, reason) {
	    debug('poll close', code, reason);
	    self.poll = null;
	    self.emit('close', code, reason);
	    self.close();
	  });
	}

	inherits(SenderReceiver, BufferedSender);

	SenderReceiver.prototype.close = function () {
	  BufferedSender.prototype.close.call(this);
	  debug('close');
	  this.removeAllListeners();
	  if (this.poll) {
	    this.poll.abort();
	    this.poll = null;
	  }
	};

	module.exports = SenderReceiver;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var inherits = __webpack_require__(25),
	    EventEmitter = __webpack_require__(26).EventEmitter;

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:buffered-sender');
	}

	function BufferedSender(url, sender) {
	  debug(url);
	  EventEmitter.call(this);
	  this.sendBuffer = [];
	  this.sender = sender;
	  this.url = url;
	}

	inherits(BufferedSender, EventEmitter);

	BufferedSender.prototype.send = function (message) {
	  debug('send', message);
	  this.sendBuffer.push(message);
	  if (!this.sendStop) {
	    this.sendSchedule();
	  }
	};

	// For polling transports in a situation when in the message callback,
	// new message is being send. If the sending connection was started
	// before receiving one, it is possible to saturate the network and
	// timeout due to the lack of receiving socket. To avoid that we delay
	// sending messages by some small time, in order to let receiving
	// connection be started beforehand. This is only a halfmeasure and
	// does not fix the big problem, but it does make the tests go more
	// stable on slow networks.
	BufferedSender.prototype.sendScheduleWait = function () {
	  debug('sendScheduleWait');
	  var self = this;
	  var tref;
	  this.sendStop = function () {
	    debug('sendStop');
	    self.sendStop = null;
	    clearTimeout(tref);
	  };
	  tref = setTimeout(function () {
	    debug('timeout');
	    self.sendStop = null;
	    self.sendSchedule();
	  }, 25);
	};

	BufferedSender.prototype.sendSchedule = function () {
	  debug('sendSchedule', this.sendBuffer.length);
	  var self = this;
	  if (this.sendBuffer.length > 0) {
	    var payload = '[' + this.sendBuffer.join(',') + ']';
	    this.sendStop = this.sender(this.url, payload, function (err) {
	      self.sendStop = null;
	      if (err) {
	        debug('error', err);
	        self.emit('close', err.code || 1006, 'Sending error: ' + err);
	        self.close();
	      } else {
	        self.sendScheduleWait();
	      }
	    });
	    this.sendBuffer = [];
	  }
	};

	BufferedSender.prototype._cleanup = function () {
	  debug('_cleanup');
	  this.removeAllListeners();
	};

	BufferedSender.prototype.close = function () {
	  debug('close');
	  this._cleanup();
	  if (this.sendStop) {
	    this.sendStop();
	    this.sendStop = null;
	  }
	};

	module.exports = BufferedSender;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var inherits = __webpack_require__(25),
	    EventEmitter = __webpack_require__(26).EventEmitter;

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:polling');
	}

	function Polling(Receiver, receiveUrl, AjaxObject) {
	  debug(receiveUrl);
	  EventEmitter.call(this);
	  this.Receiver = Receiver;
	  this.receiveUrl = receiveUrl;
	  this.AjaxObject = AjaxObject;
	  this._scheduleReceiver();
	}

	inherits(Polling, EventEmitter);

	Polling.prototype._scheduleReceiver = function () {
	  debug('_scheduleReceiver');
	  var self = this;
	  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

	  poll.on('message', function (msg) {
	    debug('message', msg);
	    self.emit('message', msg);
	  });

	  poll.once('close', function (code, reason) {
	    debug('close', code, reason, self.pollIsClosing);
	    self.poll = poll = null;

	    if (!self.pollIsClosing) {
	      if (reason === 'network') {
	        self._scheduleReceiver();
	      } else {
	        self.emit('close', code || 1006, reason);
	        self.removeAllListeners();
	      }
	    }
	  });
	};

	Polling.prototype.abort = function () {
	  debug('abort');
	  this.removeAllListeners();
	  this.pollIsClosing = true;
	  if (this.poll) {
	    this.poll.abort();
	  }
	};

	module.exports = Polling;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var inherits = __webpack_require__(25),
	    EventEmitter = __webpack_require__(26).EventEmitter;

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:receiver:xhr');
	}

	function XhrReceiver(url, AjaxObject) {
	  debug(url);
	  EventEmitter.call(this);
	  var self = this;

	  this.bufferPosition = 0;

	  this.xo = new AjaxObject('POST', url, null);
	  this.xo.on('chunk', this._chunkHandler.bind(this));
	  this.xo.once('finish', function (status, text) {
	    debug('finish', status, text);
	    self._chunkHandler(status, text);
	    self.xo = null;
	    var reason = status === 200 ? 'network' : 'permanent';
	    debug('close', reason);
	    self.emit('close', null, reason);
	    self._cleanup();
	  });
	}

	inherits(XhrReceiver, EventEmitter);

	XhrReceiver.prototype._chunkHandler = function (status, text) {
	  debug('_chunkHandler', status);
	  if (status !== 200 || !text) {
	    return;
	  }

	  for (var idx = -1;; this.bufferPosition += idx + 1) {
	    var buf = text.slice(this.bufferPosition);
	    idx = buf.indexOf('\n');
	    if (idx === -1) {
	      break;
	    }
	    var msg = buf.slice(0, idx);
	    if (msg) {
	      debug('message', msg);
	      this.emit('message', msg);
	    }
	  }
	};

	XhrReceiver.prototype._cleanup = function () {
	  debug('_cleanup');
	  this.removeAllListeners();
	};

	XhrReceiver.prototype.abort = function () {
	  debug('abort');
	  if (this.xo) {
	    this.xo.close();
	    debug('close');
	    this.emit('close', null, 'user');
	    this.xo = null;
	  }
	  this._cleanup();
	};

	module.exports = XhrReceiver;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var inherits = __webpack_require__(25),
	    XhrDriver = __webpack_require__(36);

	function XHRCorsObject(method, url, payload, opts) {
	  XhrDriver.call(this, method, url, payload, opts);
	}

	inherits(XHRCorsObject, XhrDriver);

	XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

	module.exports = XHRCorsObject;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {'use strict';

	var EventEmitter = __webpack_require__(26).EventEmitter,
	    inherits = __webpack_require__(25),
	    utils = __webpack_require__(15),
	    urlUtils = __webpack_require__(18),
	    XHR = global.XMLHttpRequest;

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:browser:xhr');
	}

	function AbstractXHRObject(method, url, payload, opts) {
	  debug(method, url);
	  var self = this;
	  EventEmitter.call(this);

	  setTimeout(function () {
	    self._start(method, url, payload, opts);
	  }, 0);
	}

	inherits(AbstractXHRObject, EventEmitter);

	AbstractXHRObject.prototype._start = function (method, url, payload, opts) {
	  var self = this;

	  try {
	    this.xhr = new XHR();
	  } catch (x) {
	    // intentionally empty
	  }

	  if (!this.xhr) {
	    debug('no xhr');
	    this.emit('finish', 0, 'no xhr support');
	    this._cleanup();
	    return;
	  }

	  // several browsers cache POSTs
	  url = urlUtils.addQuery(url, 't=' + +new Date());

	  // Explorer tends to keep connection open, even after the
	  // tab gets closed: http://bugs.jquery.com/ticket/5280
	  this.unloadRef = utils.unloadAdd(function () {
	    debug('unload cleanup');
	    self._cleanup(true);
	  });
	  try {
	    this.xhr.open(method, url, true);
	    if (this.timeout && 'timeout' in this.xhr) {
	      this.xhr.timeout = this.timeout;
	      this.xhr.ontimeout = function () {
	        debug('xhr timeout');
	        self.emit('finish', 0, '');
	        self._cleanup(false);
	      };
	    }
	  } catch (e) {
	    debug('exception', e);
	    // IE raises an exception on wrong port.
	    this.emit('finish', 0, '');
	    this._cleanup(false);
	    return;
	  }

	  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
	    debug('withCredentials');
	    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
	    // "This never affects same-site requests."

	    this.xhr.withCredentials = 'true';
	  }
	  if (opts && opts.headers) {
	    for (var key in opts.headers) {
	      this.xhr.setRequestHeader(key, opts.headers[key]);
	    }
	  }

	  this.xhr.onreadystatechange = function () {
	    if (self.xhr) {
	      var x = self.xhr;
	      var text, status;
	      debug('readyState', x.readyState);
	      switch (x.readyState) {
	        case 3:
	          // IE doesn't like peeking into responseText or status
	          // on Microsoft.XMLHTTP and readystate=3
	          try {
	            status = x.status;
	            text = x.responseText;
	          } catch (e) {
	            // intentionally empty
	          }
	          debug('status', status);
	          // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
	          if (status === 1223) {
	            status = 204;
	          }

	          // IE does return readystate == 3 for 404 answers.
	          if (status === 200 && text && text.length > 0) {
	            debug('chunk');
	            self.emit('chunk', status, text);
	          }
	          break;
	        case 4:
	          status = x.status;
	          debug('status', status);
	          // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
	          if (status === 1223) {
	            status = 204;
	          }
	          // IE returns this for a bad port
	          // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
	          if (status === 12005 || status === 12029) {
	            status = 0;
	          }

	          debug('finish', status, x.responseText);
	          self.emit('finish', status, x.responseText);
	          self._cleanup(false);
	          break;
	      }
	    }
	  };

	  try {
	    self.xhr.send(payload);
	  } catch (e) {
	    self.emit('finish', 0, '');
	    self._cleanup(false);
	  }
	};

	AbstractXHRObject.prototype._cleanup = function (abort) {
	  debug('cleanup');
	  if (!this.xhr) {
	    return;
	  }
	  this.removeAllListeners();
	  utils.unloadDel(this.unloadRef);

	  // IE needs this field to be a function
	  this.xhr.onreadystatechange = function () {};
	  if (this.xhr.ontimeout) {
	    this.xhr.ontimeout = null;
	  }

	  if (abort) {
	    try {
	      this.xhr.abort();
	    } catch (x) {
	      // intentionally empty
	    }
	  }
	  this.unloadRef = this.xhr = null;
	};

	AbstractXHRObject.prototype.close = function () {
	  debug('close');
	  this._cleanup(true);
	};

	AbstractXHRObject.enabled = !!XHR;
	// override XMLHttpRequest for IE6/7
	// obfuscate to avoid firewalls
	var axo = ['Active'].concat('Object').join('X');
	if (!AbstractXHRObject.enabled && axo in global) {
	  debug('overriding xmlhttprequest');
	  XHR = function XHR() {
	    try {
	      return new global[axo]('Microsoft.XMLHTTP');
	    } catch (e) {
	      return null;
	    }
	  };
	  AbstractXHRObject.enabled = !!new XHR();
	}

	var cors = false;
	try {
	  cors = 'withCredentials' in new XHR();
	} catch (ignored) {
	  // intentionally empty
	}

	AbstractXHRObject.supportsCORS = cors;

	module.exports = AbstractXHRObject;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(14)))

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var inherits = __webpack_require__(25),
	    XhrDriver = __webpack_require__(36);

	function XHRLocalObject(method, url, payload /*, opts */) {
	  XhrDriver.call(this, method, url, payload, {
	    noCredentials: true
	  });
	}

	inherits(XHRLocalObject, XhrDriver);

	XHRLocalObject.enabled = XhrDriver.enabled;

	module.exports = XHRLocalObject;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	module.exports = {
	  isOpera: function isOpera() {
	    return global.navigator && /opera/i.test(global.navigator.userAgent);
	  },

	  isKonqueror: function isKonqueror() {
	    return global.navigator && /konqueror/i.test(global.navigator.userAgent);
	  }

	  // #187 wrap document.domain in try/catch because of WP8 from file:///
	  , hasDomain: function hasDomain() {
	    // non-browser client always has a domain
	    if (!global.document) {
	      return true;
	    }

	    try {
	      return !!global.document.domain;
	    } catch (e) {
	      return false;
	    }
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var inherits = __webpack_require__(25),
	    AjaxBasedTransport = __webpack_require__(30),
	    XhrReceiver = __webpack_require__(34),
	    XDRObject = __webpack_require__(40);

	// According to:
	//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
	//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

	function XdrStreamingTransport(transUrl) {
	  if (!XDRObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
	}

	inherits(XdrStreamingTransport, AjaxBasedTransport);

	XdrStreamingTransport.enabled = function (info) {
	  if (info.cookie_needed || info.nullOrigin) {
	    return false;
	  }
	  return XDRObject.enabled && info.sameScheme;
	};

	XdrStreamingTransport.transportName = 'xdr-streaming';
	XdrStreamingTransport.roundTrips = 2; // preflight, ajax

	module.exports = XdrStreamingTransport;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

	var EventEmitter = __webpack_require__(26).EventEmitter,
	    inherits = __webpack_require__(25),
	    eventUtils = __webpack_require__(15),
	    browser = __webpack_require__(38),
	    urlUtils = __webpack_require__(18);

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:sender:xdr');
	}

	// References:
	//   http://ajaxian.com/archives/100-line-ajax-wrapper
	//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

	function XDRObject(method, url, payload) {
	  debug(method, url);
	  var self = this;
	  EventEmitter.call(this);

	  setTimeout(function () {
	    self._start(method, url, payload);
	  }, 0);
	}

	inherits(XDRObject, EventEmitter);

	XDRObject.prototype._start = function (method, url, payload) {
	  debug('_start');
	  var self = this;
	  var xdr = new global.XDomainRequest();
	  // IE caches even POSTs
	  url = urlUtils.addQuery(url, 't=' + +new Date());

	  xdr.onerror = function () {
	    debug('onerror');
	    self._error();
	  };
	  xdr.ontimeout = function () {
	    debug('ontimeout');
	    self._error();
	  };
	  xdr.onprogress = function () {
	    debug('progress', xdr.responseText);
	    self.emit('chunk', 200, xdr.responseText);
	  };
	  xdr.onload = function () {
	    debug('load');
	    self.emit('finish', 200, xdr.responseText);
	    self._cleanup(false);
	  };
	  this.xdr = xdr;
	  this.unloadRef = eventUtils.unloadAdd(function () {
	    self._cleanup(true);
	  });
	  try {
	    // Fails with AccessDenied if port number is bogus
	    this.xdr.open(method, url);
	    if (this.timeout) {
	      this.xdr.timeout = this.timeout;
	    }
	    this.xdr.send(payload);
	  } catch (x) {
	    this._error();
	  }
	};

	XDRObject.prototype._error = function () {
	  this.emit('finish', 0, '');
	  this._cleanup(false);
	};

	XDRObject.prototype._cleanup = function (abort) {
	  debug('cleanup', abort);
	  if (!this.xdr) {
	    return;
	  }
	  this.removeAllListeners();
	  eventUtils.unloadDel(this.unloadRef);

	  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
	  if (abort) {
	    try {
	      this.xdr.abort();
	    } catch (x) {
	      // intentionally empty
	    }
	  }
	  this.unloadRef = this.xdr = null;
	};

	XDRObject.prototype.close = function () {
	  debug('close');
	  this._cleanup(true);
	};

	// IE 8/9 if the request target uses the same scheme - #79
	XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

	module.exports = XDRObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14), (function() { return this; }())))

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var inherits = __webpack_require__(25),
	    AjaxBasedTransport = __webpack_require__(30),
	    EventSourceReceiver = __webpack_require__(42),
	    XHRCorsObject = __webpack_require__(35),
	    EventSourceDriver = __webpack_require__(43);

	function EventSourceTransport(transUrl) {
	  if (!EventSourceTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }

	  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
	}

	inherits(EventSourceTransport, AjaxBasedTransport);

	EventSourceTransport.enabled = function () {
	  return !!EventSourceDriver;
	};

	EventSourceTransport.transportName = 'eventsource';
	EventSourceTransport.roundTrips = 2;

	module.exports = EventSourceTransport;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var inherits = __webpack_require__(25),
	    EventEmitter = __webpack_require__(26).EventEmitter,
	    EventSourceDriver = __webpack_require__(43);

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:receiver:eventsource');
	}

	function EventSourceReceiver(url) {
	  debug(url);
	  EventEmitter.call(this);

	  var self = this;
	  var es = this.es = new EventSourceDriver(url);
	  es.onmessage = function (e) {
	    debug('message', e.data);
	    self.emit('message', decodeURI(e.data));
	  };
	  es.onerror = function (e) {
	    debug('error', es.readyState, e);
	    // ES on reconnection has readyState = 0 or 1.
	    // on network error it's CLOSED = 2
	    var reason = es.readyState !== 2 ? 'network' : 'permanent';
	    self._cleanup();
	    self._close(reason);
	  };
	}

	inherits(EventSourceReceiver, EventEmitter);

	EventSourceReceiver.prototype.abort = function () {
	  debug('abort');
	  this._cleanup();
	  this._close('user');
	};

	EventSourceReceiver.prototype._cleanup = function () {
	  debug('cleanup');
	  var es = this.es;
	  if (es) {
	    es.onmessage = es.onerror = null;
	    es.close();
	    this.es = null;
	  }
	};

	EventSourceReceiver.prototype._close = function (reason) {
	  debug('close', reason);
	  var self = this;
	  // Safari and chrome < 15 crash if we close window before
	  // waiting for ES cleanup. See:
	  // https://code.google.com/p/chromium/issues/detail?id=89155
	  setTimeout(function () {
	    self.emit('close', null, reason);
	    self.removeAllListeners();
	  }, 200);
	};

	module.exports = EventSourceReceiver;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	module.exports = global.EventSource;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var inherits = __webpack_require__(25),
	    IframeTransport = __webpack_require__(45),
	    objectUtils = __webpack_require__(49);

	module.exports = function (transport) {

	  function IframeWrapTransport(transUrl, baseUrl) {
	    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
	  }

	  inherits(IframeWrapTransport, IframeTransport);

	  IframeWrapTransport.enabled = function (url, info) {
	    if (!global.document) {
	      return false;
	    }

	    var iframeInfo = objectUtils.extend({}, info);
	    iframeInfo.sameOrigin = true;
	    return transport.enabled(iframeInfo) && IframeTransport.enabled();
	  };

	  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
	  IframeWrapTransport.needBody = true;
	  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

	  IframeWrapTransport.facadeTransport = transport;

	  return IframeWrapTransport;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	// Few cool transports do work only for same-origin. In order to make
	// them work cross-domain we shall use iframe, served from the
	// remote domain. New browsers have capabilities to communicate with
	// cross domain iframe using postMessage(). In IE it was implemented
	// from IE 8+, but of course, IE got some details wrong:
	//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
	//    http://stevesouders.com/misc/test-postmessage.php

	var inherits = __webpack_require__(25),
	    JSON3 = __webpack_require__(46),
	    EventEmitter = __webpack_require__(26).EventEmitter,
	    version = __webpack_require__(47),
	    urlUtils = __webpack_require__(18),
	    iframeUtils = __webpack_require__(48),
	    eventUtils = __webpack_require__(15),
	    random = __webpack_require__(16);

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:transport:iframe');
	}

	function IframeTransport(transport, transUrl, baseUrl) {
	  if (!IframeTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	  EventEmitter.call(this);

	  var self = this;
	  this.origin = urlUtils.getOrigin(baseUrl);
	  this.baseUrl = baseUrl;
	  this.transUrl = transUrl;
	  this.transport = transport;
	  this.windowId = random.string(8);

	  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
	  debug(transport, transUrl, iframeUrl);

	  this.iframeObj = iframeUtils.createIframe(iframeUrl, function (r) {
	    debug('err callback');
	    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
	    self.close();
	  });

	  this.onmessageCallback = this._message.bind(this);
	  eventUtils.attachEvent('message', this.onmessageCallback);
	}

	inherits(IframeTransport, EventEmitter);

	IframeTransport.prototype.close = function () {
	  debug('close');
	  this.removeAllListeners();
	  if (this.iframeObj) {
	    eventUtils.detachEvent('message', this.onmessageCallback);
	    try {
	      // When the iframe is not loaded, IE raises an exception
	      // on 'contentWindow'.
	      this.postMessage('c');
	    } catch (x) {
	      // intentionally empty
	    }
	    this.iframeObj.cleanup();
	    this.iframeObj = null;
	    this.onmessageCallback = this.iframeObj = null;
	  }
	};

	IframeTransport.prototype._message = function (e) {
	  debug('message', e.data);
	  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
	    debug('not same origin', e.origin, this.origin);
	    return;
	  }

	  var iframeMessage;
	  try {
	    iframeMessage = JSON3.parse(e.data);
	  } catch (ignored) {
	    debug('bad json', e.data);
	    return;
	  }

	  if (iframeMessage.windowId !== this.windowId) {
	    debug('mismatched window id', iframeMessage.windowId, this.windowId);
	    return;
	  }

	  switch (iframeMessage.type) {
	    case 's':
	      this.iframeObj.loaded();
	      // window global dependency
	      this.postMessage('s', JSON3.stringify([version, this.transport, this.transUrl, this.baseUrl]));
	      break;
	    case 't':
	      this.emit('message', iframeMessage.data);
	      break;
	    case 'c':
	      var cdata;
	      try {
	        cdata = JSON3.parse(iframeMessage.data);
	      } catch (ignored) {
	        debug('bad json', iframeMessage.data);
	        return;
	      }
	      this.emit('close', cdata[0], cdata[1]);
	      this.close();
	      break;
	  }
	};

	IframeTransport.prototype.postMessage = function (type, data) {
	  debug('postMessage', type, data);
	  this.iframeObj.post(JSON3.stringify({
	    windowId: this.windowId,
	    type: type,
	    data: data || ''
	  }), this.origin);
	};

	IframeTransport.prototype.send = function (message) {
	  debug('send', message);
	  this.postMessage('m', message);
	};

	IframeTransport.enabled = function () {
	  return iframeUtils.iframeEnabled;
	};

	IframeTransport.transportName = 'iframe';
	IframeTransport.roundTrips = 2;

	module.exports = IframeTransport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
	;(function () {
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__(6);

	  // A set of types used to distinguish objects from primitives.
	  var objectTypes = {
	    "function": true,
	    "object": true
	  };

	  // Detect the `exports` object exposed by CommonJS implementations.
	  var freeExports = objectTypes[ false ? "undefined" : _typeof(exports)] && exports && !exports.nodeType && exports;

	  // Use the `global` object exposed by Node (including Browserify via
	  // `insert-module-globals`), Narwhal, and Ringo as the default context,
	  // and the `window` object in browsers. Rhino exports a `global` function
	  // instead.
	  var root = objectTypes[typeof window === "undefined" ? "undefined" : _typeof(window)] && window || this,
	      freeGlobal = freeExports && objectTypes[ false ? "undefined" : _typeof(module)] && module && !module.nodeType && (typeof global === "undefined" ? "undefined" : _typeof(global)) == "object" && global;

	  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
	    root = freeGlobal;
	  }

	  // Public: Initializes JSON 3 using the given `context` object, attaching the
	  // `stringify` and `parse` functions to the specified `exports` object.
	  function runInContext(context, exports) {
	    context || (context = root["Object"]());
	    exports || (exports = root["Object"]());

	    // Native constructor aliases.
	    var Number = context["Number"] || root["Number"],
	        String = context["String"] || root["String"],
	        Object = context["Object"] || root["Object"],
	        Date = context["Date"] || root["Date"],
	        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
	        TypeError = context["TypeError"] || root["TypeError"],
	        Math = context["Math"] || root["Math"],
	        nativeJSON = context["JSON"] || root["JSON"];

	    // Delegate to the native `stringify` and `parse` implementations.
	    if ((typeof nativeJSON === "undefined" ? "undefined" : _typeof(nativeJSON)) == "object" && nativeJSON) {
	      exports.stringify = nativeJSON.stringify;
	      exports.parse = nativeJSON.parse;
	    }

	    // Convenience aliases.
	    var objectProto = Object.prototype,
	        getClass = objectProto.toString,
	        _isProperty,
	        _forEach,
	        undef;

	    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	    var isExtended = new Date(-3509827334573292);
	    try {
	      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	      // results for certain dates in Opera >= 10.53.
	      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	      // Safari < 2.0.2 stores the internal millisecond time value correctly,
	      // but clips the values returned by the date methods to the range of
	      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	    } catch (exception) {}

	    // Internal: Determines whether the native `JSON.stringify` and `parse`
	    // implementations are spec-compliant. Based on work by Ken Snyder.
	    function has(name) {
	      if (has[name] !== undef) {
	        // Return cached feature test result.
	        return has[name];
	      }
	      var isSupported;
	      if (name == "bug-string-char-index") {
	        // IE <= 7 doesn't support accessing string characters using square
	        // bracket notation. IE 8 only supports this for primitives.
	        isSupported = "a"[0] != "a";
	      } else if (name == "json") {
	        // Indicates whether both `JSON.stringify` and `JSON.parse` are
	        // supported.
	        isSupported = has("json-stringify") && has("json-parse");
	      } else {
	        var value,
	            serialized = "{\"a\":[1,true,false,null,\"\\u0000\\b\\n\\f\\r\\t\"]}";
	        // Test `JSON.stringify`.
	        if (name == "json-stringify") {
	          var stringify = exports.stringify,
	              stringifySupported = typeof stringify == "function" && isExtended;
	          if (stringifySupported) {
	            // A test function object with a custom `toJSON` method.
	            (value = function value() {
	              return 1;
	            }).toJSON = value;
	            try {
	              stringifySupported =
	              // Firefox 3.1b1 and b2 serialize string, number, and boolean
	              // primitives as object literals.
	              stringify(0) === "0" &&
	              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	              // literals.
	              stringify(new Number()) === "0" && stringify(new String()) == '""' &&
	              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	              // does not define a canonical JSON representation (this applies to
	              // objects with `toJSON` properties as well, *unless* they are nested
	              // within an object or array).
	              stringify(getClass) === undef &&
	              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	              // FF 3.1b3 pass this test.
	              stringify(undef) === undef &&
	              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	              // respectively, if the value is omitted entirely.
	              stringify() === undef &&
	              // FF 3.1b1, 2 throw an error if the given value is not a number,
	              // string, array, object, Boolean, or `null` literal. This applies to
	              // objects with custom `toJSON` methods as well, unless they are nested
	              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	              // methods entirely.
	              stringify(value) === "1" && stringify([value]) == "[1]" &&
	              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	              // `"[null]"`.
	              stringify([undef]) == "[null]" &&
	              // YUI 3.0.0b1 fails to serialize `null` literals.
	              stringify(null) == "null" &&
	              // FF 3.1b1, 2 halts serialization if an array contains a function:
	              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	              // elides non-JSON values from objects and arrays, unless they
	              // define custom `toJSON` methods.
	              stringify([undef, getClass, null]) == "[null,null,null]" &&
	              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	              // where character escape codes are expected (e.g., `\b` => `\u0008`).
	              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	              stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	              // serialize extended years.
	              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	              // The milliseconds are optional in ES 5, but required in 5.1.
	              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	              // four-digit years instead of six-digit years. Credits: @Yaffle.
	              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	              // values less than 1000. Credits: @Yaffle.
	              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	            } catch (exception) {
	              stringifySupported = false;
	            }
	          }
	          isSupported = stringifySupported;
	        }
	        // Test `JSON.parse`.
	        if (name == "json-parse") {
	          var parse = exports.parse;
	          if (typeof parse == "function") {
	            try {
	              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	              // Conforming implementations should also coerce the initial argument to
	              // a string prior to parsing.
	              if (parse("0") === 0 && !parse(false)) {
	                // Simple parsing test.
	                value = parse(serialized);
	                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	                if (parseSupported) {
	                  try {
	                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                    parseSupported = !parse('"\t"');
	                  } catch (exception) {}
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                      // certain octal literals.
	                      parseSupported = parse("01") !== 1;
	                    } catch (exception) {}
	                  }
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                      // points. These environments, along with FF 3.1b1 and 2,
	                      // also allow trailing commas in JSON objects and arrays.
	                      parseSupported = parse("1.") !== 1;
	                    } catch (exception) {}
	                  }
	                }
	              }
	            } catch (exception) {
	              parseSupported = false;
	            }
	          }
	          isSupported = parseSupported;
	        }
	      }
	      return has[name] = !!isSupported;
	    }

	    if (!has("json")) {
	      // Common `[[Class]]` name aliases.
	      var functionClass = "[object Function]",
	          dateClass = "[object Date]",
	          numberClass = "[object Number]",
	          stringClass = "[object String]",
	          arrayClass = "[object Array]",
	          booleanClass = "[object Boolean]";

	      // Detect incomplete support for accessing string characters by index.
	      var charIndexBuggy = has("bug-string-char-index");

	      // Define additional utility methods if the `Date` methods are buggy.
	      if (!isExtended) {
	        var floor = Math.floor;
	        // A mapping between the months of the year and the number of days between
	        // January 1st and the first of the respective month.
	        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	        // Internal: Calculates the number of days between the Unix epoch and the
	        // first day of the given month.
	        var getDay = function getDay(year, month) {
	          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	        };
	      }

	      // Internal: Determines if a property is a direct property of the given
	      // object. Delegates to the native `Object#hasOwnProperty` method.
	      if (!(_isProperty = objectProto.hasOwnProperty)) {
	        _isProperty = function isProperty(property) {
	          var members = {},
	              constructor;
	          if ((members.__proto__ = null, members.__proto__ = {
	            // The *proto* property cannot be set multiple times in recent
	            // versions of Firefox and SeaMonkey.
	            "toString": 1
	          }, members).toString != getClass) {
	            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	            // supports the mutable *proto* property.
	            _isProperty = function isProperty(property) {
	              // Capture and break the object's prototype chain (see section 8.6.2
	              // of the ES 5.1 spec). The parenthesized expression prevents an
	              // unsafe transformation by the Closure Compiler.
	              var original = this.__proto__,
	                  result = property in (this.__proto__ = null, this);
	              // Restore the original prototype chain.
	              this.__proto__ = original;
	              return result;
	            };
	          } else {
	            // Capture a reference to the top-level `Object` constructor.
	            constructor = members.constructor;
	            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	            // other environments.
	            _isProperty = function isProperty(property) {
	              var parent = (this.constructor || constructor).prototype;
	              return property in this && !(property in parent && this[property] === parent[property]);
	            };
	          }
	          members = null;
	          return _isProperty.call(this, property);
	        };
	      }

	      // Internal: Normalizes the `for...in` iteration algorithm across
	      // environments. Each enumerated key is yielded to a `callback` function.
	      _forEach = function forEach(object, callback) {
	        var size = 0,
	            Properties,
	            members,
	            property;

	        // Tests for bugs in the current environment's `for...in` algorithm. The
	        // `valueOf` property inherits the non-enumerable flag from
	        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	        (Properties = function Properties() {
	          this.valueOf = 0;
	        }).prototype.valueOf = 0;

	        // Iterate over a new instance of the `Properties` class.
	        members = new Properties();
	        for (property in members) {
	          // Ignore all properties inherited from `Object.prototype`.
	          if (_isProperty.call(members, property)) {
	            size++;
	          }
	        }
	        Properties = members = null;

	        // Normalize the iteration algorithm.
	        if (!size) {
	          // A list of non-enumerable properties inherited from `Object.prototype`.
	          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	          // properties.
	          _forEach = function forEach(object, callback) {
	            var isFunction = getClass.call(object) == functionClass,
	                property,
	                length;
	            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[_typeof(object.hasOwnProperty)] && object.hasOwnProperty || _isProperty;
	            for (property in object) {
	              // Gecko <= 1.0 enumerates the `prototype` property of functions under
	              // certain conditions; IE does not.
	              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for each non-enumerable property.
	            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property)) {}
	          };
	        } else if (size == 2) {
	          // Safari <= 2.0.4 enumerates shadowed properties twice.
	          _forEach = function forEach(object, callback) {
	            // Create a set of iterated properties.
	            var members = {},
	                isFunction = getClass.call(object) == functionClass,
	                property;
	            for (property in object) {
	              // Store each property name to prevent double enumeration. The
	              // `prototype` property of functions is not enumerated due to cross-
	              // environment inconsistencies.
	              if (!(isFunction && property == "prototype") && !_isProperty.call(members, property) && (members[property] = 1) && _isProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	          };
	        } else {
	          // No bugs detected; use the standard `for...in` algorithm.
	          _forEach = function forEach(object, callback) {
	            var isFunction = getClass.call(object) == functionClass,
	                property,
	                isConstructor;
	            for (property in object) {
	              if (!(isFunction && property == "prototype") && _isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for the `constructor` property due to
	            // cross-environment inconsistencies.
	            if (isConstructor || _isProperty.call(object, property = "constructor")) {
	              callback(property);
	            }
	          };
	        }
	        return _forEach(object, callback);
	      };

	      // Public: Serializes a JavaScript `value` as a JSON string. The optional
	      // `filter` argument may specify either a function that alters how object and
	      // array members are serialized, or an array of strings and numbers that
	      // indicates which properties should be serialized. The optional `width`
	      // argument may be either a string or number that specifies the indentation
	      // level of the output.
	      if (!has("json-stringify")) {
	        // Internal: A map of control characters and their escaped equivalents.
	        var Escapes = {
	          92: "\\\\",
	          34: '\\"',
	          8: "\\b",
	          12: "\\f",
	          10: "\\n",
	          13: "\\r",
	          9: "\\t"
	        };

	        // Internal: Converts `value` into a zero-padded string such that its
	        // length is at least equal to `width`. The `width` must be <= 6.
	        var leadingZeroes = "000000";
	        var toPaddedString = function toPaddedString(width, value) {
	          // The `|| 0` expression is necessary to work around a bug in
	          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	          return (leadingZeroes + (value || 0)).slice(-width);
	        };

	        // Internal: Double-quotes a string `value`, replacing all ASCII control
	        // characters (characters with code unit values between 0 and 31) with
	        // their escaped equivalents. This is an implementation of the
	        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	        var unicodePrefix = "\\u00";
	        var quote = function quote(value) {
	          var result = '"',
	              index = 0,
	              length = value.length,
	              useCharIndex = !charIndexBuggy || length > 10;
	          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
	          for (; index < length; index++) {
	            var charCode = value.charCodeAt(index);
	            // If the character is a control character, append its Unicode or
	            // shorthand escape sequence; otherwise, append the character as-is.
	            switch (charCode) {
	              case 8:case 9:case 10:case 12:case 13:case 34:case 92:
	                result += Escapes[charCode];
	                break;
	              default:
	                if (charCode < 32) {
	                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                  break;
	                }
	                result += useCharIndex ? symbols[index] : value.charAt(index);
	            }
	          }
	          return result + '"';
	        };

	        // Internal: Recursively serializes an object. Implements the
	        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	        var serialize = function serialize(property, object, callback, properties, whitespace, indentation, stack) {
	          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	          try {
	            // Necessary for host object support.
	            value = object[property];
	          } catch (exception) {}
	          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
	            className = getClass.call(value);
	            if (className == dateClass && !_isProperty.call(value, "toJSON")) {
	              if (value > -1 / 0 && value < 1 / 0) {
	                // Dates are serialized according to the `Date#toJSON` method
	                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	                // for the ISO 8601 date time string format.
	                if (getDay) {
	                  // Manually compute the year, month, date, hours, minutes,
	                  // seconds, and milliseconds if the `getUTC*` methods are
	                  // buggy. Adapted from @Yaffle's `date-shim` project.
	                  date = floor(value / 864e5);
	                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) {}
	                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) {}
	                  date = 1 + date - getDay(year, month);
	                  // The `time` value specifies the time within the day (see ES
	                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                  // to compute `A modulo B`, as the `%` operator does not
	                  // correspond to the `modulo` operation for negative numbers.
	                  time = (value % 864e5 + 864e5) % 864e5;
	                  // The hours, minutes, seconds, and milliseconds are obtained by
	                  // decomposing the time within the day. See section 15.9.1.10.
	                  hours = floor(time / 36e5) % 24;
	                  minutes = floor(time / 6e4) % 60;
	                  seconds = floor(time / 1e3) % 60;
	                  milliseconds = time % 1e3;
	                } else {
	                  year = value.getUTCFullYear();
	                  month = value.getUTCMonth();
	                  date = value.getUTCDate();
	                  hours = value.getUTCHours();
	                  minutes = value.getUTCMinutes();
	                  seconds = value.getUTCSeconds();
	                  milliseconds = value.getUTCMilliseconds();
	                }
	                // Serialize extended years correctly.
	                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                // Months, dates, hours, minutes, and seconds should have two
	                // digits; milliseconds should have three.
	                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                // Milliseconds are optional in ES 5.0, but required in 5.1.
	                "." + toPaddedString(3, milliseconds) + "Z";
	              } else {
	                value = null;
	              }
	            } else if (typeof value.toJSON == "function" && (className != numberClass && className != stringClass && className != arrayClass || _isProperty.call(value, "toJSON"))) {
	              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	              // ignores all `toJSON` methods on these objects unless they are
	              // defined directly on an instance.
	              value = value.toJSON(property);
	            }
	          }
	          if (callback) {
	            // If a replacement function was provided, call it to obtain the value
	            // for serialization.
	            value = callback.call(object, property, value);
	          }
	          if (value === null) {
	            return "null";
	          }
	          className = getClass.call(value);
	          if (className == booleanClass) {
	            // Booleans are represented literally.
	            return "" + value;
	          } else if (className == numberClass) {
	            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	            // `"null"`.
	            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	          } else if (className == stringClass) {
	            // Strings are double-quoted and escaped.
	            return quote("" + value);
	          }
	          // Recursively serialize objects and arrays.
	          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object") {
	            // Check for cyclic structures. This is a linear search; performance
	            // is inversely proportional to the number of unique nested objects.
	            for (length = stack.length; length--;) {
	              if (stack[length] === value) {
	                // Cyclic structures cannot be serialized by `JSON.stringify`.
	                throw TypeError();
	              }
	            }
	            // Add the object to the stack of traversed objects.
	            stack.push(value);
	            results = [];
	            // Save the current indentation level and indent one additional level.
	            prefix = indentation;
	            indentation += whitespace;
	            if (className == arrayClass) {
	              // Recursively serialize array elements.
	              for (index = 0, length = value.length; index < length; index++) {
	                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	                results.push(element === undef ? "null" : element);
	              }
	              result = results.length ? whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : "[" + results.join(",") + "]" : "[]";
	            } else {
	              // Recursively serialize object members. Members are selected from
	              // either a user-specified list of property names, or the object
	              // itself.
	              _forEach(properties || value, function (property) {
	                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	                if (element !== undef) {
	                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                  // is not the empty string, let `member` {quote(property) + ":"}
	                  // be the concatenation of `member` and the `space` character."
	                  // The "`space` character" refers to the literal space
	                  // character, not the `space` {width} argument provided to
	                  // `JSON.stringify`.
	                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	                }
	              });
	              result = results.length ? whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : "{" + results.join(",") + "}" : "{}";
	            }
	            // Remove the object from the traversed object stack.
	            stack.pop();
	            return result;
	          }
	        };

	        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	        exports.stringify = function (source, filter, width) {
	          var whitespace, callback, properties, className;
	          if (objectTypes[typeof filter === "undefined" ? "undefined" : _typeof(filter)] && filter) {
	            if ((className = getClass.call(filter)) == functionClass) {
	              callback = filter;
	            } else if (className == arrayClass) {
	              // Convert the property names array into a makeshift set.
	              properties = {};
	              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], (className = getClass.call(value), className == stringClass || className == numberClass) && (properties[value] = 1)) {}
	            }
	          }
	          if (width) {
	            if ((className = getClass.call(width)) == numberClass) {
	              // Convert the `width` to an integer and create a string containing
	              // `width` number of space characters.
	              if ((width -= width % 1) > 0) {
	                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ") {}
	              }
	            } else if (className == stringClass) {
	              whitespace = width.length <= 10 ? width : width.slice(0, 10);
	            }
	          }
	          // Opera <= 7.54u2 discards the values associated with empty string keys
	          // (`""`) only if they are used directly within an object member list
	          // (e.g., `!("" in { "": 1})`).
	          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	        };
	      }

	      // Public: Parses a JSON source string.
	      if (!has("json-parse")) {
	        var fromCharCode = String.fromCharCode;

	        // Internal: A map of escaped control characters and their unescaped
	        // equivalents.
	        var Unescapes = {
	          92: "\\",
	          34: '"',
	          47: "/",
	          98: "\b",
	          116: "\t",
	          110: "\n",
	          102: "\f",
	          114: "\r"
	        };

	        // Internal: Stores the parser state.
	        var Index, Source;

	        // Internal: Resets the parser state and throws a `SyntaxError`.
	        var abort = function abort() {
	          Index = Source = null;
	          throw SyntaxError();
	        };

	        // Internal: Returns the next token, or `"$"` if the parser has reached
	        // the end of the source string. A token may be a string, number, `null`
	        // literal, or Boolean literal.
	        var lex = function lex() {
	          var source = Source,
	              length = source.length,
	              value,
	              begin,
	              position,
	              isSigned,
	              charCode;
	          while (Index < length) {
	            charCode = source.charCodeAt(Index);
	            switch (charCode) {
	              case 9:case 10:case 13:case 32:
	                // Skip whitespace tokens, including tabs, carriage returns, line
	                // feeds, and space characters.
	                Index++;
	                break;
	              case 123:case 125:case 91:case 93:case 58:case 44:
	                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	                // the current position.
	                value = charIndexBuggy ? source.charAt(Index) : source[Index];
	                Index++;
	                return value;
	              case 34:
	                // `"` delimits a JSON string; advance to the next character and
	                // begin parsing the string. String tokens are prefixed with the
	                // sentinel `@` character to distinguish them from punctuators and
	                // end-of-string tokens.
	                for (value = "@", Index++; Index < length;) {
	                  charCode = source.charCodeAt(Index);
	                  if (charCode < 32) {
	                    // Unescaped ASCII control characters (those with a code unit
	                    // less than the space character) are not permitted.
	                    abort();
	                  } else if (charCode == 92) {
	                    // A reverse solidus (`\`) marks the beginning of an escaped
	                    // control character (including `"`, `\`, and `/`) or Unicode
	                    // escape sequence.
	                    charCode = source.charCodeAt(++Index);
	                    switch (charCode) {
	                      case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:
	                        // Revive escaped control characters.
	                        value += Unescapes[charCode];
	                        Index++;
	                        break;
	                      case 117:
	                        // `\u` marks the beginning of a Unicode escape sequence.
	                        // Advance to the first character and validate the
	                        // four-digit code point.
	                        begin = ++Index;
	                        for (position = Index + 4; Index < position; Index++) {
	                          charCode = source.charCodeAt(Index);
	                          // A valid sequence comprises four hexdigits (case-
	                          // insensitive) that form a single hexadecimal value.
	                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                            // Invalid Unicode escape sequence.
	                            abort();
	                          }
	                        }
	                        // Revive the escaped character.
	                        value += fromCharCode("0x" + source.slice(begin, Index));
	                        break;
	                      default:
	                        // Invalid escape sequence.
	                        abort();
	                    }
	                  } else {
	                    if (charCode == 34) {
	                      // An unescaped double-quote character marks the end of the
	                      // string.
	                      break;
	                    }
	                    charCode = source.charCodeAt(Index);
	                    begin = Index;
	                    // Optimize for the common case where a string is valid.
	                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                      charCode = source.charCodeAt(++Index);
	                    }
	                    // Append the string as-is.
	                    value += source.slice(begin, Index);
	                  }
	                }
	                if (source.charCodeAt(Index) == 34) {
	                  // Advance to the next character and return the revived string.
	                  Index++;
	                  return value;
	                }
	                // Unterminated string.
	                abort();
	              default:
	                // Parse numbers and literals.
	                begin = Index;
	                // Advance past the negative sign, if one is specified.
	                if (charCode == 45) {
	                  isSigned = true;
	                  charCode = source.charCodeAt(++Index);
	                }
	                // Parse an integer or floating-point value.
	                if (charCode >= 48 && charCode <= 57) {
	                  // Leading zeroes are interpreted as octal literals.
	                  if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {
	                    // Illegal octal literal.
	                    abort();
	                  }
	                  isSigned = false;
	                  // Parse the integer component.
	                  for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++) {}
	                  // Floats cannot contain a leading decimal point; however, this
	                  // case is already accounted for by the parser.
	                  if (source.charCodeAt(Index) == 46) {
	                    position = ++Index;
	                    // Parse the decimal component.
	                    for (; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
	                    if (position == Index) {
	                      // Illegal trailing decimal.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Parse exponents. The `e` denoting the exponent is
	                  // case-insensitive.
	                  charCode = source.charCodeAt(Index);
	                  if (charCode == 101 || charCode == 69) {
	                    charCode = source.charCodeAt(++Index);
	                    // Skip past the sign following the exponent, if one is
	                    // specified.
	                    if (charCode == 43 || charCode == 45) {
	                      Index++;
	                    }
	                    // Parse the exponential component.
	                    for (position = Index; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
	                    if (position == Index) {
	                      // Illegal empty exponent.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Coerce the parsed value to a JavaScript number.
	                  return +source.slice(begin, Index);
	                }
	                // A negative sign may only precede numbers.
	                if (isSigned) {
	                  abort();
	                }
	                // `true`, `false`, and `null` literals.
	                if (source.slice(Index, Index + 4) == "true") {
	                  Index += 4;
	                  return true;
	                } else if (source.slice(Index, Index + 5) == "false") {
	                  Index += 5;
	                  return false;
	                } else if (source.slice(Index, Index + 4) == "null") {
	                  Index += 4;
	                  return null;
	                }
	                // Unrecognized token.
	                abort();
	            }
	          }
	          // Return the sentinel `$` character if the parser has reached the end
	          // of the source string.
	          return "$";
	        };

	        // Internal: Parses a JSON `value` token.
	        var get = function get(value) {
	          var results, hasMembers;
	          if (value == "$") {
	            // Unexpected end of input.
	            abort();
	          }
	          if (typeof value == "string") {
	            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	              // Remove the sentinel `@` character.
	              return value.slice(1);
	            }
	            // Parse object and array literals.
	            if (value == "[") {
	              // Parses a JSON array, returning a new JavaScript array.
	              results = [];
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing square bracket marks the end of the array literal.
	                if (value == "]") {
	                  break;
	                }
	                // If the array literal contains elements, the current token
	                // should be a comma separating the previous element from the
	                // next.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "]") {
	                      // Unexpected trailing `,` in array literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each array element.
	                    abort();
	                  }
	                }
	                // Elisions and leading commas are not permitted.
	                if (value == ",") {
	                  abort();
	                }
	                results.push(get(value));
	              }
	              return results;
	            } else if (value == "{") {
	              // Parses a JSON object, returning a new JavaScript object.
	              results = {};
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing curly brace marks the end of the object literal.
	                if (value == "}") {
	                  break;
	                }
	                // If the object literal contains members, the current token
	                // should be a comma separator.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "}") {
	                      // Unexpected trailing `,` in object literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each object member.
	                    abort();
	                  }
	                }
	                // Leading commas are not permitted, object property names must be
	                // double-quoted strings, and a `:` must separate each property
	                // name and value.
	                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                  abort();
	                }
	                results[value.slice(1)] = get(lex());
	              }
	              return results;
	            }
	            // Unexpected token encountered.
	            abort();
	          }
	          return value;
	        };

	        // Internal: Updates a traversed object member.
	        var update = function update(source, property, callback) {
	          var element = walk(source, property, callback);
	          if (element === undef) {
	            delete source[property];
	          } else {
	            source[property] = element;
	          }
	        };

	        // Internal: Recursively traverses a parsed JSON object, invoking the
	        // `callback` function for each value. This is an implementation of the
	        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	        var walk = function walk(source, property, callback) {
	          var value = source[property],
	              length;
	          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
	            // `forEach` can't be used to traverse an array in Opera <= 8.54
	            // because its `Object#hasOwnProperty` implementation returns `false`
	            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	            if (getClass.call(value) == arrayClass) {
	              for (length = value.length; length--;) {
	                update(value, length, callback);
	              }
	            } else {
	              _forEach(value, function (property) {
	                update(value, property, callback);
	              });
	            }
	          }
	          return callback.call(source, property, value);
	        };

	        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	        exports.parse = function (source, callback) {
	          var result, value;
	          Index = 0;
	          Source = "" + source;
	          result = get(lex());
	          // If a JSON string contains multiple tokens, it is invalid.
	          if (lex() != "$") {
	            abort();
	          }
	          // Reset the parser state.
	          Index = Source = null;
	          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	        };
	      }
	    }

	    exports["runInContext"] = runInContext;
	    return exports;
	  }

	  if (freeExports && !isLoader) {
	    // Export for CommonJS environments.
	    runInContext(root, freeExports);
	  } else {
	    // Export for web browsers and JavaScript engines.
	    var nativeJSON = root.JSON,
	        previousJSON = root["JSON3"],
	        isRestored = false;

	    var JSON3 = runInContext(root, root["JSON3"] = {
	      // Public: Restores the original value of the global `JSON` object and
	      // returns a reference to the `JSON3` object.
	      "noConflict": function noConflict() {
	        if (!isRestored) {
	          isRestored = true;
	          root.JSON = nativeJSON;
	          root["JSON3"] = previousJSON;
	          nativeJSON = previousJSON = null;
	        }
	        return JSON3;
	      }
	    });

	    root.JSON = {
	      "parse": JSON3.parse,
	      "stringify": JSON3.stringify
	    };
	  }

	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)(module), (function() { return this; }())))

/***/ }),
/* 47 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = '1.1.4';

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var eventUtils = __webpack_require__(15),
	    JSON3 = __webpack_require__(46),
	    browser = __webpack_require__(38);

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:utils:iframe');
	}

	module.exports = {
	  WPrefix: '_jp',
	  currentWindowId: null,

	  polluteGlobalNamespace: function polluteGlobalNamespace() {
	    if (!(module.exports.WPrefix in global)) {
	      global[module.exports.WPrefix] = {};
	    }
	  },

	  postMessage: function postMessage(type, data) {
	    if (global.parent !== global) {
	      global.parent.postMessage(JSON3.stringify({
	        windowId: module.exports.currentWindowId,
	        type: type,
	        data: data || ''
	      }), '*');
	    } else {
	      debug('Cannot postMessage, no parent window.', type, data);
	    }
	  },

	  createIframe: function createIframe(iframeUrl, errorCallback) {
	    var iframe = global.document.createElement('iframe');
	    var tref, unloadRef;
	    var unattach = function unattach() {
	      debug('unattach');
	      clearTimeout(tref);
	      // Explorer had problems with that.
	      try {
	        iframe.onload = null;
	      } catch (x) {
	        // intentionally empty
	      }
	      iframe.onerror = null;
	    };
	    var cleanup = function cleanup() {
	      debug('cleanup');
	      if (iframe) {
	        unattach();
	        // This timeout makes chrome fire onbeforeunload event
	        // within iframe. Without the timeout it goes straight to
	        // onunload.
	        setTimeout(function () {
	          if (iframe) {
	            iframe.parentNode.removeChild(iframe);
	          }
	          iframe = null;
	        }, 0);
	        eventUtils.unloadDel(unloadRef);
	      }
	    };
	    var onerror = function onerror(err) {
	      debug('onerror', err);
	      if (iframe) {
	        cleanup();
	        errorCallback(err);
	      }
	    };
	    var post = function post(msg, origin) {
	      debug('post', msg, origin);
	      try {
	        // When the iframe is not loaded, IE raises an exception
	        // on 'contentWindow'.
	        setTimeout(function () {
	          if (iframe && iframe.contentWindow) {
	            iframe.contentWindow.postMessage(msg, origin);
	          }
	        }, 0);
	      } catch (x) {
	        // intentionally empty
	      }
	    };

	    iframe.src = iframeUrl;
	    iframe.style.display = 'none';
	    iframe.style.position = 'absolute';
	    iframe.onerror = function () {
	      onerror('onerror');
	    };
	    iframe.onload = function () {
	      debug('onload');
	      // `onload` is triggered before scripts on the iframe are
	      // executed. Give it few seconds to actually load stuff.
	      clearTimeout(tref);
	      tref = setTimeout(function () {
	        onerror('onload timeout');
	      }, 2000);
	    };
	    global.document.body.appendChild(iframe);
	    tref = setTimeout(function () {
	      onerror('timeout');
	    }, 15000);
	    unloadRef = eventUtils.unloadAdd(cleanup);
	    return {
	      post: post,
	      cleanup: cleanup,
	      loaded: unattach
	    };
	  }

	  /* eslint no-undef: "off", new-cap: "off" */
	  , createHtmlfile: function createHtmlfile(iframeUrl, errorCallback) {
	    var axo = ['Active'].concat('Object').join('X');
	    var doc = new global[axo]('htmlfile');
	    var tref, unloadRef;
	    var iframe;
	    var unattach = function unattach() {
	      clearTimeout(tref);
	      iframe.onerror = null;
	    };
	    var cleanup = function cleanup() {
	      if (doc) {
	        unattach();
	        eventUtils.unloadDel(unloadRef);
	        iframe.parentNode.removeChild(iframe);
	        iframe = doc = null;
	        CollectGarbage();
	      }
	    };
	    var onerror = function onerror(r) {
	      debug('onerror', r);
	      if (doc) {
	        cleanup();
	        errorCallback(r);
	      }
	    };
	    var post = function post(msg, origin) {
	      try {
	        // When the iframe is not loaded, IE raises an exception
	        // on 'contentWindow'.
	        setTimeout(function () {
	          if (iframe && iframe.contentWindow) {
	            iframe.contentWindow.postMessage(msg, origin);
	          }
	        }, 0);
	      } catch (x) {
	        // intentionally empty
	      }
	    };

	    doc.open();
	    doc.write('<html><s' + 'cript>' + 'document.domain="' + global.document.domain + '";' + '</s' + 'cript></html>');
	    doc.close();
	    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
	    var c = doc.createElement('div');
	    doc.body.appendChild(c);
	    iframe = doc.createElement('iframe');
	    c.appendChild(iframe);
	    iframe.src = iframeUrl;
	    iframe.onerror = function () {
	      onerror('onerror');
	    };
	    tref = setTimeout(function () {
	      onerror('timeout');
	    }, 15000);
	    unloadRef = eventUtils.unloadAdd(cleanup);
	    return {
	      post: post,
	      cleanup: cleanup,
	      loaded: unattach
	    };
	  }
	};

	module.exports.iframeEnabled = false;
	if (global.document) {
	  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
	  // huge delay, or not at all.
	  module.exports.iframeEnabled = (typeof global.postMessage === 'function' || _typeof(global.postMessage) === 'object') && !browser.isKonqueror();
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14), (function() { return this; }())))

/***/ }),
/* 49 */
/***/ (function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	module.exports = {
	  isObject: function isObject(obj) {
	    var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
	    return type === 'function' || type === 'object' && !!obj;
	  },

	  extend: function extend(obj) {
	    if (!this.isObject(obj)) {
	      return obj;
	    }
	    var source, prop;
	    for (var i = 1, length = arguments.length; i < length; i++) {
	      source = arguments[i];
	      for (prop in source) {
	        if (Object.prototype.hasOwnProperty.call(source, prop)) {
	          obj[prop] = source[prop];
	        }
	      }
	    }
	    return obj;
	  }
	};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var inherits = __webpack_require__(25),
	    HtmlfileReceiver = __webpack_require__(51),
	    XHRLocalObject = __webpack_require__(37),
	    AjaxBasedTransport = __webpack_require__(30);

	function HtmlFileTransport(transUrl) {
	  if (!HtmlfileReceiver.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
	}

	inherits(HtmlFileTransport, AjaxBasedTransport);

	HtmlFileTransport.enabled = function (info) {
	  return HtmlfileReceiver.enabled && info.sameOrigin;
	};

	HtmlFileTransport.transportName = 'htmlfile';
	HtmlFileTransport.roundTrips = 2;

	module.exports = HtmlFileTransport;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

	var inherits = __webpack_require__(25),
	    iframeUtils = __webpack_require__(48),
	    urlUtils = __webpack_require__(18),
	    EventEmitter = __webpack_require__(26).EventEmitter,
	    random = __webpack_require__(16);

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:receiver:htmlfile');
	}

	function HtmlfileReceiver(url) {
	  debug(url);
	  EventEmitter.call(this);
	  var self = this;
	  iframeUtils.polluteGlobalNamespace();

	  this.id = 'a' + random.string(6);
	  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

	  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
	  var constructFunc = HtmlfileReceiver.htmlfileEnabled ? iframeUtils.createHtmlfile : iframeUtils.createIframe;

	  global[iframeUtils.WPrefix][this.id] = {
	    start: function start() {
	      debug('start');
	      self.iframeObj.loaded();
	    },
	    message: function message(data) {
	      debug('message', data);
	      self.emit('message', data);
	    },
	    stop: function stop() {
	      debug('stop');
	      self._cleanup();
	      self._close('network');
	    }
	  };
	  this.iframeObj = constructFunc(url, function () {
	    debug('callback');
	    self._cleanup();
	    self._close('permanent');
	  });
	}

	inherits(HtmlfileReceiver, EventEmitter);

	HtmlfileReceiver.prototype.abort = function () {
	  debug('abort');
	  this._cleanup();
	  this._close('user');
	};

	HtmlfileReceiver.prototype._cleanup = function () {
	  debug('_cleanup');
	  if (this.iframeObj) {
	    this.iframeObj.cleanup();
	    this.iframeObj = null;
	  }
	  delete global[iframeUtils.WPrefix][this.id];
	};

	HtmlfileReceiver.prototype._close = function (reason) {
	  debug('_close', reason);
	  this.emit('close', null, reason);
	  this.removeAllListeners();
	};

	HtmlfileReceiver.htmlfileEnabled = false;

	// obfuscate to avoid firewalls
	var axo = ['Active'].concat('Object').join('X');
	if (axo in global) {
	  try {
	    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
	  } catch (x) {
	    // intentionally empty
	  }
	}

	HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

	module.exports = HtmlfileReceiver;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14), (function() { return this; }())))

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var inherits = __webpack_require__(25),
	    AjaxBasedTransport = __webpack_require__(30),
	    XhrReceiver = __webpack_require__(34),
	    XHRCorsObject = __webpack_require__(35),
	    XHRLocalObject = __webpack_require__(37);

	function XhrPollingTransport(transUrl) {
	  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
	}

	inherits(XhrPollingTransport, AjaxBasedTransport);

	XhrPollingTransport.enabled = function (info) {
	  if (info.nullOrigin) {
	    return false;
	  }

	  if (XHRLocalObject.enabled && info.sameOrigin) {
	    return true;
	  }
	  return XHRCorsObject.enabled;
	};

	XhrPollingTransport.transportName = 'xhr-polling';
	XhrPollingTransport.roundTrips = 2; // preflight, ajax

	module.exports = XhrPollingTransport;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var inherits = __webpack_require__(25),
	    AjaxBasedTransport = __webpack_require__(30),
	    XdrStreamingTransport = __webpack_require__(39),
	    XhrReceiver = __webpack_require__(34),
	    XDRObject = __webpack_require__(40);

	function XdrPollingTransport(transUrl) {
	  if (!XDRObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
	}

	inherits(XdrPollingTransport, AjaxBasedTransport);

	XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
	XdrPollingTransport.transportName = 'xdr-polling';
	XdrPollingTransport.roundTrips = 2; // preflight, ajax

	module.exports = XdrPollingTransport;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	// The simplest and most robust transport, using the well-know cross
	// domain hack - JSONP. This transport is quite inefficient - one
	// message could use up to one http request. But at least it works almost
	// everywhere.
	// Known limitations:
	//   o you will get a spinning cursor
	//   o for Konqueror a dumb timer is needed to detect errors

	var inherits = __webpack_require__(25),
	    SenderReceiver = __webpack_require__(31),
	    JsonpReceiver = __webpack_require__(55),
	    jsonpSender = __webpack_require__(56);

	function JsonPTransport(transUrl) {
	  if (!JsonPTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
	}

	inherits(JsonPTransport, SenderReceiver);

	JsonPTransport.enabled = function () {
	  return !!global.document;
	};

	JsonPTransport.transportName = 'jsonp-polling';
	JsonPTransport.roundTrips = 1;
	JsonPTransport.needBody = true;

	module.exports = JsonPTransport;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

	var utils = __webpack_require__(48),
	    random = __webpack_require__(16),
	    browser = __webpack_require__(38),
	    urlUtils = __webpack_require__(18),
	    inherits = __webpack_require__(25),
	    EventEmitter = __webpack_require__(26).EventEmitter;

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:receiver:jsonp');
	}

	function JsonpReceiver(url) {
	  debug(url);
	  var self = this;
	  EventEmitter.call(this);

	  utils.polluteGlobalNamespace();

	  this.id = 'a' + random.string(6);
	  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

	  global[utils.WPrefix][this.id] = this._callback.bind(this);
	  this._createScript(urlWithId);

	  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
	  this.timeoutId = setTimeout(function () {
	    debug('timeout');
	    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
	  }, JsonpReceiver.timeout);
	}

	inherits(JsonpReceiver, EventEmitter);

	JsonpReceiver.prototype.abort = function () {
	  debug('abort');
	  if (global[utils.WPrefix][this.id]) {
	    var err = new Error('JSONP user aborted read');
	    err.code = 1000;
	    this._abort(err);
	  }
	};

	JsonpReceiver.timeout = 35000;
	JsonpReceiver.scriptErrorTimeout = 1000;

	JsonpReceiver.prototype._callback = function (data) {
	  debug('_callback', data);
	  this._cleanup();

	  if (this.aborting) {
	    return;
	  }

	  if (data) {
	    debug('message', data);
	    this.emit('message', data);
	  }
	  this.emit('close', null, 'network');
	  this.removeAllListeners();
	};

	JsonpReceiver.prototype._abort = function (err) {
	  debug('_abort', err);
	  this._cleanup();
	  this.aborting = true;
	  this.emit('close', err.code, err.message);
	  this.removeAllListeners();
	};

	JsonpReceiver.prototype._cleanup = function () {
	  debug('_cleanup');
	  clearTimeout(this.timeoutId);
	  if (this.script2) {
	    this.script2.parentNode.removeChild(this.script2);
	    this.script2 = null;
	  }
	  if (this.script) {
	    var script = this.script;
	    // Unfortunately, you can't really abort script loading of
	    // the script.
	    script.parentNode.removeChild(script);
	    script.onreadystatechange = script.onerror = script.onload = script.onclick = null;
	    this.script = null;
	  }
	  delete global[utils.WPrefix][this.id];
	};

	JsonpReceiver.prototype._scriptError = function () {
	  debug('_scriptError');
	  var self = this;
	  if (this.errorTimer) {
	    return;
	  }

	  this.errorTimer = setTimeout(function () {
	    if (!self.loadedOkay) {
	      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
	    }
	  }, JsonpReceiver.scriptErrorTimeout);
	};

	JsonpReceiver.prototype._createScript = function (url) {
	  debug('_createScript', url);
	  var self = this;
	  var script = this.script = global.document.createElement('script');
	  var script2; // Opera synchronous load trick.

	  script.id = 'a' + random.string(8);
	  script.src = url;
	  script.type = 'text/javascript';
	  script.charset = 'UTF-8';
	  script.onerror = this._scriptError.bind(this);
	  script.onload = function () {
	    debug('onload');
	    self._abort(new Error('JSONP script loaded abnormally (onload)'));
	  };

	  // IE9 fires 'error' event after onreadystatechange or before, in random order.
	  // Use loadedOkay to determine if actually errored
	  script.onreadystatechange = function () {
	    debug('onreadystatechange', script.readyState);
	    if (/loaded|closed/.test(script.readyState)) {
	      if (script && script.htmlFor && script.onclick) {
	        self.loadedOkay = true;
	        try {
	          // In IE, actually execute the script.
	          script.onclick();
	        } catch (x) {
	          // intentionally empty
	        }
	      }
	      if (script) {
	        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
	      }
	    }
	  };
	  // IE: event/htmlFor/onclick trick.
	  // One can't rely on proper order for onreadystatechange. In order to
	  // make sure, set a 'htmlFor' and 'event' properties, so that
	  // script code will be installed as 'onclick' handler for the
	  // script object. Later, onreadystatechange, manually execute this
	  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
	  // set. For reference see:
	  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
	  // Also, read on that about script ordering:
	  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
	  if (typeof script.async === 'undefined' && global.document.attachEvent) {
	    // According to mozilla docs, in recent browsers script.async defaults
	    // to 'true', so we may use it to detect a good browser:
	    // https://developer.mozilla.org/en/HTML/Element/script
	    if (!browser.isOpera()) {
	      // Naively assume we're in IE
	      try {
	        script.htmlFor = script.id;
	        script.event = 'onclick';
	      } catch (x) {
	        // intentionally empty
	      }
	      script.async = true;
	    } else {
	      // Opera, second sync script hack
	      script2 = this.script2 = global.document.createElement('script');
	      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
	      script.async = script2.async = false;
	    }
	  }
	  if (typeof script.async !== 'undefined') {
	    script.async = true;
	  }

	  var head = global.document.getElementsByTagName('head')[0];
	  head.insertBefore(script, head.firstChild);
	  if (script2) {
	    head.insertBefore(script2, head.firstChild);
	  }
	};

	module.exports = JsonpReceiver;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14), (function() { return this; }())))

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

	var random = __webpack_require__(16),
	    urlUtils = __webpack_require__(18);

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:sender:jsonp');
	}

	var form, area;

	function createIframe(id) {
	  debug('createIframe', id);
	  try {
	    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	    return global.document.createElement('<iframe name="' + id + '">');
	  } catch (x) {
	    var iframe = global.document.createElement('iframe');
	    iframe.name = id;
	    return iframe;
	  }
	}

	function createForm() {
	  debug('createForm');
	  form = global.document.createElement('form');
	  form.style.display = 'none';
	  form.style.position = 'absolute';
	  form.method = 'POST';
	  form.enctype = 'application/x-www-form-urlencoded';
	  form.acceptCharset = 'UTF-8';

	  area = global.document.createElement('textarea');
	  area.name = 'd';
	  form.appendChild(area);

	  global.document.body.appendChild(form);
	}

	module.exports = function (url, payload, callback) {
	  debug(url, payload);
	  if (!form) {
	    createForm();
	  }
	  var id = 'a' + random.string(8);
	  form.target = id;
	  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

	  var iframe = createIframe(id);
	  iframe.id = id;
	  iframe.style.display = 'none';
	  form.appendChild(iframe);

	  try {
	    area.value = payload;
	  } catch (e) {
	    // seriously broken browsers get here
	  }
	  form.submit();

	  var completed = function completed(err) {
	    debug('completed', id, err);
	    if (!iframe.onerror) {
	      return;
	    }
	    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
	    // Opera mini doesn't like if we GC iframe
	    // immediately, thus this timeout.
	    setTimeout(function () {
	      debug('cleaning up', id);
	      iframe.parentNode.removeChild(iframe);
	      iframe = null;
	    }, 500);
	    area.value = '';
	    // It is not possible to detect if the iframe succeeded or
	    // failed to submit our form.
	    callback(err);
	  };
	  iframe.onerror = function () {
	    debug('onerror', id);
	    completed();
	  };
	  iframe.onload = function () {
	    debug('onload', id);
	    completed();
	  };
	  iframe.onreadystatechange = function (e) {
	    debug('onreadystatechange', id, iframe.readyState, e);
	    if (iframe.readyState === 'complete') {
	      completed();
	    }
	  };
	  return function () {
	    debug('aborted', id);
	    completed(new Error('Aborted'));
	  };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14), (function() { return this; }())))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

	__webpack_require__(58);

	var URL = __webpack_require__(19),
	    inherits = __webpack_require__(25),
	    JSON3 = __webpack_require__(46),
	    random = __webpack_require__(16),
	    escape = __webpack_require__(59),
	    urlUtils = __webpack_require__(18),
	    eventUtils = __webpack_require__(15),
	    transport = __webpack_require__(60),
	    objectUtils = __webpack_require__(49),
	    browser = __webpack_require__(38),
	    log = __webpack_require__(61),
	    Event = __webpack_require__(62),
	    EventTarget = __webpack_require__(27),
	    loc = __webpack_require__(63),
	    CloseEvent = __webpack_require__(64),
	    TransportMessageEvent = __webpack_require__(65),
	    InfoReceiver = __webpack_require__(66);

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:main');
	}

	var transports;

	// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
	function SockJS(url, protocols, options) {
	  if (!(this instanceof SockJS)) {
	    return new SockJS(url, protocols, options);
	  }
	  if (arguments.length < 1) {
	    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
	  }
	  EventTarget.call(this);

	  this.readyState = SockJS.CONNECTING;
	  this.extensions = '';
	  this.protocol = '';

	  // non-standard extension
	  options = options || {};
	  if (options.protocols_whitelist) {
	    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
	  }
	  this._transportsWhitelist = options.transports;
	  this._transportOptions = options.transportOptions || {};

	  var sessionId = options.sessionId || 8;
	  if (typeof sessionId === 'function') {
	    this._generateSessionId = sessionId;
	  } else if (typeof sessionId === 'number') {
	    this._generateSessionId = function () {
	      return random.string(sessionId);
	    };
	  } else {
	    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
	  }

	  this._server = options.server || random.numberString(1000);

	  // Step 1 of WS spec - parse and validate the url. Issue #8
	  var parsedUrl = new URL(url);
	  if (!parsedUrl.host || !parsedUrl.protocol) {
	    throw new SyntaxError("The URL '" + url + "' is invalid");
	  } else if (parsedUrl.hash) {
	    throw new SyntaxError('The URL must not contain a fragment');
	  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
	    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
	  }

	  var secure = parsedUrl.protocol === 'https:';
	  // Step 2 - don't allow secure origin with an insecure protocol
	  if (loc.protocol === 'https' && !secure) {
	    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
	  }

	  // Step 3 - check port access - no need here
	  // Step 4 - parse protocols argument
	  if (!protocols) {
	    protocols = [];
	  } else if (!Array.isArray(protocols)) {
	    protocols = [protocols];
	  }

	  // Step 5 - check protocols argument
	  var sortedProtocols = protocols.sort();
	  sortedProtocols.forEach(function (proto, i) {
	    if (!proto) {
	      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
	    }
	    if (i < sortedProtocols.length - 1 && proto === sortedProtocols[i + 1]) {
	      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
	    }
	  });

	  // Step 6 - convert origin
	  var o = urlUtils.getOrigin(loc.href);
	  this._origin = o ? o.toLowerCase() : null;

	  // remove the trailing slash
	  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

	  // store the sanitized url
	  this.url = parsedUrl.href;
	  debug('using url', this.url);

	  // Step 7 - start connection in background
	  // obtain server info
	  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
	  this._urlInfo = {
	    nullOrigin: !browser.hasDomain(),
	    sameOrigin: urlUtils.isOriginEqual(this.url, loc.href),
	    sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
	  };

	  this._ir = new InfoReceiver(this.url, this._urlInfo);
	  this._ir.once('finish', this._receiveInfo.bind(this));
	}

	inherits(SockJS, EventTarget);

	function userSetCode(code) {
	  return code === 1000 || code >= 3000 && code <= 4999;
	}

	SockJS.prototype.close = function (code, reason) {
	  // Step 1
	  if (code && !userSetCode(code)) {
	    throw new Error('InvalidAccessError: Invalid code');
	  }
	  // Step 2.4 states the max is 123 bytes, but we are just checking length
	  if (reason && reason.length > 123) {
	    throw new SyntaxError('reason argument has an invalid length');
	  }

	  // Step 3.1
	  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
	    return;
	  }

	  // TODO look at docs to determine how to set this
	  var wasClean = true;
	  this._close(code || 1000, reason || 'Normal closure', wasClean);
	};

	SockJS.prototype.send = function (data) {
	  // #13 - convert anything non-string to string
	  // TODO this currently turns objects into [object Object]
	  if (typeof data !== 'string') {
	    data = '' + data;
	  }
	  if (this.readyState === SockJS.CONNECTING) {
	    throw new Error('InvalidStateError: The connection has not been established yet');
	  }
	  if (this.readyState !== SockJS.OPEN) {
	    return;
	  }
	  this._transport.send(escape.quote(data));
	};

	SockJS.version = __webpack_require__(47);

	SockJS.CONNECTING = 0;
	SockJS.OPEN = 1;
	SockJS.CLOSING = 2;
	SockJS.CLOSED = 3;

	SockJS.prototype._receiveInfo = function (info, rtt) {
	  debug('_receiveInfo', rtt);
	  this._ir = null;
	  if (!info) {
	    this._close(1002, 'Cannot connect to server');
	    return;
	  }

	  // establish a round-trip timeout (RTO) based on the
	  // round-trip time (RTT)
	  this._rto = this.countRTO(rtt);
	  // allow server to override url used for the actual transport
	  this._transUrl = info.base_url ? info.base_url : this.url;
	  info = objectUtils.extend(info, this._urlInfo);
	  debug('info', info);
	  // determine list of desired and supported transports
	  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
	  this._transports = enabledTransports.main;
	  debug(this._transports.length + ' enabled transports');

	  this._connect();
	};

	SockJS.prototype._connect = function () {
	  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
	    debug('attempt', Transport.transportName);
	    if (Transport.needBody) {
	      if (!global.document.body || typeof global.document.readyState !== 'undefined' && global.document.readyState !== 'complete' && global.document.readyState !== 'interactive') {
	        debug('waiting for body');
	        this._transports.unshift(Transport);
	        eventUtils.attachEvent('load', this._connect.bind(this));
	        return;
	      }
	    }

	    // calculate timeout based on RTO and round trips. Default to 5s
	    var timeoutMs = this._rto * Transport.roundTrips || 5000;
	    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
	    debug('using timeout', timeoutMs);

	    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
	    var options = this._transportOptions[Transport.transportName];
	    debug('transport url', transportUrl);
	    var transportObj = new Transport(transportUrl, this._transUrl, options);
	    transportObj.on('message', this._transportMessage.bind(this));
	    transportObj.once('close', this._transportClose.bind(this));
	    transportObj.transportName = Transport.transportName;
	    this._transport = transportObj;

	    return;
	  }
	  this._close(2000, 'All transports failed', false);
	};

	SockJS.prototype._transportTimeout = function () {
	  debug('_transportTimeout');
	  if (this.readyState === SockJS.CONNECTING) {
	    this._transportClose(2007, 'Transport timed out');
	  }
	};

	SockJS.prototype._transportMessage = function (msg) {
	  debug('_transportMessage', msg);
	  var self = this,
	      type = msg.slice(0, 1),
	      content = msg.slice(1),
	      payload;

	  // first check for messages that don't need a payload
	  switch (type) {
	    case 'o':
	      this._open();
	      return;
	    case 'h':
	      this.dispatchEvent(new Event('heartbeat'));
	      debug('heartbeat', this.transport);
	      return;
	  }

	  if (content) {
	    try {
	      payload = JSON3.parse(content);
	    } catch (e) {
	      debug('bad json', content);
	    }
	  }

	  if (typeof payload === 'undefined') {
	    debug('empty payload', content);
	    return;
	  }

	  switch (type) {
	    case 'a':
	      if (Array.isArray(payload)) {
	        payload.forEach(function (p) {
	          debug('message', self.transport, p);
	          self.dispatchEvent(new TransportMessageEvent(p));
	        });
	      }
	      break;
	    case 'm':
	      debug('message', this.transport, payload);
	      this.dispatchEvent(new TransportMessageEvent(payload));
	      break;
	    case 'c':
	      if (Array.isArray(payload) && payload.length === 2) {
	        this._close(payload[0], payload[1], true);
	      }
	      break;
	  }
	};

	SockJS.prototype._transportClose = function (code, reason) {
	  debug('_transportClose', this.transport, code, reason);
	  if (this._transport) {
	    this._transport.removeAllListeners();
	    this._transport = null;
	    this.transport = null;
	  }

	  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
	    this._connect();
	    return;
	  }

	  this._close(code, reason);
	};

	SockJS.prototype._open = function () {
	  debug('_open', this._transport.transportName, this.readyState);
	  if (this.readyState === SockJS.CONNECTING) {
	    if (this._transportTimeoutId) {
	      clearTimeout(this._transportTimeoutId);
	      this._transportTimeoutId = null;
	    }
	    this.readyState = SockJS.OPEN;
	    this.transport = this._transport.transportName;
	    this.dispatchEvent(new Event('open'));
	    debug('connected', this.transport);
	  } else {
	    // The server might have been restarted, and lost track of our
	    // connection.
	    this._close(1006, 'Server lost session');
	  }
	};

	SockJS.prototype._close = function (code, reason, wasClean) {
	  debug('_close', this.transport, code, reason, wasClean, this.readyState);
	  var forceFail = false;

	  if (this._ir) {
	    forceFail = true;
	    this._ir.close();
	    this._ir = null;
	  }
	  if (this._transport) {
	    this._transport.close();
	    this._transport = null;
	    this.transport = null;
	  }

	  if (this.readyState === SockJS.CLOSED) {
	    throw new Error('InvalidStateError: SockJS has already been closed');
	  }

	  this.readyState = SockJS.CLOSING;
	  setTimeout(function () {
	    this.readyState = SockJS.CLOSED;

	    if (forceFail) {
	      this.dispatchEvent(new Event('error'));
	    }

	    var e = new CloseEvent('close');
	    e.wasClean = wasClean || false;
	    e.code = code || 1000;
	    e.reason = reason;

	    this.dispatchEvent(e);
	    this.onmessage = this.onclose = this.onerror = null;
	    debug('disconnected');
	  }.bind(this), 0);
	};

	// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
	// and RFC 2988.
	SockJS.prototype.countRTO = function (rtt) {
	  // In a local environment, when using IE8/9 and the `jsonp-polling`
	  // transport the time needed to establish a connection (the time that pass
	  // from the opening of the transport to the call of `_dispatchOpen`) is
	  // around 200msec (the lower bound used in the article above) and this
	  // causes spurious timeouts. For this reason we calculate a value slightly
	  // larger than that used in the article.
	  if (rtt > 100) {
	    return 4 * rtt; // rto > 400msec
	  }
	  return 300 + rtt; // 300msec < rto <= 400msec
	};

	module.exports = function (availableTransports) {
	  transports = transport(availableTransports);
	  __webpack_require__(71)(SockJS, availableTransports);
	  return SockJS;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14), (function() { return this; }())))

/***/ }),
/* 58 */
/***/ (function(module, exports) {

	/* eslint-disable */
	/* jscs: disable */
	'use strict';

	// pulled specific shims from https://github.com/es-shims/es5-shim

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var ArrayPrototype = Array.prototype;
	var ObjectPrototype = Object.prototype;
	var FunctionPrototype = Function.prototype;
	var StringPrototype = String.prototype;
	var array_slice = ArrayPrototype.slice;

	var _toString = ObjectPrototype.toString;
	var isFunction = function isFunction(val) {
	    return ObjectPrototype.toString.call(val) === '[object Function]';
	};
	var isArray = function isArray(obj) {
	    return _toString.call(obj) === '[object Array]';
	};
	var isString = function isString(obj) {
	    return _toString.call(obj) === '[object String]';
	};

	var supportsDescriptors = Object.defineProperty && function () {
	    try {
	        Object.defineProperty({}, 'x', {});
	        return true;
	    } catch (e) {
	        /* this is ES3 */
	        return false;
	    }
	}();

	// Define configurable, writable and non-enumerable props
	// if they don't exist.
	var defineProperty;
	if (supportsDescriptors) {
	    defineProperty = function defineProperty(object, name, method, forceAssign) {
	        if (!forceAssign && name in object) {
	            return;
	        }
	        Object.defineProperty(object, name, {
	            configurable: true,
	            enumerable: false,
	            writable: true,
	            value: method
	        });
	    };
	} else {
	    defineProperty = function defineProperty(object, name, method, forceAssign) {
	        if (!forceAssign && name in object) {
	            return;
	        }
	        object[name] = method;
	    };
	}
	var defineProperties = function defineProperties(object, map, forceAssign) {
	    for (var name in map) {
	        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
	            defineProperty(object, name, map[name], forceAssign);
	        }
	    }
	};

	var toObject = function toObject(o) {
	    if (o == null) {
	        // this matches both null and undefined
	        throw new TypeError("can't convert " + o + ' to object');
	    }
	    return Object(o);
	};

	//
	// Util
	// ======
	//

	// ES5 9.4
	// http://es5.github.com/#x9.4
	// http://jsperf.com/to-integer

	function toInteger(num) {
	    var n = +num;
	    if (n !== n) {
	        // isNaN
	        n = 0;
	    } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
	        n = (n > 0 || -1) * Math.floor(Math.abs(n));
	    }
	    return n;
	}

	function ToUint32(x) {
	    return x >>> 0;
	}

	//
	// Function
	// ========
	//

	// ES-5 15.3.4.5
	// http://es5.github.com/#x15.3.4.5

	function Empty() {}

	defineProperties(FunctionPrototype, {
	    bind: function bind(that) {
	        // .length is 1
	        // 1. Let Target be the this value.
	        var target = this;
	        // 2. If IsCallable(Target) is false, throw a TypeError exception.
	        if (!isFunction(target)) {
	            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
	        }
	        // 3. Let A be a new (possibly empty) internal list of all of the
	        //   argument values provided after thisArg (arg1, arg2 etc), in order.
	        // XXX slicedArgs will stand in for "A" if used
	        var args = array_slice.call(arguments, 1); // for normal call
	        // 4. Let F be a new native ECMAScript object.
	        // 11. Set the [[Prototype]] internal property of F to the standard
	        //   built-in Function prototype object as specified in 15.3.3.1.
	        // 12. Set the [[Call]] internal property of F as described in
	        //   15.3.4.5.1.
	        // 13. Set the [[Construct]] internal property of F as described in
	        //   15.3.4.5.2.
	        // 14. Set the [[HasInstance]] internal property of F as described in
	        //   15.3.4.5.3.
	        var binder = function binder() {

	            if (this instanceof bound) {
	                // 15.3.4.5.2 [[Construct]]
	                // When the [[Construct]] internal method of a function object,
	                // F that was created using the bind function is called with a
	                // list of arguments ExtraArgs, the following steps are taken:
	                // 1. Let target be the value of F's [[TargetFunction]]
	                //   internal property.
	                // 2. If target has no [[Construct]] internal method, a
	                //   TypeError exception is thrown.
	                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Construct]] internal
	                //   method of target providing args as the arguments.

	                var result = target.apply(this, args.concat(array_slice.call(arguments)));
	                if (Object(result) === result) {
	                    return result;
	                }
	                return this;
	            } else {
	                // 15.3.4.5.1 [[Call]]
	                // When the [[Call]] internal method of a function object, F,
	                // which was created using the bind function is called with a
	                // this value and a list of arguments ExtraArgs, the following
	                // steps are taken:
	                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 2. Let boundThis be the value of F's [[BoundThis]] internal
	                //   property.
	                // 3. Let target be the value of F's [[TargetFunction]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Call]] internal method
	                //   of target providing boundThis as the this value and
	                //   providing args as the arguments.

	                // equiv: target.call(this, ...boundArgs, ...args)
	                return target.apply(that, args.concat(array_slice.call(arguments)));
	            }
	        };

	        // 15. If the [[Class]] internal property of Target is "Function", then
	        //     a. Let L be the length property of Target minus the length of A.
	        //     b. Set the length own property of F to either 0 or L, whichever is
	        //       larger.
	        // 16. Else set the length own property of F to 0.

	        var boundLength = Math.max(0, target.length - args.length);

	        // 17. Set the attributes of the length own property of F to the values
	        //   specified in 15.3.5.1.
	        var boundArgs = [];
	        for (var i = 0; i < boundLength; i++) {
	            boundArgs.push('$' + i);
	        }

	        // XXX Build a dynamic function with desired amount of arguments is the only
	        // way to set the length property of a function.
	        // In environments where Content Security Policies enabled (Chrome extensions,
	        // for ex.) all use of eval or Function costructor throws an exception.
	        // However in all of these environments Function.prototype.bind exists
	        // and so this code will never be executed.
	        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

	        if (target.prototype) {
	            Empty.prototype = target.prototype;
	            bound.prototype = new Empty();
	            // Clean up dangling references.
	            Empty.prototype = null;
	        }

	        // TODO
	        // 18. Set the [[Extensible]] internal property of F to true.

	        // TODO
	        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
	        // 20. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
	        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
	        //   false.
	        // 21. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
	        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
	        //   and false.

	        // TODO
	        // NOTE Function objects created using Function.prototype.bind do not
	        // have a prototype property or the [[Code]], [[FormalParameters]], and
	        // [[Scope]] internal properties.
	        // XXX can't delete prototype in pure-js.

	        // 22. Return F.
	        return bound;
	    }
	});

	//
	// Array
	// =====
	//

	// ES5 15.4.3.2
	// http://es5.github.com/#x15.4.3.2
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
	defineProperties(Array, { isArray: isArray });

	var boxedString = Object('a');
	var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

	var properlyBoxesContext = function properlyBoxed(method) {
	    // Check node 0.6.21 bug where third parameter is not boxed
	    var properlyBoxesNonStrict = true;
	    var properlyBoxesStrict = true;
	    if (method) {
	        method.call('foo', function (_, __, context) {
	            if ((typeof context === 'undefined' ? 'undefined' : _typeof(context)) !== 'object') {
	                properlyBoxesNonStrict = false;
	            }
	        });

	        method.call([1], function () {
	            'use strict';

	            properlyBoxesStrict = typeof this === 'string';
	        }, 'x');
	    }
	    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
	};

	defineProperties(ArrayPrototype, {
	    forEach: function forEach(fun /*, thisp*/) {
	        var object = toObject(this),
	            self = splitString && isString(this) ? this.split('') : object,
	            thisp = arguments[1],
	            i = -1,
	            length = self.length >>> 0;

	        // If no callback function or if callback is not a callable function
	        if (!isFunction(fun)) {
	            throw new TypeError(); // TODO message
	        }

	        while (++i < length) {
	            if (i in self) {
	                // Invoke the callback function with call, passing arguments:
	                // context, property value, property key, thisArg object
	                // context
	                fun.call(thisp, self[i], i, object);
	            }
	        }
	    }
	}, !properlyBoxesContext(ArrayPrototype.forEach));

	// ES5 15.4.4.14
	// http://es5.github.com/#x15.4.4.14
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
	var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
	defineProperties(ArrayPrototype, {
	    indexOf: function indexOf(sought /*, fromIndex */) {
	        var self = splitString && isString(this) ? this.split('') : toObject(this),
	            length = self.length >>> 0;

	        if (!length) {
	            return -1;
	        }

	        var i = 0;
	        if (arguments.length > 1) {
	            i = toInteger(arguments[1]);
	        }

	        // handle negative indices
	        i = i >= 0 ? i : Math.max(0, length + i);
	        for (; i < length; i++) {
	            if (i in self && self[i] === sought) {
	                return i;
	            }
	        }
	        return -1;
	    }
	}, hasFirefox2IndexOfBug);

	//
	// String
	// ======
	//

	// ES5 15.5.4.14
	// http://es5.github.com/#x15.5.4.14

	// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
	// Many browsers do not split properly with regular expressions or they
	// do not perform the split correctly under obscure conditions.
	// See http://blog.stevenlevithan.com/archives/cross-browser-split
	// I've tested in many browsers and this seems to cover the deviant ones:
	//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
	//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
	//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
	//       [undefined, "t", undefined, "e", ...]
	//    ''.split(/.?/) should be [], not [""]
	//    '.'.split(/()()/) should be ["."], not ["", "", "."]

	var string_split = StringPrototype.split;
	if ('ab'.split(/(?:ab)*/).length !== 2 || '.'.split(/(.?)(.?)/).length !== 4 || 'tesst'.split(/(s)*/)[1] === 't' || 'test'.split(/(?:)/, -1).length !== 4 || ''.split(/.?/).length || '.'.split(/()()/).length > 1) {
	    (function () {
	        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

	        StringPrototype.split = function (separator, limit) {
	            var string = this;
	            if (separator === void 0 && limit === 0) {
	                return [];
	            }

	            // If `separator` is not a regex, use native split
	            if (_toString.call(separator) !== '[object RegExp]') {
	                return string_split.call(this, separator, limit);
	            }

	            var output = [],
	                flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.extended ? 'x' : '') + ( // Proposed for ES6
	            separator.sticky ? 'y' : ''),
	                // Firefox 3+
	            lastLastIndex = 0,

	            // Make `global` and avoid `lastIndex` issues by working with a copy
	            separator2,
	                match,
	                lastIndex,
	                lastLength;
	            separator = new RegExp(separator.source, flags + 'g');
	            string += ''; // Type-convert
	            if (!compliantExecNpcg) {
	                // Doesn't need flags gy, but they don't hurt
	                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
	            }
	            /* Values for `limit`, per the spec:
	             * If undefined: 4294967295 // Math.pow(2, 32) - 1
	             * If 0, Infinity, or NaN: 0
	             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
	             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
	             * If other: Type-convert, then use the above rules
	             */
	            limit = limit === void 0 ? -1 >>> 0 : // Math.pow(2, 32) - 1
	            ToUint32(limit);
	            while (match = separator.exec(string)) {
	                // `separator.lastIndex` is not reliable cross-browser
	                lastIndex = match.index + match[0].length;
	                if (lastIndex > lastLastIndex) {
	                    output.push(string.slice(lastLastIndex, match.index));
	                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
	                    // nonparticipating capturing groups
	                    if (!compliantExecNpcg && match.length > 1) {
	                        match[0].replace(separator2, function () {
	                            for (var i = 1; i < arguments.length - 2; i++) {
	                                if (arguments[i] === void 0) {
	                                    match[i] = void 0;
	                                }
	                            }
	                        });
	                    }
	                    if (match.length > 1 && match.index < string.length) {
	                        ArrayPrototype.push.apply(output, match.slice(1));
	                    }
	                    lastLength = match[0].length;
	                    lastLastIndex = lastIndex;
	                    if (output.length >= limit) {
	                        break;
	                    }
	                }
	                if (separator.lastIndex === match.index) {
	                    separator.lastIndex++; // Avoid an infinite loop
	                }
	            }
	            if (lastLastIndex === string.length) {
	                if (lastLength || !separator.test('')) {
	                    output.push('');
	                }
	            } else {
	                output.push(string.slice(lastLastIndex));
	            }
	            return output.length > limit ? output.slice(0, limit) : output;
	        };
	    })();

	    // [bugfix, chrome]
	    // If separator is undefined, then the result array contains just one String,
	    // which is the this value (converted to a String). If limit is not undefined,
	    // then the output array is truncated so that it contains no more than limit
	    // elements.
	    // "0".split(undefined, 0) -> []
	} else if ('0'.split(void 0, 0).length) {
	    StringPrototype.split = function split(separator, limit) {
	        if (separator === void 0 && limit === 0) {
	            return [];
	        }
	        return string_split.call(this, separator, limit);
	    };
	}

	// ECMA-262, 3rd B.2.3
	// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
	// non-normative section suggesting uniform semantics and it should be
	// normalized across all browsers
	// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
	var string_substr = StringPrototype.substr;
	var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
	defineProperties(StringPrototype, {
	    substr: function substr(start, length) {
	        return string_substr.call(this, start < 0 ? (start = this.length + start) < 0 ? 0 : start : start, length);
	    }
	}, hasNegativeSubstrBug);

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var JSON3 = __webpack_require__(46);

	// Some extra characters that Chrome gets wrong, and substitutes with
	// something else on the wire.
	// eslint-disable-next-line no-control-regex
	var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g,
	    extraLookup;

	// This may be quite slow, so let's delay until user actually uses bad
	// characters.
	var unrollLookup = function unrollLookup(escapable) {
	  var i;
	  var unrolled = {};
	  var c = [];
	  for (i = 0; i < 65536; i++) {
	    c.push(String.fromCharCode(i));
	  }
	  escapable.lastIndex = 0;
	  c.join('').replace(escapable, function (a) {
	    unrolled[a] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	    return '';
	  });
	  escapable.lastIndex = 0;
	  return unrolled;
	};

	// Quote string, also taking care of unicode characters that browsers
	// often break. Especially, take care of unicode surrogates:
	// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
	module.exports = {
	  quote: function quote(string) {
	    var quoted = JSON3.stringify(string);

	    // In most cases this should be very fast and good enough.
	    extraEscapable.lastIndex = 0;
	    if (!extraEscapable.test(quoted)) {
	      return quoted;
	    }

	    if (!extraLookup) {
	      extraLookup = unrollLookup(extraEscapable);
	    }

	    return quoted.replace(extraEscapable, function (a) {
	      return extraLookup[a];
	    });
	  }
	};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:utils:transport');
	}

	module.exports = function (availableTransports) {
	  return {
	    filterToEnabled: function filterToEnabled(transportsWhitelist, info) {
	      var transports = {
	        main: [],
	        facade: []
	      };
	      if (!transportsWhitelist) {
	        transportsWhitelist = [];
	      } else if (typeof transportsWhitelist === 'string') {
	        transportsWhitelist = [transportsWhitelist];
	      }

	      availableTransports.forEach(function (trans) {
	        if (!trans) {
	          return;
	        }

	        if (trans.transportName === 'websocket' && info.websocket === false) {
	          debug('disabled from server', 'websocket');
	          return;
	        }

	        if (transportsWhitelist.length && transportsWhitelist.indexOf(trans.transportName) === -1) {
	          debug('not in whitelist', trans.transportName);
	          return;
	        }

	        if (trans.enabled(info)) {
	          debug('enabled', trans.transportName);
	          transports.main.push(trans);
	          if (trans.facadeTransport) {
	            transports.facade.push(trans.facadeTransport);
	          }
	        } else {
	          debug('disabled', trans.transportName);
	        }
	      });
	      return transports;
	    }
	  };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 61 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var logObject = {};
	['log', 'debug', 'warn'].forEach(function (level) {
	  var levelExists;

	  try {
	    levelExists = global.console && global.console[level] && global.console[level].apply;
	  } catch (e) {
	    // do nothing
	  }

	  logObject[level] = levelExists ? function () {
	    return global.console[level].apply(global.console, arguments);
	  } : level === 'log' ? function () {} : logObject.log;
	});

	module.exports = logObject;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 62 */
/***/ (function(module, exports) {

	'use strict';

	function Event(eventType) {
	  this.type = eventType;
	}

	Event.prototype.initEvent = function (eventType, canBubble, cancelable) {
	  this.type = eventType;
	  this.bubbles = canBubble;
	  this.cancelable = cancelable;
	  this.timeStamp = +new Date();
	  return this;
	};

	Event.prototype.stopPropagation = function () {};
	Event.prototype.preventDefault = function () {};

	Event.CAPTURING_PHASE = 1;
	Event.AT_TARGET = 2;
	Event.BUBBLING_PHASE = 3;

	module.exports = Event;

/***/ }),
/* 63 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	module.exports = global.location || {
	  origin: 'http://localhost:80',
	  protocol: 'http',
	  host: 'localhost',
	  port: 80,
	  href: 'http://localhost/',
	  hash: ''
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var inherits = __webpack_require__(25),
	    Event = __webpack_require__(62);

	function CloseEvent() {
	  Event.call(this);
	  this.initEvent('close', false, false);
	  this.wasClean = false;
	  this.code = 0;
	  this.reason = '';
	}

	inherits(CloseEvent, Event);

	module.exports = CloseEvent;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var inherits = __webpack_require__(25),
	    Event = __webpack_require__(62);

	function TransportMessageEvent(data) {
	  Event.call(this);
	  this.initEvent('message', false, false);
	  this.data = data;
	}

	inherits(TransportMessageEvent, Event);

	module.exports = TransportMessageEvent;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var EventEmitter = __webpack_require__(26).EventEmitter,
	    inherits = __webpack_require__(25),
	    urlUtils = __webpack_require__(18),
	    XDR = __webpack_require__(40),
	    XHRCors = __webpack_require__(35),
	    XHRLocal = __webpack_require__(37),
	    XHRFake = __webpack_require__(67),
	    InfoIframe = __webpack_require__(68),
	    InfoAjax = __webpack_require__(70);

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:info-receiver');
	}

	function InfoReceiver(baseUrl, urlInfo) {
	  debug(baseUrl);
	  var self = this;
	  EventEmitter.call(this);

	  setTimeout(function () {
	    self.doXhr(baseUrl, urlInfo);
	  }, 0);
	}

	inherits(InfoReceiver, EventEmitter);

	// TODO this is currently ignoring the list of available transports and the whitelist

	InfoReceiver._getReceiver = function (baseUrl, url, urlInfo) {
	  // determine method of CORS support (if needed)
	  if (urlInfo.sameOrigin) {
	    return new InfoAjax(url, XHRLocal);
	  }
	  if (XHRCors.enabled) {
	    return new InfoAjax(url, XHRCors);
	  }
	  if (XDR.enabled && urlInfo.sameScheme) {
	    return new InfoAjax(url, XDR);
	  }
	  if (InfoIframe.enabled()) {
	    return new InfoIframe(baseUrl, url);
	  }
	  return new InfoAjax(url, XHRFake);
	};

	InfoReceiver.prototype.doXhr = function (baseUrl, urlInfo) {
	  var self = this,
	      url = urlUtils.addPath(baseUrl, '/info');
	  debug('doXhr', url);

	  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

	  this.timeoutRef = setTimeout(function () {
	    debug('timeout');
	    self._cleanup(false);
	    self.emit('finish');
	  }, InfoReceiver.timeout);

	  this.xo.once('finish', function (info, rtt) {
	    debug('finish', info, rtt);
	    self._cleanup(true);
	    self.emit('finish', info, rtt);
	  });
	};

	InfoReceiver.prototype._cleanup = function (wasClean) {
	  debug('_cleanup');
	  clearTimeout(this.timeoutRef);
	  this.timeoutRef = null;
	  if (!wasClean && this.xo) {
	    this.xo.close();
	  }
	  this.xo = null;
	};

	InfoReceiver.prototype.close = function () {
	  debug('close');
	  this.removeAllListeners();
	  this._cleanup(false);
	};

	InfoReceiver.timeout = 8000;

	module.exports = InfoReceiver;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var EventEmitter = __webpack_require__(26).EventEmitter,
	    inherits = __webpack_require__(25);

	function XHRFake() /* method, url, payload, opts */{
	  var self = this;
	  EventEmitter.call(this);

	  this.to = setTimeout(function () {
	    self.emit('finish', 200, '{}');
	  }, XHRFake.timeout);
	}

	inherits(XHRFake, EventEmitter);

	XHRFake.prototype.close = function () {
	  clearTimeout(this.to);
	};

	XHRFake.timeout = 2000;

	module.exports = XHRFake;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

	var EventEmitter = __webpack_require__(26).EventEmitter,
	    inherits = __webpack_require__(25),
	    JSON3 = __webpack_require__(46),
	    utils = __webpack_require__(15),
	    IframeTransport = __webpack_require__(45),
	    InfoReceiverIframe = __webpack_require__(69);

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:info-iframe');
	}

	function InfoIframe(baseUrl, url) {
	  var self = this;
	  EventEmitter.call(this);

	  var go = function go() {
	    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

	    ifr.once('message', function (msg) {
	      if (msg) {
	        var d;
	        try {
	          d = JSON3.parse(msg);
	        } catch (e) {
	          debug('bad json', msg);
	          self.emit('finish');
	          self.close();
	          return;
	        }

	        var info = d[0],
	            rtt = d[1];
	        self.emit('finish', info, rtt);
	      }
	      self.close();
	    });

	    ifr.once('close', function () {
	      self.emit('finish');
	      self.close();
	    });
	  };

	  // TODO this seems the same as the 'needBody' from transports
	  if (!global.document.body) {
	    utils.attachEvent('load', go);
	  } else {
	    go();
	  }
	}

	inherits(InfoIframe, EventEmitter);

	InfoIframe.enabled = function () {
	  return IframeTransport.enabled();
	};

	InfoIframe.prototype.close = function () {
	  if (this.ifr) {
	    this.ifr.close();
	  }
	  this.removeAllListeners();
	  this.ifr = null;
	};

	module.exports = InfoIframe;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14), (function() { return this; }())))

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var inherits = __webpack_require__(25),
	    EventEmitter = __webpack_require__(26).EventEmitter,
	    JSON3 = __webpack_require__(46),
	    XHRLocalObject = __webpack_require__(37),
	    InfoAjax = __webpack_require__(70);

	function InfoReceiverIframe(transUrl) {
	  var self = this;
	  EventEmitter.call(this);

	  this.ir = new InfoAjax(transUrl, XHRLocalObject);
	  this.ir.once('finish', function (info, rtt) {
	    self.ir = null;
	    self.emit('message', JSON3.stringify([info, rtt]));
	  });
	}

	inherits(InfoReceiverIframe, EventEmitter);

	InfoReceiverIframe.transportName = 'iframe-info-receiver';

	InfoReceiverIframe.prototype.close = function () {
	  if (this.ir) {
	    this.ir.close();
	    this.ir = null;
	  }
	  this.removeAllListeners();
	};

	module.exports = InfoReceiverIframe;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var EventEmitter = __webpack_require__(26).EventEmitter,
	    inherits = __webpack_require__(25),
	    JSON3 = __webpack_require__(46),
	    objectUtils = __webpack_require__(49);

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:info-ajax');
	}

	function InfoAjax(url, AjaxObject) {
	  EventEmitter.call(this);

	  var self = this;
	  var t0 = +new Date();
	  this.xo = new AjaxObject('GET', url);

	  this.xo.once('finish', function (status, text) {
	    var info, rtt;
	    if (status === 200) {
	      rtt = +new Date() - t0;
	      if (text) {
	        try {
	          info = JSON3.parse(text);
	        } catch (e) {
	          debug('bad json', text);
	        }
	      }

	      if (!objectUtils.isObject(info)) {
	        info = {};
	      }
	    }
	    self.emit('finish', info, rtt);
	    self.removeAllListeners();
	  });
	}

	inherits(InfoAjax, EventEmitter);

	InfoAjax.prototype.close = function () {
	  this.removeAllListeners();
	  this.xo.close();
	};

	module.exports = InfoAjax;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var urlUtils = __webpack_require__(18),
	    eventUtils = __webpack_require__(15),
	    JSON3 = __webpack_require__(46),
	    FacadeJS = __webpack_require__(72),
	    InfoIframeReceiver = __webpack_require__(69),
	    iframeUtils = __webpack_require__(48),
	    loc = __webpack_require__(63);

	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(22)('sockjs-client:iframe-bootstrap');
	}

	module.exports = function (SockJS, availableTransports) {
	  var transportMap = {};
	  availableTransports.forEach(function (at) {
	    if (at.facadeTransport) {
	      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
	    }
	  });

	  // hard-coded for the info iframe
	  // TODO see if we can make this more dynamic
	  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
	  var parentOrigin;

	  /* eslint-disable camelcase */
	  SockJS.bootstrap_iframe = function () {
	    /* eslint-enable camelcase */
	    var facade;
	    iframeUtils.currentWindowId = loc.hash.slice(1);
	    var onMessage = function onMessage(e) {
	      if (e.source !== parent) {
	        return;
	      }
	      if (typeof parentOrigin === 'undefined') {
	        parentOrigin = e.origin;
	      }
	      if (e.origin !== parentOrigin) {
	        return;
	      }

	      var iframeMessage;
	      try {
	        iframeMessage = JSON3.parse(e.data);
	      } catch (ignored) {
	        debug('bad json', e.data);
	        return;
	      }

	      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
	        return;
	      }
	      switch (iframeMessage.type) {
	        case 's':
	          var p;
	          try {
	            p = JSON3.parse(iframeMessage.data);
	          } catch (ignored) {
	            debug('bad json', iframeMessage.data);
	            break;
	          }
	          var version = p[0];
	          var transport = p[1];
	          var transUrl = p[2];
	          var baseUrl = p[3];
	          debug(version, transport, transUrl, baseUrl);
	          // change this to semver logic
	          if (version !== SockJS.version) {
	            throw new Error('Incompatible SockJS! Main site uses:' + ' "' + version + '", the iframe:' + ' "' + SockJS.version + '".');
	          }

	          if (!urlUtils.isOriginEqual(transUrl, loc.href) || !urlUtils.isOriginEqual(baseUrl, loc.href)) {
	            throw new Error('Can\'t connect to different domain from within an ' + 'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
	          }
	          facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
	          break;
	        case 'm':
	          facade._send(iframeMessage.data);
	          break;
	        case 'c':
	          if (facade) {
	            facade._close();
	          }
	          facade = null;
	          break;
	      }
	    };

	    eventUtils.attachEvent('message', onMessage);

	    // Start
	    iframeUtils.postMessage('s');
	  };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var JSON3 = __webpack_require__(46),
	    iframeUtils = __webpack_require__(48);

	function FacadeJS(transport) {
	  this._transport = transport;
	  transport.on('message', this._transportMessage.bind(this));
	  transport.on('close', this._transportClose.bind(this));
	}

	FacadeJS.prototype._transportClose = function (code, reason) {
	  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
	};
	FacadeJS.prototype._transportMessage = function (frame) {
	  iframeUtils.postMessage('t', frame);
	};
	FacadeJS.prototype._send = function (data) {
	  this._transport.send(data);
	};
	FacadeJS.prototype._close = function () {
	  this._transport.close();
	  this._transport.removeAllListeners();
	};

	module.exports = FacadeJS;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var ansiRegex = __webpack_require__(74)();

	module.exports = function (str) {
		return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
	};

/***/ }),
/* 74 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function () {
		return (/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g
		);
	};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	/*globals window __webpack_hash__ */
	if (true) {
		var lastData;
		var upToDate = function upToDate() {
			return lastData.indexOf(__webpack_require__.h()) >= 0;
		};
		var check = function check() {
			module.hot.check(true, function (err, updatedModules) {
				if (err) {
					if (module.hot.status() in {
						abort: 1,
						fail: 1
					}) {
						console.warn("[HMR] Cannot apply update. Need to do a full reload!");
						console.warn("[HMR] " + err.stack || err.message);
						window.location.reload();
					} else {
						console.warn("[HMR] Update failed: " + err.stack || err.message);
					}
					return;
				}

				if (!updatedModules) {
					console.warn("[HMR] Cannot find update. Need to do a full reload!");
					console.warn("[HMR] (Probably because of restarting the webpack-dev-server)");
					window.location.reload();
					return;
				}

				if (!upToDate()) {
					check();
				}

				__webpack_require__(76)(updatedModules, updatedModules);

				if (upToDate()) {
					console.log("[HMR] App is up to date.");
				}
			});
		};
		var addEventListener = window.addEventListener ? function (eventName, listener) {
			window.addEventListener(eventName, listener, false);
		} : function (eventName, listener) {
			window.attachEvent("on" + eventName, listener);
		};
		addEventListener("message", function (event) {
			if (typeof event.data === "string" && event.data.indexOf("webpackHotUpdate") === 0) {
				lastData = event.data;
				if (!upToDate() && module.hot.status() === "idle") {
					console.log("[HMR] Checking for updates on the server...");
					check();
				}
			}
		});
		console.log("[HMR] Waiting for update signal from WDS...");
	} else {
		throw new Error("[HMR] Hot Module Replacement is disabled.");
	}

/***/ }),
/* 76 */
/***/ (function(module, exports) {

	"use strict";

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function (updatedModules, renewedModules) {
		var unacceptedModules = updatedModules.filter(function (moduleId) {
			return renewedModules && renewedModules.indexOf(moduleId) < 0;
		});

		if (unacceptedModules.length > 0) {
			console.warn("[HMR] The following modules couldn't be hot updated: (They would need a full reload!)");
			unacceptedModules.forEach(function (moduleId) {
				console.warn("[HMR]  - " + moduleId);
			});
		}

		if (!renewedModules || renewedModules.length === 0) {
			console.log("[HMR] Nothing hot updated.");
		} else {
			console.log("[HMR] Updated modules:");
			renewedModules.forEach(function (moduleId) {
				console.log("[HMR]  - " + moduleId);
			});
		}
	};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _angular$module;

	var _angularUiRouter = __webpack_require__(78);

	var _angularUiRouter2 = _interopRequireDefault(_angularUiRouter);

	var _angularUiBootstrap = __webpack_require__(79);

	var _angularUiBootstrap2 = _interopRequireDefault(_angularUiBootstrap);

	__webpack_require__(81);

	var _Routes = __webpack_require__(91);

	var _Routes2 = _interopRequireDefault(_Routes);

	var _Directive = __webpack_require__(95);

	var _Directive2 = _interopRequireDefault(_Directive);

	var _Module = __webpack_require__(110);

	var _Module2 = _interopRequireDefault(_Module);

	var _Config = __webpack_require__(107);

	var _Config2 = _interopRequireDefault(_Config);

	var _Redux = __webpack_require__(93);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	function _toConsumableArray(arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }return arr2;
	  } else {
	    return Array.from(arr);
	  }
	} // import angular from 'angular';

	// import angularDrag from 'angular-dragdrop';


	console.log(_angularUiBootstrap2.default);
	var app = (_angular$module = angular.module('myApp', [_angularUiRouter2.default, _angularUiBootstrap2.default])).provider.apply(_angular$module, _toConsumableArray(_Routes2.default.provider)).config(_Routes2.default.config).run(_Routes2.default.run);

	// 记录app
	(0, _Redux.getRedux)(app, { type: "APP" });

	// 注入 directive 
	(0, _Directive2.default)(app);

	// 注入 module
	(0, _Module2.default)(app);

	// 注入统一配置
	(0, _Config.Constant)(app);

/***/ }),
/* 78 */
/***/ (function(module, exports) {

	"use strict";

	/**
	 * State-based routing for AngularJS
	 * @version v0.3.2
	 * @link http://angular-ui.github.com/
	 * @license MIT License, http://www.opensource.org/licenses/MIT
	 */

	/* commonjs package manager support (eg componentjs) */
	if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
	  module.exports = 'ui.router';
	}

	(function (window, angular, undefined) {
	  /*jshint globalstrict:true*/
	  /*global angular:false*/
	  'use strict';

	  var isDefined = angular.isDefined,
	      isFunction = angular.isFunction,
	      isString = angular.isString,
	      isObject = angular.isObject,
	      isArray = angular.isArray,
	      forEach = angular.forEach,
	      extend = angular.extend,
	      copy = angular.copy,
	      toJson = angular.toJson;

	  function inherit(parent, extra) {
	    return extend(new (extend(function () {}, { prototype: parent }))(), extra);
	  }

	  function merge(dst) {
	    forEach(arguments, function (obj) {
	      if (obj !== dst) {
	        forEach(obj, function (value, key) {
	          if (!dst.hasOwnProperty(key)) dst[key] = value;
	        });
	      }
	    });
	    return dst;
	  }

	  /**
	   * Finds the common ancestor path between two states.
	   *
	   * @param {Object} first The first state.
	   * @param {Object} second The second state.
	   * @return {Array} Returns an array of state names in descending order, not including the root.
	   */
	  function ancestors(first, second) {
	    var path = [];

	    for (var n in first.path) {
	      if (first.path[n] !== second.path[n]) break;
	      path.push(first.path[n]);
	    }
	    return path;
	  }

	  /**
	   * IE8-safe wrapper for `Object.keys()`.
	   *
	   * @param {Object} object A JavaScript object.
	   * @return {Array} Returns the keys of the object as an array.
	   */
	  function objectKeys(object) {
	    if (Object.keys) {
	      return Object.keys(object);
	    }
	    var result = [];

	    forEach(object, function (val, key) {
	      result.push(key);
	    });
	    return result;
	  }

	  /**
	   * IE8-safe wrapper for `Array.prototype.indexOf()`.
	   *
	   * @param {Array} array A JavaScript array.
	   * @param {*} value A value to search the array for.
	   * @return {Number} Returns the array index value of `value`, or `-1` if not present.
	   */
	  function indexOf(array, value) {
	    if (Array.prototype.indexOf) {
	      return array.indexOf(value, Number(arguments[2]) || 0);
	    }
	    var len = array.length >>> 0,
	        from = Number(arguments[2]) || 0;
	    from = from < 0 ? Math.ceil(from) : Math.floor(from);

	    if (from < 0) from += len;

	    for (; from < len; from++) {
	      if (from in array && array[from] === value) return from;
	    }
	    return -1;
	  }

	  /**
	   * Merges a set of parameters with all parameters inherited between the common parents of the
	   * current state and a given destination state.
	   *
	   * @param {Object} currentParams The value of the current state parameters ($stateParams).
	   * @param {Object} newParams The set of parameters which will be composited with inherited params.
	   * @param {Object} $current Internal definition of object representing the current state.
	   * @param {Object} $to Internal definition of object representing state to transition to.
	   */
	  function inheritParams(currentParams, newParams, $current, $to) {
	    var parents = ancestors($current, $to),
	        parentParams,
	        inherited = {},
	        inheritList = [];

	    for (var i in parents) {
	      if (!parents[i] || !parents[i].params) continue;
	      parentParams = objectKeys(parents[i].params);
	      if (!parentParams.length) continue;

	      for (var j in parentParams) {
	        if (indexOf(inheritList, parentParams[j]) >= 0) continue;
	        inheritList.push(parentParams[j]);
	        inherited[parentParams[j]] = currentParams[parentParams[j]];
	      }
	    }
	    return extend({}, inherited, newParams);
	  }

	  /**
	   * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.
	   *
	   * @param {Object} a The first object.
	   * @param {Object} b The second object.
	   * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,
	   *                     it defaults to the list of keys in `a`.
	   * @return {Boolean} Returns `true` if the keys match, otherwise `false`.
	   */
	  function equalForKeys(a, b, keys) {
	    if (!keys) {
	      keys = [];
	      for (var n in a) {
	        keys.push(n);
	      } // Used instead of Object.keys() for IE8 compatibility
	    }

	    for (var i = 0; i < keys.length; i++) {
	      var k = keys[i];
	      if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized
	    }
	    return true;
	  }

	  /**
	   * Returns the subset of an object, based on a list of keys.
	   *
	   * @param {Array} keys
	   * @param {Object} values
	   * @return {Boolean} Returns a subset of `values`.
	   */
	  function filterByKeys(keys, values) {
	    var filtered = {};

	    forEach(keys, function (name) {
	      filtered[name] = values[name];
	    });
	    return filtered;
	  }

	  // like _.indexBy
	  // when you know that your index values will be unique, or you want last-one-in to win
	  function indexBy(array, propName) {
	    var result = {};
	    forEach(array, function (item) {
	      result[item[propName]] = item;
	    });
	    return result;
	  }

	  // extracted from underscore.js
	  // Return a copy of the object only containing the whitelisted properties.
	  function pick(obj) {
	    var copy = {};
	    var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
	    forEach(keys, function (key) {
	      if (key in obj) copy[key] = obj[key];
	    });
	    return copy;
	  }

	  // extracted from underscore.js
	  // Return a copy of the object omitting the blacklisted properties.
	  function omit(obj) {
	    var copy = {};
	    var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
	    for (var key in obj) {
	      if (indexOf(keys, key) == -1) copy[key] = obj[key];
	    }
	    return copy;
	  }

	  function pluck(collection, key) {
	    var result = isArray(collection) ? [] : {};

	    forEach(collection, function (val, i) {
	      result[i] = isFunction(key) ? key(val) : val[key];
	    });
	    return result;
	  }

	  function filter(collection, callback) {
	    var array = isArray(collection);
	    var result = array ? [] : {};
	    forEach(collection, function (val, i) {
	      if (callback(val, i)) {
	        result[array ? result.length : i] = val;
	      }
	    });
	    return result;
	  }

	  function map(collection, callback) {
	    var result = isArray(collection) ? [] : {};

	    forEach(collection, function (val, i) {
	      result[i] = callback(val, i);
	    });
	    return result;
	  }

	  // issue #2676 #2889
	  function silenceUncaughtInPromise(promise) {
	    return promise.then(undefined, function () {}) && promise;
	  }

	  /**
	   * @ngdoc overview
	   * @name ui.router.util
	   *
	   * @description
	   * # ui.router.util sub-module
	   *
	   * This module is a dependency of other sub-modules. Do not include this module as a dependency
	   * in your angular app (use {@link ui.router} module instead).
	   *
	   */
	  angular.module('ui.router.util', ['ng']);

	  /**
	   * @ngdoc overview
	   * @name ui.router.router
	   * 
	   * @requires ui.router.util
	   *
	   * @description
	   * # ui.router.router sub-module
	   *
	   * This module is a dependency of other sub-modules. Do not include this module as a dependency
	   * in your angular app (use {@link ui.router} module instead).
	   */
	  angular.module('ui.router.router', ['ui.router.util']);

	  /**
	   * @ngdoc overview
	   * @name ui.router.state
	   * 
	   * @requires ui.router.router
	   * @requires ui.router.util
	   *
	   * @description
	   * # ui.router.state sub-module
	   *
	   * This module is a dependency of the main ui.router module. Do not include this module as a dependency
	   * in your angular app (use {@link ui.router} module instead).
	   * 
	   */
	  angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);

	  /**
	   * @ngdoc overview
	   * @name ui.router
	   *
	   * @requires ui.router.state
	   *
	   * @description
	   * # ui.router
	   * 
	   * ## The main module for ui.router 
	   * There are several sub-modules included with the ui.router module, however only this module is needed
	   * as a dependency within your angular app. The other modules are for organization purposes. 
	   *
	   * The modules are:
	   * * ui.router - the main "umbrella" module
	   * * ui.router.router - 
	   * 
	   * *You'll need to include **only** this module as the dependency within your angular app.*
	   * 
	   * <pre>
	   * <!doctype html>
	   * <html ng-app="myApp">
	   * <head>
	   *   <script src="js/angular.js"></script>
	   *   <!-- Include the ui-router script -->
	   *   <script src="js/angular-ui-router.min.js"></script>
	   *   <script>
	   *     // ...and add 'ui.router' as a dependency
	   *     var myApp = angular.module('myApp', ['ui.router']);
	   *   </script>
	   * </head>
	   * <body>
	   * </body>
	   * </html>
	   * </pre>
	   */
	  angular.module('ui.router', ['ui.router.state']);

	  angular.module('ui.router.compat', ['ui.router']);

	  /**
	   * @ngdoc object
	   * @name ui.router.util.$resolve
	   *
	   * @requires $q
	   * @requires $injector
	   *
	   * @description
	   * Manages resolution of (acyclic) graphs of promises.
	   */
	  $Resolve.$inject = ['$q', '$injector'];
	  function $Resolve($q, $injector) {

	    var VISIT_IN_PROGRESS = 1,
	        VISIT_DONE = 2,
	        NOTHING = {},
	        NO_DEPENDENCIES = [],
	        NO_LOCALS = NOTHING,
	        NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });

	    /**
	     * @ngdoc function
	     * @name ui.router.util.$resolve#study
	     * @methodOf ui.router.util.$resolve
	     *
	     * @description
	     * Studies a set of invocables that are likely to be used multiple times.
	     * <pre>
	     * $resolve.study(invocables)(locals, parent, self)
	     * </pre>
	     * is equivalent to
	     * <pre>
	     * $resolve.resolve(invocables, locals, parent, self)
	     * </pre>
	     * but the former is more efficient (in fact `resolve` just calls `study` 
	     * internally).
	     *
	     * @param {object} invocables Invocable objects
	     * @return {function} a function to pass in locals, parent and self
	     */
	    this.study = function (invocables) {
	      if (!isObject(invocables)) throw new Error("'invocables' must be an object");
	      var invocableKeys = objectKeys(invocables || {});

	      // Perform a topological sort of invocables to build an ordered plan
	      var plan = [],
	          cycle = [],
	          visited = {};
	      function visit(value, key) {
	        if (visited[key] === VISIT_DONE) return;

	        cycle.push(key);
	        if (visited[key] === VISIT_IN_PROGRESS) {
	          cycle.splice(0, indexOf(cycle, key));
	          throw new Error("Cyclic dependency: " + cycle.join(" -> "));
	        }
	        visited[key] = VISIT_IN_PROGRESS;

	        if (isString(value)) {
	          plan.push(key, [function () {
	            return $injector.get(value);
	          }], NO_DEPENDENCIES);
	        } else {
	          var params = $injector.annotate(value);
	          forEach(params, function (param) {
	            if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
	          });
	          plan.push(key, value, params);
	        }

	        cycle.pop();
	        visited[key] = VISIT_DONE;
	      }
	      forEach(invocables, visit);
	      invocables = cycle = visited = null; // plan is all that's required

	      function isResolve(value) {
	        return isObject(value) && value.then && value.$$promises;
	      }

	      return function (locals, parent, self) {
	        if (isResolve(locals) && self === undefined) {
	          self = parent;parent = locals;locals = null;
	        }
	        if (!locals) locals = NO_LOCALS;else if (!isObject(locals)) {
	          throw new Error("'locals' must be an object");
	        }
	        if (!parent) parent = NO_PARENT;else if (!isResolve(parent)) {
	          throw new Error("'parent' must be a promise returned by $resolve.resolve()");
	        }

	        // To complete the overall resolution, we have to wait for the parent
	        // promise and for the promise for each invokable in our plan.
	        var resolution = $q.defer(),
	            result = resolution.promise,
	            promises = result.$$promises = {},
	            values = extend({}, locals),
	            wait = 1 + plan.length / 3,
	            merged = false;

	        function done() {
	          // Merge parent values we haven't got yet and publish our own $$values
	          if (! --wait) {
	            if (!merged) merge(values, parent.$$values);
	            result.$$values = values;
	            result.$$promises = result.$$promises || true; // keep for isResolve()
	            delete result.$$inheritedValues;
	            resolution.resolve(values);
	          }
	        }

	        function fail(reason) {
	          result.$$failure = reason;
	          resolution.reject(reason);
	        }

	        // Short-circuit if parent has already failed
	        if (isDefined(parent.$$failure)) {
	          fail(parent.$$failure);
	          return result;
	        }

	        if (parent.$$inheritedValues) {
	          merge(values, omit(parent.$$inheritedValues, invocableKeys));
	        }

	        // Merge parent values if the parent has already resolved, or merge
	        // parent promises and wait if the parent resolve is still in progress.
	        extend(promises, parent.$$promises);
	        if (parent.$$values) {
	          merged = merge(values, omit(parent.$$values, invocableKeys));
	          result.$$inheritedValues = omit(parent.$$values, invocableKeys);
	          done();
	        } else {
	          if (parent.$$inheritedValues) {
	            result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
	          }
	          parent.then(done, fail);
	        }

	        // Process each invocable in the plan, but ignore any where a local of the same name exists.
	        for (var i = 0, ii = plan.length; i < ii; i += 3) {
	          if (locals.hasOwnProperty(plan[i])) done();else invoke(plan[i], plan[i + 1], plan[i + 2]);
	        }

	        function invoke(key, invocable, params) {
	          // Create a deferred for this invocation. Failures will propagate to the resolution as well.
	          var invocation = $q.defer(),
	              waitParams = 0;
	          function onfailure(reason) {
	            invocation.reject(reason);
	            fail(reason);
	          }
	          // Wait for any parameter that we have a promise for (either from parent or from this
	          // resolve; in that case study() will have made sure it's ordered before us in the plan).
	          forEach(params, function (dep) {
	            if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
	              waitParams++;
	              promises[dep].then(function (result) {
	                values[dep] = result;
	                if (! --waitParams) proceed();
	              }, onfailure);
	            }
	          });
	          if (!waitParams) proceed();
	          function proceed() {
	            if (isDefined(result.$$failure)) return;
	            try {
	              invocation.resolve($injector.invoke(invocable, self, values));
	              invocation.promise.then(function (result) {
	                values[key] = result;
	                done();
	              }, onfailure);
	            } catch (e) {
	              onfailure(e);
	            }
	          }
	          // Publish promise synchronously; invocations further down in the plan may depend on it.
	          promises[key] = invocation.promise;
	        }

	        return result;
	      };
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.util.$resolve#resolve
	     * @methodOf ui.router.util.$resolve
	     *
	     * @description
	     * Resolves a set of invocables. An invocable is a function to be invoked via 
	     * `$injector.invoke()`, and can have an arbitrary number of dependencies. 
	     * An invocable can either return a value directly,
	     * or a `$q` promise. If a promise is returned it will be resolved and the 
	     * resulting value will be used instead. Dependencies of invocables are resolved 
	     * (in this order of precedence)
	     *
	     * - from the specified `locals`
	     * - from another invocable that is part of this `$resolve` call
	     * - from an invocable that is inherited from a `parent` call to `$resolve` 
	     *   (or recursively
	     * - from any ancestor `$resolve` of that parent).
	     *
	     * The return value of `$resolve` is a promise for an object that contains 
	     * (in this order of precedence)
	     *
	     * - any `locals` (if specified)
	     * - the resolved return values of all injectables
	     * - any values inherited from a `parent` call to `$resolve` (if specified)
	     *
	     * The promise will resolve after the `parent` promise (if any) and all promises 
	     * returned by injectables have been resolved. If any invocable 
	     * (or `$injector.invoke`) throws an exception, or if a promise returned by an 
	     * invocable is rejected, the `$resolve` promise is immediately rejected with the 
	     * same error. A rejection of a `parent` promise (if specified) will likewise be 
	     * propagated immediately. Once the `$resolve` promise has been rejected, no 
	     * further invocables will be called.
	     * 
	     * Cyclic dependencies between invocables are not permitted and will cause `$resolve`
	     * to throw an error. As a special case, an injectable can depend on a parameter 
	     * with the same name as the injectable, which will be fulfilled from the `parent` 
	     * injectable of the same name. This allows inherited values to be decorated. 
	     * Note that in this case any other injectable in the same `$resolve` with the same
	     * dependency would see the decorated value, not the inherited value.
	     *
	     * Note that missing dependencies -- unlike cyclic dependencies -- will cause an 
	     * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) 
	     * exception.
	     *
	     * Invocables are invoked eagerly as soon as all dependencies are available. 
	     * This is true even for dependencies inherited from a `parent` call to `$resolve`.
	     *
	     * As a special case, an invocable can be a string, in which case it is taken to 
	     * be a service name to be passed to `$injector.get()`. This is supported primarily 
	     * for backwards-compatibility with the `resolve` property of `$routeProvider` 
	     * routes.
	     *
	     * @param {object} invocables functions to invoke or 
	     * `$injector` services to fetch.
	     * @param {object} locals  values to make available to the injectables
	     * @param {object} parent  a promise returned by another call to `$resolve`.
	     * @param {object} self  the `this` for the invoked methods
	     * @return {object} Promise for an object that contains the resolved return value
	     * of all invocables, as well as any inherited and local values.
	     */
	    this.resolve = function (invocables, locals, parent, self) {
	      return this.study(invocables)(locals, parent, self);
	    };
	  }

	  angular.module('ui.router.util').service('$resolve', $Resolve);

	  /**
	   * @ngdoc object
	   * @name ui.router.util.$templateFactory
	   *
	   * @requires $http
	   * @requires $templateCache
	   * @requires $injector
	   *
	   * @description
	   * Service. Manages loading of templates.
	   */
	  $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
	  function $TemplateFactory($http, $templateCache, $injector) {

	    /**
	     * @ngdoc function
	     * @name ui.router.util.$templateFactory#fromConfig
	     * @methodOf ui.router.util.$templateFactory
	     *
	     * @description
	     * Creates a template from a configuration object. 
	     *
	     * @param {object} config Configuration object for which to load a template. 
	     * The following properties are search in the specified order, and the first one 
	     * that is defined is used to create the template:
	     *
	     * @param {string|object} config.template html string template or function to 
	     * load via {@link ui.router.util.$templateFactory#fromString fromString}.
	     * @param {string|object} config.templateUrl url to load or a function returning 
	     * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.
	     * @param {Function} config.templateProvider function to invoke via 
	     * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.
	     * @param {object} params  Parameters to pass to the template function.
	     * @param {object} locals Locals to pass to `invoke` if the template is loaded 
	     * via a `templateProvider`. Defaults to `{ params: params }`.
	     *
	     * @return {string|object}  The template html as a string, or a promise for 
	     * that string,or `null` if no template is configured.
	     */
	    this.fromConfig = function (config, params, locals) {
	      return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null;
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.util.$templateFactory#fromString
	     * @methodOf ui.router.util.$templateFactory
	     *
	     * @description
	     * Creates a template from a string or a function returning a string.
	     *
	     * @param {string|object} template html template as a string or function that 
	     * returns an html template as a string.
	     * @param {object} params Parameters to pass to the template function.
	     *
	     * @return {string|object} The template html as a string, or a promise for that 
	     * string.
	     */
	    this.fromString = function (template, params) {
	      return isFunction(template) ? template(params) : template;
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.util.$templateFactory#fromUrl
	     * @methodOf ui.router.util.$templateFactory
	     * 
	     * @description
	     * Loads a template from the a URL via `$http` and `$templateCache`.
	     *
	     * @param {string|Function} url url of the template to load, or a function 
	     * that returns a url.
	     * @param {Object} params Parameters to pass to the url function.
	     * @return {string|Promise.<string>} The template html as a string, or a promise 
	     * for that string.
	     */
	    this.fromUrl = function (url, params) {
	      if (isFunction(url)) url = url(params);
	      if (url == null) return null;else return $http.get(url, { cache: $templateCache, headers: { Accept: 'text/html' } }).then(function (response) {
	        return response.data;
	      });
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.util.$templateFactory#fromProvider
	     * @methodOf ui.router.util.$templateFactory
	     *
	     * @description
	     * Creates a template by invoking an injectable provider function.
	     *
	     * @param {Function} provider Function to invoke via `$injector.invoke`
	     * @param {Object} params Parameters for the template.
	     * @param {Object} locals Locals to pass to `invoke`. Defaults to 
	     * `{ params: params }`.
	     * @return {string|Promise.<string>} The template html as a string, or a promise 
	     * for that string.
	     */
	    this.fromProvider = function (provider, params, locals) {
	      return $injector.invoke(provider, null, locals || { params: params });
	    };
	  }

	  angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);

	  var $$UMFP; // reference to $UrlMatcherFactoryProvider

	  /**
	   * @ngdoc object
	   * @name ui.router.util.type:UrlMatcher
	   *
	   * @description
	   * Matches URLs against patterns and extracts named parameters from the path or the search
	   * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list
	   * of search parameters. Multiple search parameter names are separated by '&'. Search parameters
	   * do not influence whether or not a URL is matched, but their values are passed through into
	   * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.
	   *
	   * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace
	   * syntax, which optionally allows a regular expression for the parameter to be specified:
	   *
	   * * `':'` name - colon placeholder
	   * * `'*'` name - catch-all placeholder
	   * * `'{' name '}'` - curly placeholder
	   * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the
	   *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.
	   *
	   * Parameter names may contain only word characters (latin letters, digits, and underscore) and
	   * must be unique within the pattern (across both path and search parameters). For colon
	   * placeholders or curly placeholders without an explicit regexp, a path parameter matches any
	   * number of characters other than '/'. For catch-all placeholders the path parameter matches
	   * any number of characters.
	   *
	   * Examples:
	   *
	   * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
	   *   trailing slashes, and patterns have to match the entire path, not just a prefix.
	   * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
	   *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
	   * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
	   * * `'/user/{id:[^/]*}'` - Same as the previous example.
	   * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
	   *   parameter consists of 1 to 8 hex digits.
	   * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
	   *   path into the parameter 'path'.
	   * * `'/files/*path'` - ditto.
	   * * `'/calendar/{start:date}'` - Matches "/calendar/2014-11-12" (because the pattern defined
	   *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start
	   *
	   * @param {string} pattern  The pattern to compile into a matcher.
	   * @param {Object} config  A configuration object hash:
	   * @param {Object=} parentMatcher Used to concatenate the pattern/config onto
	   *   an existing UrlMatcher
	   *
	   * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.
	   * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.
	   *
	   * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any
	   *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns
	   *   non-null) will start with this prefix.
	   *
	   * @property {string} source  The pattern that was passed into the constructor
	   *
	   * @property {string} sourcePath  The path portion of the source property
	   *
	   * @property {string} sourceSearch  The search portion of the source property
	   *
	   * @property {string} regex  The constructed regex that will be used to match against the url when
	   *   it is time to determine which url will match.
	   *
	   * @returns {Object}  New `UrlMatcher` object
	   */
	  function UrlMatcher(pattern, config, parentMatcher) {
	    config = extend({ params: {} }, isObject(config) ? config : {});

	    // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
	    //   '*' name
	    //   ':' name
	    //   '{' name '}'
	    //   '{' name ':' regexp '}'
	    // The regular expression is somewhat complicated due to the need to allow curly braces
	    // inside the regular expression. The placeholder regexp breaks down as follows:
	    //    ([:*])([\w\[\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)
	    //    \{([\w\[\]]+)(?:\:\s*( ... ))?\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case
	    //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either
	    //    [^{}\\]+                       - anything other than curly braces or backslash
	    //    \\.                            - a backslash escape
	    //    \{(?:[^{}\\]+|\\.)*\}          - a matched set of curly braces containing other atoms
	    var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
	        searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
	        compiled = '^',
	        last = 0,
	        m,
	        segments = this.segments = [],
	        parentParams = parentMatcher ? parentMatcher.params : {},
	        params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
	        paramNames = [];

	    function addParameter(id, type, config, location) {
	      paramNames.push(id);
	      if (parentParams[id]) return parentParams[id];
	      if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
	      if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
	      params[id] = new $$UMFP.Param(id, type, config, location);
	      return params[id];
	    }

	    function quoteRegExp(string, pattern, squash, optional) {
	      var surroundPattern = ['', ''],
	          result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
	      if (!pattern) return result;
	      switch (squash) {
	        case false:
	          surroundPattern = ['(', ')' + (optional ? "?" : "")];break;
	        case true:
	          result = result.replace(/\/$/, '');
	          surroundPattern = ['(?:\/(', ')|\/)?'];
	          break;
	        default:
	          surroundPattern = ['(' + squash + "|", ')?'];break;
	      }
	      return result + surroundPattern[0] + pattern + surroundPattern[1];
	    }

	    this.source = pattern;

	    // Split into static segments separated by path parameter placeholders.
	    // The number of segments is always 1 more than the number of parameters.
	    function matchDetails(m, isSearch) {
	      var id, regexp, segment, type, cfg, arrayMode;
	      id = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null
	      cfg = config.params[id];
	      segment = pattern.substring(last, m.index);
	      regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);

	      if (regexp) {
	        type = $$UMFP.type(regexp) || inherit($$UMFP.type("string"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });
	      }

	      return {
	        id: id, regexp: regexp, segment: segment, type: type, cfg: cfg
	      };
	    }

	    var p, param, segment;
	    while (m = placeholder.exec(pattern)) {
	      p = matchDetails(m, false);
	      if (p.segment.indexOf('?') >= 0) break; // we're into the search part

	      param = addParameter(p.id, p.type, p.cfg, "path");
	      compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
	      segments.push(p.segment);
	      last = placeholder.lastIndex;
	    }
	    segment = pattern.substring(last);

	    // Find any search parameter names and remove them from the last segment
	    var i = segment.indexOf('?');

	    if (i >= 0) {
	      var search = this.sourceSearch = segment.substring(i);
	      segment = segment.substring(0, i);
	      this.sourcePath = pattern.substring(0, last + i);

	      if (search.length > 0) {
	        last = 0;
	        while (m = searchPlaceholder.exec(search)) {
	          p = matchDetails(m, true);
	          param = addParameter(p.id, p.type, p.cfg, "search");
	          last = placeholder.lastIndex;
	          // check if ?&
	        }
	      }
	    } else {
	      this.sourcePath = pattern;
	      this.sourceSearch = '';
	    }

	    compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
	    segments.push(segment);

	    this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
	    this.prefix = segments[0];
	    this.$$paramNames = paramNames;
	  }

	  /**
	   * @ngdoc function
	   * @name ui.router.util.type:UrlMatcher#concat
	   * @methodOf ui.router.util.type:UrlMatcher
	   *
	   * @description
	   * Returns a new matcher for a pattern constructed by appending the path part and adding the
	   * search parameters of the specified pattern to this pattern. The current pattern is not
	   * modified. This can be understood as creating a pattern for URLs that are relative to (or
	   * suffixes of) the current pattern.
	   *
	   * @example
	   * The following two matchers are equivalent:
	   * <pre>
	   * new UrlMatcher('/user/{id}?q').concat('/details?date');
	   * new UrlMatcher('/user/{id}/details?q&date');
	   * </pre>
	   *
	   * @param {string} pattern  The pattern to append.
	   * @param {Object} config  An object hash of the configuration for the matcher.
	   * @returns {UrlMatcher}  A matcher for the concatenated pattern.
	   */
	  UrlMatcher.prototype.concat = function (pattern, config) {
	    // Because order of search parameters is irrelevant, we can add our own search
	    // parameters to the end of the new pattern. Parse the new pattern by itself
	    // and then join the bits together, but it's much easier to do this on a string level.
	    var defaultConfig = {
	      caseInsensitive: $$UMFP.caseInsensitive(),
	      strict: $$UMFP.strictMode(),
	      squash: $$UMFP.defaultSquashPolicy()
	    };
	    return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
	  };

	  UrlMatcher.prototype.toString = function () {
	    return this.source;
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.type:UrlMatcher#exec
	   * @methodOf ui.router.util.type:UrlMatcher
	   *
	   * @description
	   * Tests the specified path against this matcher, and returns an object containing the captured
	   * parameter values, or null if the path does not match. The returned object contains the values
	   * of any search parameters that are mentioned in the pattern, but their value may be null if
	   * they are not present in `searchParams`. This means that search parameters are always treated
	   * as optional.
	   *
	   * @example
	   * <pre>
	   * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
	   *   x: '1', q: 'hello'
	   * });
	   * // returns { id: 'bob', q: 'hello', r: null }
	   * </pre>
	   *
	   * @param {string} path  The URL path to match, e.g. `$location.path()`.
	   * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.
	   * @returns {Object}  The captured parameter values.
	   */
	  UrlMatcher.prototype.exec = function (path, searchParams) {
	    var m = this.regexp.exec(path);
	    if (!m) return null;
	    searchParams = searchParams || {};

	    var paramNames = this.parameters(),
	        nTotal = paramNames.length,
	        nPath = this.segments.length - 1,
	        values = {},
	        i,
	        j,
	        cfg,
	        paramName;

	    if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");

	    function decodePathArray(string) {
	      function reverseString(str) {
	        return str.split("").reverse().join("");
	      }
	      function unquoteDashes(str) {
	        return str.replace(/\\-/g, "-");
	      }

	      var split = reverseString(string).split(/-(?!\\)/);
	      var allReversed = map(split, reverseString);
	      return map(allReversed, unquoteDashes).reverse();
	    }

	    var param, paramVal;
	    for (i = 0; i < nPath; i++) {
	      paramName = paramNames[i];
	      param = this.params[paramName];
	      paramVal = m[i + 1];
	      // if the param value matches a pre-replace pair, replace the value before decoding.
	      for (j = 0; j < param.replace.length; j++) {
	        if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
	      }
	      if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);
	      if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
	      values[paramName] = param.value(paramVal);
	    }
	    for (; /**/i < nTotal; i++) {
	      paramName = paramNames[i];
	      values[paramName] = this.params[paramName].value(searchParams[paramName]);
	      param = this.params[paramName];
	      paramVal = searchParams[paramName];
	      for (j = 0; j < param.replace.length; j++) {
	        if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
	      }
	      if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
	      values[paramName] = param.value(paramVal);
	    }

	    return values;
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.type:UrlMatcher#parameters
	   * @methodOf ui.router.util.type:UrlMatcher
	   *
	   * @description
	   * Returns the names of all path and search parameters of this pattern in an unspecified order.
	   *
	   * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the
	   *    pattern has no parameters, an empty array is returned.
	   */
	  UrlMatcher.prototype.parameters = function (param) {
	    if (!isDefined(param)) return this.$$paramNames;
	    return this.params[param] || null;
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.type:UrlMatcher#validates
	   * @methodOf ui.router.util.type:UrlMatcher
	   *
	   * @description
	   * Checks an object hash of parameters to validate their correctness according to the parameter
	   * types of this `UrlMatcher`.
	   *
	   * @param {Object} params The object hash of parameters to validate.
	   * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.
	   */
	  UrlMatcher.prototype.validates = function (params) {
	    return this.params.$$validates(params);
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.type:UrlMatcher#format
	   * @methodOf ui.router.util.type:UrlMatcher
	   *
	   * @description
	   * Creates a URL that matches this pattern by substituting the specified values
	   * for the path and search parameters. Null values for path parameters are
	   * treated as empty strings.
	   *
	   * @example
	   * <pre>
	   * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
	   * // returns '/user/bob?q=yes'
	   * </pre>
	   *
	   * @param {Object} values  the values to substitute for the parameters in this pattern.
	   * @returns {string}  the formatted URL (path and optionally search part).
	   */
	  UrlMatcher.prototype.format = function (values) {
	    values = values || {};
	    var segments = this.segments,
	        params = this.parameters(),
	        paramset = this.params;
	    if (!this.validates(values)) return null;

	    var i,
	        search = false,
	        nPath = segments.length - 1,
	        nTotal = params.length,
	        result = segments[0];

	    function encodeDashes(str) {
	      // Replace dashes with encoded "\-"
	      return encodeURIComponent(str).replace(/-/g, function (c) {
	        return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
	      });
	    }

	    for (i = 0; i < nTotal; i++) {
	      var isPathParam = i < nPath;
	      var name = params[i],
	          param = paramset[name],
	          value = param.value(values[name]);
	      var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
	      var squash = isDefaultValue ? param.squash : false;
	      var encoded = param.type.encode(value);

	      if (isPathParam) {
	        var nextSegment = segments[i + 1];
	        var isFinalPathParam = i + 1 === nPath;

	        if (squash === false) {
	          if (encoded != null) {
	            if (isArray(encoded)) {
	              result += map(encoded, encodeDashes).join("-");
	            } else {
	              result += encodeURIComponent(encoded);
	            }
	          }
	          result += nextSegment;
	        } else if (squash === true) {
	          var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
	          result += nextSegment.match(capture)[1];
	        } else if (isString(squash)) {
	          result += squash + nextSegment;
	        }

	        if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);
	      } else {
	        if (encoded == null || isDefaultValue && squash !== false) continue;
	        if (!isArray(encoded)) encoded = [encoded];
	        if (encoded.length === 0) continue;
	        encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
	        result += (search ? '&' : '?') + (name + '=' + encoded);
	        search = true;
	      }
	    }

	    return result;
	  };

	  /**
	   * @ngdoc object
	   * @name ui.router.util.type:Type
	   *
	   * @description
	   * Implements an interface to define custom parameter types that can be decoded from and encoded to
	   * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}
	   * objects when matching or formatting URLs, or comparing or validating parameter values.
	   *
	   * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more
	   * information on registering custom types.
	   *
	   * @param {Object} config  A configuration object which contains the custom type definition.  The object's
	   *        properties will override the default methods and/or pattern in `Type`'s public interface.
	   * @example
	   * <pre>
	   * {
	   *   decode: function(val) { return parseInt(val, 10); },
	   *   encode: function(val) { return val && val.toString(); },
	   *   equals: function(a, b) { return this.is(a) && a === b; },
	   *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },
	   *   pattern: /\d+/
	   * }
	   * </pre>
	   *
	   * @property {RegExp} pattern The regular expression pattern used to match values of this type when
	   *           coming from a substring of a URL.
	   *
	   * @returns {Object}  Returns a new `Type` object.
	   */
	  function Type(config) {
	    extend(this, config);
	  }

	  /**
	   * @ngdoc function
	   * @name ui.router.util.type:Type#is
	   * @methodOf ui.router.util.type:Type
	   *
	   * @description
	   * Detects whether a value is of a particular type. Accepts a native (decoded) value
	   * and determines whether it matches the current `Type` object.
	   *
	   * @param {*} val  The value to check.
	   * @param {string} key  Optional. If the type check is happening in the context of a specific
	   *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the
	   *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.
	   * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.
	   */
	  Type.prototype.is = function (val, key) {
	    return true;
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.type:Type#encode
	   * @methodOf ui.router.util.type:Type
	   *
	   * @description
	   * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the
	   * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it
	   * only needs to be a representation of `val` that has been coerced to a string.
	   *
	   * @param {*} val  The value to encode.
	   * @param {string} key  The name of the parameter in which `val` is stored. Can be used for
	   *        meta-programming of `Type` objects.
	   * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.
	   */
	  Type.prototype.encode = function (val, key) {
	    return val;
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.type:Type#decode
	   * @methodOf ui.router.util.type:Type
	   *
	   * @description
	   * Converts a parameter value (from URL string or transition param) to a custom/native value.
	   *
	   * @param {string} val  The URL parameter value to decode.
	   * @param {string} key  The name of the parameter in which `val` is stored. Can be used for
	   *        meta-programming of `Type` objects.
	   * @returns {*}  Returns a custom representation of the URL parameter value.
	   */
	  Type.prototype.decode = function (val, key) {
	    return val;
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.type:Type#equals
	   * @methodOf ui.router.util.type:Type
	   *
	   * @description
	   * Determines whether two decoded values are equivalent.
	   *
	   * @param {*} a  A value to compare against.
	   * @param {*} b  A value to compare against.
	   * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.
	   */
	  Type.prototype.equals = function (a, b) {
	    return a == b;
	  };

	  Type.prototype.$subPattern = function () {
	    var sub = this.pattern.toString();
	    return sub.substr(1, sub.length - 2);
	  };

	  Type.prototype.pattern = /.*/;

	  Type.prototype.toString = function () {
	    return "{Type:" + this.name + "}";
	  };

	  /** Given an encoded string, or a decoded object, returns a decoded object */
	  Type.prototype.$normalize = function (val) {
	    return this.is(val) ? val : this.decode(val);
	  };

	  /*
	   * Wraps an existing custom Type as an array of Type, depending on 'mode'.
	   * e.g.:
	   * - urlmatcher pattern "/path?{queryParam[]:int}"
	   * - url: "/path?queryParam=1&queryParam=2
	   * - $stateParams.queryParam will be [1, 2]
	   * if `mode` is "auto", then
	   * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
	   * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
	   */
	  Type.prototype.$asArray = function (mode, isSearch) {
	    if (!mode) return this;
	    if (mode === "auto" && !isSearch) throw new Error("'auto' array mode is for query parameters only");

	    function ArrayType(type, mode) {
	      function bindTo(type, callbackName) {
	        return function () {
	          return type[callbackName].apply(type, arguments);
	        };
	      }

	      // Wrap non-array value as array
	      function arrayWrap(val) {
	        return isArray(val) ? val : isDefined(val) ? [val] : [];
	      }
	      // Unwrap array value for "auto" mode. Return undefined for empty array.
	      function arrayUnwrap(val) {
	        switch (val.length) {
	          case 0:
	            return undefined;
	          case 1:
	            return mode === "auto" ? val[0] : val;
	          default:
	            return val;
	        }
	      }
	      function falsey(val) {
	        return !val;
	      }

	      // Wraps type (.is/.encode/.decode) functions to operate on each value of an array
	      function arrayHandler(callback, allTruthyMode) {
	        return function handleArray(val) {
	          if (isArray(val) && val.length === 0) return val;
	          val = arrayWrap(val);
	          var result = map(val, callback);
	          if (allTruthyMode === true) return filter(result, falsey).length === 0;
	          return arrayUnwrap(result);
	        };
	      }

	      // Wraps type (.equals) functions to operate on each value of an array
	      function arrayEqualsHandler(callback) {
	        return function handleArray(val1, val2) {
	          var left = arrayWrap(val1),
	              right = arrayWrap(val2);
	          if (left.length !== right.length) return false;
	          for (var i = 0; i < left.length; i++) {
	            if (!callback(left[i], right[i])) return false;
	          }
	          return true;
	        };
	      }

	      this.encode = arrayHandler(bindTo(type, 'encode'));
	      this.decode = arrayHandler(bindTo(type, 'decode'));
	      this.is = arrayHandler(bindTo(type, 'is'), true);
	      this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
	      this.pattern = type.pattern;
	      this.$normalize = arrayHandler(bindTo(type, '$normalize'));
	      this.name = type.name;
	      this.$arrayMode = mode;
	    }

	    return new ArrayType(this, mode);
	  };

	  /**
	   * @ngdoc object
	   * @name ui.router.util.$urlMatcherFactory
	   *
	   * @description
	   * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory
	   * is also available to providers under the name `$urlMatcherFactoryProvider`.
	   */
	  function $UrlMatcherFactory() {
	    $$UMFP = this;

	    var isCaseInsensitive = false,
	        isStrictMode = true,
	        defaultSquashPolicy = false;

	    // Use tildes to pre-encode slashes.
	    // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,
	    // and bidirectional encoding/decoding fails.
	    // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character
	    function valToString(val) {
	      return val != null ? val.toString().replace(/(~|\/)/g, function (m) {
	        return { '~': '~~', '/': '~2F' }[m];
	      }) : val;
	    }
	    function valFromString(val) {
	      return val != null ? val.toString().replace(/(~~|~2F)/g, function (m) {
	        return { '~~': '~', '~2F': '/' }[m];
	      }) : val;
	    }

	    var $types = {},
	        enqueue = true,
	        typeQueue = [],
	        injector,
	        defaultTypes = {
	      "string": {
	        encode: valToString,
	        decode: valFromString,
	        // TODO: in 1.0, make string .is() return false if value is undefined/null by default.
	        // In 0.2.x, string params are optional by default for backwards compat
	        is: function is(val) {
	          return val == null || !isDefined(val) || typeof val === "string";
	        },
	        pattern: /[^/]*/
	      },
	      "int": {
	        encode: valToString,
	        decode: function decode(val) {
	          return parseInt(val, 10);
	        },
	        is: function is(val) {
	          return isDefined(val) && this.decode(val.toString()) === val;
	        },
	        pattern: /\d+/
	      },
	      "bool": {
	        encode: function encode(val) {
	          return val ? 1 : 0;
	        },
	        decode: function decode(val) {
	          return parseInt(val, 10) !== 0;
	        },
	        is: function is(val) {
	          return val === true || val === false;
	        },
	        pattern: /0|1/
	      },
	      "date": {
	        encode: function encode(val) {
	          if (!this.is(val)) return undefined;
	          return [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join("-");
	        },
	        decode: function decode(val) {
	          if (this.is(val)) return val;
	          var match = this.capture.exec(val);
	          return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
	        },
	        is: function is(val) {
	          return val instanceof Date && !isNaN(val.valueOf());
	        },
	        equals: function equals(a, b) {
	          return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
	        },
	        pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
	        capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
	      },
	      "json": {
	        encode: angular.toJson,
	        decode: angular.fromJson,
	        is: angular.isObject,
	        equals: angular.equals,
	        pattern: /[^/]*/
	      },
	      "any": { // does not encode/decode
	        encode: angular.identity,
	        decode: angular.identity,
	        equals: angular.equals,
	        pattern: /.*/
	      }
	    };

	    function getDefaultConfig() {
	      return {
	        strict: isStrictMode,
	        caseInsensitive: isCaseInsensitive
	      };
	    }

	    function isInjectable(value) {
	      return isFunction(value) || isArray(value) && isFunction(value[value.length - 1]);
	    }

	    /**
	     * [Internal] Get the default value of a parameter, which may be an injectable function.
	     */
	    $UrlMatcherFactory.$$getDefaultValue = function (config) {
	      if (!isInjectable(config.value)) return config.value;
	      if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
	      return injector.invoke(config.value);
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.util.$urlMatcherFactory#caseInsensitive
	     * @methodOf ui.router.util.$urlMatcherFactory
	     *
	     * @description
	     * Defines whether URL matching should be case sensitive (the default behavior), or not.
	     *
	     * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;
	     * @returns {boolean} the current value of caseInsensitive
	     */
	    this.caseInsensitive = function (value) {
	      if (isDefined(value)) isCaseInsensitive = value;
	      return isCaseInsensitive;
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.util.$urlMatcherFactory#strictMode
	     * @methodOf ui.router.util.$urlMatcherFactory
	     *
	     * @description
	     * Defines whether URLs should match trailing slashes, or not (the default behavior).
	     *
	     * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.
	     * @returns {boolean} the current value of strictMode
	     */
	    this.strictMode = function (value) {
	      if (isDefined(value)) isStrictMode = value;
	      return isStrictMode;
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy
	     * @methodOf ui.router.util.$urlMatcherFactory
	     *
	     * @description
	     * Sets the default behavior when generating or matching URLs with default parameter values.
	     *
	     * @param {string} value A string that defines the default parameter URL squashing behavior.
	     *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL
	     *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the
	     *             parameter is surrounded by slashes, squash (remove) one slash from the URL
	     *    any other string, e.g. "~": When generating an href with a default parameter value, squash (remove)
	     *             the parameter value from the URL and replace it with this string.
	     */
	    this.defaultSquashPolicy = function (value) {
	      if (!isDefined(value)) return defaultSquashPolicy;
	      if (value !== true && value !== false && !isString(value)) throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
	      defaultSquashPolicy = value;
	      return value;
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.util.$urlMatcherFactory#compile
	     * @methodOf ui.router.util.$urlMatcherFactory
	     *
	     * @description
	     * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.
	     *
	     * @param {string} pattern  The URL pattern.
	     * @param {Object} config  The config object hash.
	     * @returns {UrlMatcher}  The UrlMatcher.
	     */
	    this.compile = function (pattern, config) {
	      return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.util.$urlMatcherFactory#isMatcher
	     * @methodOf ui.router.util.$urlMatcherFactory
	     *
	     * @description
	     * Returns true if the specified object is a `UrlMatcher`, or false otherwise.
	     *
	     * @param {Object} object  The object to perform the type check against.
	     * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by
	     *          implementing all the same methods.
	     */
	    this.isMatcher = function (o) {
	      if (!isObject(o)) return false;
	      var result = true;

	      forEach(UrlMatcher.prototype, function (val, name) {
	        if (isFunction(val)) {
	          result = result && isDefined(o[name]) && isFunction(o[name]);
	        }
	      });
	      return result;
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.util.$urlMatcherFactory#type
	     * @methodOf ui.router.util.$urlMatcherFactory
	     *
	     * @description
	     * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to
	     * generate URLs with typed parameters.
	     *
	     * @param {string} name  The type name.
	     * @param {Object|Function} definition   The type definition. See
	     *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.
	     * @param {Object|Function} definitionFn (optional) A function that is injected before the app
	     *        runtime starts.  The result of this function is merged into the existing `definition`.
	     *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.
	     *
	     * @returns {Object}  Returns `$urlMatcherFactoryProvider`.
	     *
	     * @example
	     * This is a simple example of a custom type that encodes and decodes items from an
	     * array, using the array index as the URL-encoded value:
	     *
	     * <pre>
	     * var list = ['John', 'Paul', 'George', 'Ringo'];
	     *
	     * $urlMatcherFactoryProvider.type('listItem', {
	     *   encode: function(item) {
	     *     // Represent the list item in the URL using its corresponding index
	     *     return list.indexOf(item);
	     *   },
	     *   decode: function(item) {
	     *     // Look up the list item by index
	     *     return list[parseInt(item, 10)];
	     *   },
	     *   is: function(item) {
	     *     // Ensure the item is valid by checking to see that it appears
	     *     // in the list
	     *     return list.indexOf(item) > -1;
	     *   }
	     * });
	     *
	     * $stateProvider.state('list', {
	     *   url: "/list/{item:listItem}",
	     *   controller: function($scope, $stateParams) {
	     *     console.log($stateParams.item);
	     *   }
	     * });
	     *
	     * // ...
	     *
	     * // Changes URL to '/list/3', logs "Ringo" to the console
	     * $state.go('list', { item: "Ringo" });
	     * </pre>
	     *
	     * This is a more complex example of a type that relies on dependency injection to
	     * interact with services, and uses the parameter name from the URL to infer how to
	     * handle encoding and decoding parameter values:
	     *
	     * <pre>
	     * // Defines a custom type that gets a value from a service,
	     * // where each service gets different types of values from
	     * // a backend API:
	     * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {
	     *
	     *   // Matches up services to URL parameter names
	     *   var services = {
	     *     user: Users,
	     *     post: Posts
	     *   };
	     *
	     *   return {
	     *     encode: function(object) {
	     *       // Represent the object in the URL using its unique ID
	     *       return object.id;
	     *     },
	     *     decode: function(value, key) {
	     *       // Look up the object by ID, using the parameter
	     *       // name (key) to call the correct service
	     *       return services[key].findById(value);
	     *     },
	     *     is: function(object, key) {
	     *       // Check that object is a valid dbObject
	     *       return angular.isObject(object) && object.id && services[key];
	     *     }
	     *     equals: function(a, b) {
	     *       // Check the equality of decoded objects by comparing
	     *       // their unique IDs
	     *       return a.id === b.id;
	     *     }
	     *   };
	     * });
	     *
	     * // In a config() block, you can then attach URLs with
	     * // type-annotated parameters:
	     * $stateProvider.state('users', {
	     *   url: "/users",
	     *   // ...
	     * }).state('users.item', {
	     *   url: "/{user:dbObject}",
	     *   controller: function($scope, $stateParams) {
	     *     // $stateParams.user will now be an object returned from
	     *     // the Users service
	     *   },
	     *   // ...
	     * });
	     * </pre>
	     */
	    this.type = function (name, definition, definitionFn) {
	      if (!isDefined(definition)) return $types[name];
	      if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");

	      $types[name] = new Type(extend({ name: name }, definition));
	      if (definitionFn) {
	        typeQueue.push({ name: name, def: definitionFn });
	        if (!enqueue) flushTypeQueue();
	      }
	      return this;
	    };

	    // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s
	    function flushTypeQueue() {
	      while (typeQueue.length) {
	        var type = typeQueue.shift();
	        if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
	        angular.extend($types[type.name], injector.invoke(type.def));
	      }
	    }

	    // Register default types. Store them in the prototype of $types.
	    forEach(defaultTypes, function (type, name) {
	      $types[name] = new Type(extend({ name: name }, type));
	    });
	    $types = inherit($types, {});

	    /* No need to document $get, since it returns this */
	    this.$get = ['$injector', function ($injector) {
	      injector = $injector;
	      enqueue = false;
	      flushTypeQueue();

	      forEach(defaultTypes, function (type, name) {
	        if (!$types[name]) $types[name] = new Type(type);
	      });
	      return this;
	    }];

	    this.Param = function Param(id, type, config, location) {
	      var self = this;
	      config = unwrapShorthand(config);
	      type = getType(config, type, location);
	      var arrayMode = getArrayMode();
	      type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
	      if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined) config.value = ""; // for 0.2.x; in 0.3.0+ do not automatically default to ""
	      var isOptional = config.value !== undefined;
	      var squash = getSquashPolicy(config, isOptional);
	      var replace = getReplace(config, arrayMode, isOptional, squash);

	      function unwrapShorthand(config) {
	        var keys = isObject(config) ? objectKeys(config) : [];
	        var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
	        if (isShorthand) config = { value: config };
	        config.$$fn = isInjectable(config.value) ? config.value : function () {
	          return config.value;
	        };
	        return config;
	      }

	      function getType(config, urlType, location) {
	        if (config.type && urlType) throw new Error("Param '" + id + "' has two type configurations.");
	        if (urlType) return urlType;
	        if (!config.type) return location === "config" ? $types.any : $types.string;

	        if (angular.isString(config.type)) return $types[config.type];
	        if (config.type instanceof Type) return config.type;
	        return new Type(config.type);
	      }

	      // array config: param name (param[]) overrides default settings.  explicit config overrides param name.
	      function getArrayMode() {
	        var arrayDefaults = { array: location === "search" ? "auto" : false };
	        var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
	        return extend(arrayDefaults, arrayParamNomenclature, config).array;
	      }

	      /**
	       * returns false, true, or the squash value to indicate the "default parameter url squash policy".
	       */
	      function getSquashPolicy(config, isOptional) {
	        var squash = config.squash;
	        if (!isOptional || squash === false) return false;
	        if (!isDefined(squash) || squash == null) return defaultSquashPolicy;
	        if (squash === true || isString(squash)) return squash;
	        throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
	      }

	      function getReplace(config, arrayMode, isOptional, squash) {
	        var replace,
	            configuredKeys,
	            defaultPolicy = [{ from: "", to: isOptional || arrayMode ? undefined : "" }, { from: null, to: isOptional || arrayMode ? undefined : "" }];
	        replace = isArray(config.replace) ? config.replace : [];
	        if (isString(squash)) replace.push({ from: squash, to: undefined });
	        configuredKeys = map(replace, function (item) {
	          return item.from;
	        });
	        return filter(defaultPolicy, function (item) {
	          return indexOf(configuredKeys, item.from) === -1;
	        }).concat(replace);
	      }

	      /**
	       * [Internal] Get the default value of a parameter, which may be an injectable function.
	       */
	      function $$getDefaultValue() {
	        if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
	        var defaultValue = injector.invoke(config.$$fn);
	        if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue)) throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
	        return defaultValue;
	      }

	      /**
	       * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
	       * default value, which may be the result of an injectable function.
	       */
	      function $value(value) {
	        function hasReplaceVal(val) {
	          return function (obj) {
	            return obj.from === val;
	          };
	        }
	        function $replace(value) {
	          var replacement = map(filter(self.replace, hasReplaceVal(value)), function (obj) {
	            return obj.to;
	          });
	          return replacement.length ? replacement[0] : value;
	        }
	        value = $replace(value);
	        return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
	      }

	      function toString() {
	        return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
	      }

	      extend(this, {
	        id: id,
	        type: type,
	        location: location,
	        array: arrayMode,
	        squash: squash,
	        replace: replace,
	        isOptional: isOptional,
	        value: $value,
	        dynamic: undefined,
	        config: config,
	        toString: toString
	      });
	    };

	    function ParamSet(params) {
	      extend(this, params || {});
	    }

	    ParamSet.prototype = {
	      $$new: function $$new() {
	        return inherit(this, extend(new ParamSet(), { $$parent: this }));
	      },
	      $$keys: function $$keys() {
	        var keys = [],
	            chain = [],
	            parent = this,
	            ignore = objectKeys(ParamSet.prototype);
	        while (parent) {
	          chain.push(parent);parent = parent.$$parent;
	        }
	        chain.reverse();
	        forEach(chain, function (paramset) {
	          forEach(objectKeys(paramset), function (key) {
	            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);
	          });
	        });
	        return keys;
	      },
	      $$values: function $$values(paramValues) {
	        var values = {},
	            self = this;
	        forEach(self.$$keys(), function (key) {
	          values[key] = self[key].value(paramValues && paramValues[key]);
	        });
	        return values;
	      },
	      $$equals: function $$equals(paramValues1, paramValues2) {
	        var equal = true,
	            self = this;
	        forEach(self.$$keys(), function (key) {
	          var left = paramValues1 && paramValues1[key],
	              right = paramValues2 && paramValues2[key];
	          if (!self[key].type.equals(left, right)) equal = false;
	        });
	        return equal;
	      },
	      $$validates: function $$validate(paramValues) {
	        var keys = this.$$keys(),
	            i,
	            param,
	            rawVal,
	            normalized,
	            encoded;
	        for (i = 0; i < keys.length; i++) {
	          param = this[keys[i]];
	          rawVal = paramValues[keys[i]];
	          if ((rawVal === undefined || rawVal === null) && param.isOptional) break; // There was no parameter value, but the param is optional
	          normalized = param.type.$normalize(rawVal);
	          if (!param.type.is(normalized)) return false; // The value was not of the correct Type, and could not be decoded to the correct Type
	          encoded = param.type.encode(normalized);
	          if (angular.isString(encoded) && !param.type.pattern.exec(encoded)) return false; // The value was of the correct type, but when encoded, did not match the Type's regexp
	        }
	        return true;
	      },
	      $$parent: undefined
	    };

	    this.ParamSet = ParamSet;
	  }

	  // Register as a provider so it's available to other providers
	  angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
	  angular.module('ui.router.util').run(['$urlMatcherFactory', function ($urlMatcherFactory) {}]);

	  /**
	   * @ngdoc object
	   * @name ui.router.router.$urlRouterProvider
	   *
	   * @requires ui.router.util.$urlMatcherFactoryProvider
	   * @requires $locationProvider
	   *
	   * @description
	   * `$urlRouterProvider` has the responsibility of watching `$location`. 
	   * When `$location` changes it runs through a list of rules one by one until a 
	   * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify 
	   * a url in a state configuration. All urls are compiled into a UrlMatcher object.
	   *
	   * There are several methods on `$urlRouterProvider` that make it useful to use directly
	   * in your module config.
	   */
	  $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
	  function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
	    var rules = [],
	        otherwise = null,
	        interceptDeferred = false,
	        listener;

	    // Returns a string that is a prefix of all strings matching the RegExp
	    function regExpPrefix(re) {
	      var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
	      return prefix != null ? prefix[1].replace(/\\(.)/g, "$1") : '';
	    }

	    // Interpolates matched values into a String.replace()-style pattern
	    function interpolate(pattern, match) {
	      return pattern.replace(/\$(\$|\d{1,2})/, function (m, what) {
	        return match[what === '$' ? 0 : Number(what)];
	      });
	    }

	    /**
	     * @ngdoc function
	     * @name ui.router.router.$urlRouterProvider#rule
	     * @methodOf ui.router.router.$urlRouterProvider
	     *
	     * @description
	     * Defines rules that are used by `$urlRouterProvider` to find matches for
	     * specific URLs.
	     *
	     * @example
	     * <pre>
	     * var app = angular.module('app', ['ui.router.router']);
	     *
	     * app.config(function ($urlRouterProvider) {
	     *   // Here's an example of how you might allow case insensitive urls
	     *   $urlRouterProvider.rule(function ($injector, $location) {
	     *     var path = $location.path(),
	     *         normalized = path.toLowerCase();
	     *
	     *     if (path !== normalized) {
	     *       return normalized;
	     *     }
	     *   });
	     * });
	     * </pre>
	     *
	     * @param {function} rule Handler function that takes `$injector` and `$location`
	     * services as arguments. You can use them to return a valid path as a string.
	     *
	     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
	     */
	    this.rule = function (rule) {
	      if (!isFunction(rule)) throw new Error("'rule' must be a function");
	      rules.push(rule);
	      return this;
	    };

	    /**
	     * @ngdoc object
	     * @name ui.router.router.$urlRouterProvider#otherwise
	     * @methodOf ui.router.router.$urlRouterProvider
	     *
	     * @description
	     * Defines a path that is used when an invalid route is requested.
	     *
	     * @example
	     * <pre>
	     * var app = angular.module('app', ['ui.router.router']);
	     *
	     * app.config(function ($urlRouterProvider) {
	     *   // if the path doesn't match any of the urls you configured
	     *   // otherwise will take care of routing the user to the
	     *   // specified url
	     *   $urlRouterProvider.otherwise('/index');
	     *
	     *   // Example of using function rule as param
	     *   $urlRouterProvider.otherwise(function ($injector, $location) {
	     *     return '/a/valid/url';
	     *   });
	     * });
	     * </pre>
	     *
	     * @param {string|function} rule The url path you want to redirect to or a function 
	     * rule that returns the url path. The function version is passed two params: 
	     * `$injector` and `$location` services, and must return a url string.
	     *
	     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
	     */
	    this.otherwise = function (rule) {
	      if (isString(rule)) {
	        var redirect = rule;
	        rule = function rule() {
	          return redirect;
	        };
	      } else if (!isFunction(rule)) throw new Error("'rule' must be a function");
	      otherwise = rule;
	      return this;
	    };

	    function handleIfMatch($injector, handler, match) {
	      if (!match) return false;
	      var result = $injector.invoke(handler, handler, { $match: match });
	      return isDefined(result) ? result : true;
	    }

	    /**
	     * @ngdoc function
	     * @name ui.router.router.$urlRouterProvider#when
	     * @methodOf ui.router.router.$urlRouterProvider
	     *
	     * @description
	     * Registers a handler for a given url matching. 
	     * 
	     * If the handler is a string, it is
	     * treated as a redirect, and is interpolated according to the syntax of match
	     * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).
	     *
	     * If the handler is a function, it is injectable. It gets invoked if `$location`
	     * matches. You have the option of inject the match object as `$match`.
	     *
	     * The handler can return
	     *
	     * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`
	     *   will continue trying to find another one that matches.
	     * - **string** which is treated as a redirect and passed to `$location.url()`
	     * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.
	     *
	     * @example
	     * <pre>
	     * var app = angular.module('app', ['ui.router.router']);
	     *
	     * app.config(function ($urlRouterProvider) {
	     *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {
	     *     if ($state.$current.navigable !== state ||
	     *         !equalForKeys($match, $stateParams) {
	     *      $state.transitionTo(state, $match, false);
	     *     }
	     *   });
	     * });
	     * </pre>
	     *
	     * @param {string|object} what The incoming path that you want to redirect.
	     * @param {string|function} handler The path you want to redirect your user to.
	     */
	    this.when = function (what, handler) {
	      var redirect,
	          handlerIsString = isString(handler);
	      if (isString(what)) what = $urlMatcherFactory.compile(what);

	      if (!handlerIsString && !isFunction(handler) && !isArray(handler)) throw new Error("invalid 'handler' in when()");

	      var strategies = {
	        matcher: function matcher(what, handler) {
	          if (handlerIsString) {
	            redirect = $urlMatcherFactory.compile(handler);
	            handler = ['$match', function ($match) {
	              return redirect.format($match);
	            }];
	          }
	          return extend(function ($injector, $location) {
	            return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
	          }, {
	            prefix: isString(what.prefix) ? what.prefix : ''
	          });
	        },
	        regex: function regex(what, handler) {
	          if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");

	          if (handlerIsString) {
	            redirect = handler;
	            handler = ['$match', function ($match) {
	              return interpolate(redirect, $match);
	            }];
	          }
	          return extend(function ($injector, $location) {
	            return handleIfMatch($injector, handler, what.exec($location.path()));
	          }, {
	            prefix: regExpPrefix(what)
	          });
	        }
	      };

	      var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };

	      for (var n in check) {
	        if (check[n]) return this.rule(strategies[n](what, handler));
	      }

	      throw new Error("invalid 'what' in when()");
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.router.$urlRouterProvider#deferIntercept
	     * @methodOf ui.router.router.$urlRouterProvider
	     *
	     * @description
	     * Disables (or enables) deferring location change interception.
	     *
	     * If you wish to customize the behavior of syncing the URL (for example, if you wish to
	     * defer a transition but maintain the current URL), call this method at configuration time.
	     * Then, at run time, call `$urlRouter.listen()` after you have configured your own
	     * `$locationChangeSuccess` event handler.
	     *
	     * @example
	     * <pre>
	     * var app = angular.module('app', ['ui.router.router']);
	     *
	     * app.config(function ($urlRouterProvider) {
	     *
	     *   // Prevent $urlRouter from automatically intercepting URL changes;
	     *   // this allows you to configure custom behavior in between
	     *   // location changes and route synchronization:
	     *   $urlRouterProvider.deferIntercept();
	     *
	     * }).run(function ($rootScope, $urlRouter, UserService) {
	     *
	     *   $rootScope.$on('$locationChangeSuccess', function(e) {
	     *     // UserService is an example service for managing user state
	     *     if (UserService.isLoggedIn()) return;
	     *
	     *     // Prevent $urlRouter's default handler from firing
	     *     e.preventDefault();
	     *
	     *     UserService.handleLogin().then(function() {
	     *       // Once the user has logged in, sync the current URL
	     *       // to the router:
	     *       $urlRouter.sync();
	     *     });
	     *   });
	     *
	     *   // Configures $urlRouter's listener *after* your custom listener
	     *   $urlRouter.listen();
	     * });
	     * </pre>
	     *
	     * @param {boolean} defer Indicates whether to defer location change interception. Passing
	              no parameter is equivalent to `true`.
	     */
	    this.deferIntercept = function (defer) {
	      if (defer === undefined) defer = true;
	      interceptDeferred = defer;
	    };

	    /**
	     * @ngdoc object
	     * @name ui.router.router.$urlRouter
	     *
	     * @requires $location
	     * @requires $rootScope
	     * @requires $injector
	     * @requires $browser
	     *
	     * @description
	     *
	     */
	    this.$get = $get;
	    $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];
	    function $get($location, $rootScope, $injector, $browser, $sniffer) {

	      var baseHref = $browser.baseHref(),
	          location = $location.url(),
	          lastPushedUrl;

	      function appendBasePath(url, isHtml5, absolute) {
	        if (baseHref === '/') return url;
	        if (isHtml5) return baseHref.slice(0, -1) + url;
	        if (absolute) return baseHref.slice(1) + url;
	        return url;
	      }

	      // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree
	      function update(evt) {
	        if (evt && evt.defaultPrevented) return;
	        var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
	        lastPushedUrl = undefined;
	        // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573
	        //if (ignoreUpdate) return true;

	        function check(rule) {
	          var handled = rule($injector, $location);

	          if (!handled) return false;
	          if (isString(handled)) $location.replace().url(handled);
	          return true;
	        }
	        var n = rules.length,
	            i;

	        for (i = 0; i < n; i++) {
	          if (check(rules[i])) return;
	        }
	        // always check otherwise last to allow dynamic updates to the set of rules
	        if (otherwise) check(otherwise);
	      }

	      function _listen() {
	        listener = listener || $rootScope.$on('$locationChangeSuccess', update);
	        return listener;
	      }

	      if (!interceptDeferred) _listen();

	      return {
	        /**
	         * @ngdoc function
	         * @name ui.router.router.$urlRouter#sync
	         * @methodOf ui.router.router.$urlRouter
	         *
	         * @description
	         * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.
	         * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,
	         * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed
	         * with the transition by calling `$urlRouter.sync()`.
	         *
	         * @example
	         * <pre>
	         * angular.module('app', ['ui.router'])
	         *   .run(function($rootScope, $urlRouter) {
	         *     $rootScope.$on('$locationChangeSuccess', function(evt) {
	         *       // Halt state change from even starting
	         *       evt.preventDefault();
	         *       // Perform custom logic
	         *       var meetsRequirement = ...
	         *       // Continue with the update and state transition if logic allows
	         *       if (meetsRequirement) $urlRouter.sync();
	         *     });
	         * });
	         * </pre>
	         */
	        sync: function sync() {
	          update();
	        },

	        listen: function listen() {
	          return _listen();
	        },

	        update: function update(read) {
	          if (read) {
	            location = $location.url();
	            return;
	          }
	          if ($location.url() === location) return;

	          $location.url(location);
	          $location.replace();
	        },

	        push: function push(urlMatcher, params, options) {
	          var url = urlMatcher.format(params || {});

	          // Handle the special hash param, if needed
	          if (url !== null && params && params['#']) {
	            url += '#' + params['#'];
	          }

	          $location.url(url);
	          lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
	          if (options && options.replace) $location.replace();
	        },

	        /**
	         * @ngdoc function
	         * @name ui.router.router.$urlRouter#href
	         * @methodOf ui.router.router.$urlRouter
	         *
	         * @description
	         * A URL generation method that returns the compiled URL for a given
	         * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.
	         *
	         * @example
	         * <pre>
	         * $bob = $urlRouter.href(new UrlMatcher("/about/:person"), {
	         *   person: "bob"
	         * });
	         * // $bob == "/about/bob";
	         * </pre>
	         *
	         * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.
	         * @param {object=} params An object of parameter values to fill the matcher's required parameters.
	         * @param {object=} options Options object. The options are:
	         *
	         * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
	         *
	         * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
	         */
	        href: function href(urlMatcher, params, options) {
	          if (!urlMatcher.validates(params)) return null;

	          var isHtml5 = $locationProvider.html5Mode();
	          if (angular.isObject(isHtml5)) {
	            isHtml5 = isHtml5.enabled;
	          }

	          isHtml5 = isHtml5 && $sniffer.history;

	          var url = urlMatcher.format(params);
	          options = options || {};

	          if (!isHtml5 && url !== null) {
	            url = "#" + $locationProvider.hashPrefix() + url;
	          }

	          // Handle special hash param, if needed
	          if (url !== null && params && params['#']) {
	            url += '#' + params['#'];
	          }

	          url = appendBasePath(url, isHtml5, options.absolute);

	          if (!options.absolute || !url) {
	            return url;
	          }

	          var slash = !isHtml5 && url ? '/' : '',
	              port = $location.port();
	          port = port === 80 || port === 443 ? '' : ':' + port;

	          return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
	        }
	      };
	    }
	  }

	  angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);

	  /**
	   * @ngdoc object
	   * @name ui.router.state.$stateProvider
	   *
	   * @requires ui.router.router.$urlRouterProvider
	   * @requires ui.router.util.$urlMatcherFactoryProvider
	   *
	   * @description
	   * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely
	   * on state.
	   *
	   * A state corresponds to a "place" in the application in terms of the overall UI and
	   * navigation. A state describes (via the controller / template / view properties) what
	   * the UI looks like and does at that place.
	   *
	   * States often have things in common, and the primary way of factoring out these
	   * commonalities in this model is via the state hierarchy, i.e. parent/child states aka
	   * nested states.
	   *
	   * The `$stateProvider` provides interfaces to declare these states for your app.
	   */
	  $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
	  function $StateProvider($urlRouterProvider, $urlMatcherFactory) {

	    var root,
	        states = {},
	        $state,
	        queue = {},
	        abstractKey = 'abstract';

	    // Builds state properties from definition passed to registerState()
	    var stateBuilder = {

	      // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.
	      // state.children = [];
	      // if (parent) parent.children.push(state);
	      parent: function parent(state) {
	        if (isDefined(state.parent) && state.parent) return findState(state.parent);
	        // regex matches any valid composite state name
	        // would match "contact.list" but not "contacts"
	        var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
	        return compositeName ? findState(compositeName[1]) : root;
	      },

	      // inherit 'data' from parent and override by own values (if any)
	      data: function data(state) {
	        if (state.parent && state.parent.data) {
	          state.data = state.self.data = inherit(state.parent.data, state.data);
	        }
	        return state.data;
	      },

	      // Build a URLMatcher if necessary, either via a relative or absolute URL
	      url: function url(state) {
	        var url = state.url,
	            config = { params: state.params || {} };

	        if (isString(url)) {
	          if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);
	          return (state.parent.navigable || root).url.concat(url, config);
	        }

	        if (!url || $urlMatcherFactory.isMatcher(url)) return url;
	        throw new Error("Invalid url '" + url + "' in state '" + state + "'");
	      },

	      // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
	      navigable: function navigable(state) {
	        return state.url ? state : state.parent ? state.parent.navigable : null;
	      },

	      // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params
	      ownParams: function ownParams(state) {
	        var params = state.url && state.url.params || new $$UMFP.ParamSet();
	        forEach(state.params || {}, function (config, id) {
	          if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, "config");
	        });
	        return params;
	      },

	      // Derive parameters for this state and ensure they're a super-set of parent's parameters
	      params: function params(state) {
	        var ownParams = pick(state.ownParams, state.ownParams.$$keys());
	        return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();
	      },

	      // If there is no explicit multi-view configuration, make one up so we don't have
	      // to handle both cases in the view directive later. Note that having an explicit
	      // 'views' property will mean the default unnamed view properties are ignored. This
	      // is also a good time to resolve view names to absolute names, so everything is a
	      // straight lookup at link time.
	      views: function views(state) {
	        var views = {};

	        forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {
	          if (name.indexOf('@') < 0) name += '@' + state.parent.name;
	          view.resolveAs = view.resolveAs || state.resolveAs || '$resolve';
	          views[name] = view;
	        });
	        return views;
	      },

	      // Keep a full path from the root down to this state as this is needed for state activation.
	      path: function path(state) {
	        return state.parent ? state.parent.path.concat(state) : []; // exclude root from path
	      },

	      // Speed up $state.contains() as it's used a lot
	      includes: function includes(state) {
	        var includes = state.parent ? extend({}, state.parent.includes) : {};
	        includes[state.name] = true;
	        return includes;
	      },

	      $delegates: {}
	    };

	    function isRelative(stateName) {
	      return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
	    }

	    function findState(stateOrName, base) {
	      if (!stateOrName) return undefined;

	      var isStr = isString(stateOrName),
	          name = isStr ? stateOrName : stateOrName.name,
	          path = isRelative(name);

	      if (path) {
	        if (!base) throw new Error("No reference point given for path '" + name + "'");
	        base = findState(base);

	        var rel = name.split("."),
	            i = 0,
	            pathLength = rel.length,
	            current = base;

	        for (; i < pathLength; i++) {
	          if (rel[i] === "" && i === 0) {
	            current = base;
	            continue;
	          }
	          if (rel[i] === "^") {
	            if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
	            current = current.parent;
	            continue;
	          }
	          break;
	        }
	        rel = rel.slice(i).join(".");
	        name = current.name + (current.name && rel ? "." : "") + rel;
	      }
	      var state = states[name];

	      if (state && (isStr || !isStr && (state === stateOrName || state.self === stateOrName))) {
	        return state;
	      }
	      return undefined;
	    }

	    function queueState(parentName, state) {
	      if (!queue[parentName]) {
	        queue[parentName] = [];
	      }
	      queue[parentName].push(state);
	    }

	    function flushQueuedChildren(parentName) {
	      var queued = queue[parentName] || [];
	      while (queued.length) {
	        registerState(queued.shift());
	      }
	    }

	    function registerState(state) {
	      // Wrap a new object around the state so we can store our private details easily.
	      state = inherit(state, {
	        self: state,
	        resolve: state.resolve || {},
	        toString: function toString() {
	          return this.name;
	        }
	      });

	      var name = state.name;
	      if (!isString(name) || name.indexOf('@') >= 0) throw new Error("State must have a valid name");
	      if (states.hasOwnProperty(name)) throw new Error("State '" + name + "' is already defined");

	      // Get parent name
	      var parentName = name.indexOf('.') !== -1 ? name.substring(0, name.lastIndexOf('.')) : isString(state.parent) ? state.parent : isObject(state.parent) && isString(state.parent.name) ? state.parent.name : '';

	      // If parent is not registered yet, add state to queue and register later
	      if (parentName && !states[parentName]) {
	        return queueState(parentName, state.self);
	      }

	      for (var key in stateBuilder) {
	        if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
	      }
	      states[name] = state;

	      // Register the state in the global state list and with $urlRouter if necessary.
	      if (!state[abstractKey] && state.url) {
	        $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {
	          if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
	            $state.transitionTo(state, $match, { inherit: true, location: false });
	          }
	        }]);
	      }

	      // Register any queued children
	      flushQueuedChildren(name);

	      return state;
	    }

	    // Checks text to see if it looks like a glob.
	    function isGlob(text) {
	      return text.indexOf('*') > -1;
	    }

	    // Returns true if glob matches current $state name.
	    function doesStateMatchGlob(glob) {
	      var globSegments = glob.split('.'),
	          segments = $state.$current.name.split('.');

	      //match single stars
	      for (var i = 0, l = globSegments.length; i < l; i++) {
	        if (globSegments[i] === '*') {
	          segments[i] = '*';
	        }
	      }

	      //match greedy starts
	      if (globSegments[0] === '**') {
	        segments = segments.slice(indexOf(segments, globSegments[1]));
	        segments.unshift('**');
	      }
	      //match greedy ends
	      if (globSegments[globSegments.length - 1] === '**') {
	        segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
	        segments.push('**');
	      }

	      if (globSegments.length != segments.length) {
	        return false;
	      }

	      return segments.join('') === globSegments.join('');
	    }

	    // Implicit root state that is always active
	    root = registerState({
	      name: '',
	      url: '^',
	      views: null,
	      'abstract': true
	    });
	    root.navigable = null;

	    /**
	     * @ngdoc function
	     * @name ui.router.state.$stateProvider#decorator
	     * @methodOf ui.router.state.$stateProvider
	     *
	     * @description
	     * Allows you to extend (carefully) or override (at your own peril) the 
	     * `stateBuilder` object used internally by `$stateProvider`. This can be used 
	     * to add custom functionality to ui-router, for example inferring templateUrl 
	     * based on the state name.
	     *
	     * When passing only a name, it returns the current (original or decorated) builder
	     * function that matches `name`.
	     *
	     * The builder functions that can be decorated are listed below. Though not all
	     * necessarily have a good use case for decoration, that is up to you to decide.
	     *
	     * In addition, users can attach custom decorators, which will generate new 
	     * properties within the state's internal definition. There is currently no clear 
	     * use-case for this beyond accessing internal states (i.e. $state.$current), 
	     * however, expect this to become increasingly relevant as we introduce additional 
	     * meta-programming features.
	     *
	     * **Warning**: Decorators should not be interdependent because the order of 
	     * execution of the builder functions in non-deterministic. Builder functions 
	     * should only be dependent on the state definition object and super function.
	     *
	     *
	     * Existing builder functions and current return values:
	     *
	     * - **parent** `{object}` - returns the parent state object.
	     * - **data** `{object}` - returns state data, including any inherited data that is not
	     *   overridden by own values (if any).
	     * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
	     *   or `null`.
	     * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is 
	     *   navigable).
	     * - **params** `{object}` - returns an array of state params that are ensured to 
	     *   be a super-set of parent's params.
	     * - **views** `{object}` - returns a views object where each key is an absolute view 
	     *   name (i.e. "viewName@stateName") and each value is the config object 
	     *   (template, controller) for the view. Even when you don't use the views object 
	     *   explicitly on a state config, one is still created for you internally.
	     *   So by decorating this builder function you have access to decorating template 
	     *   and controller properties.
	     * - **ownParams** `{object}` - returns an array of params that belong to the state, 
	     *   not including any params defined by ancestor states.
	     * - **path** `{string}` - returns the full path from the root down to this state. 
	     *   Needed for state activation.
	     * - **includes** `{object}` - returns an object that includes every state that 
	     *   would pass a `$state.includes()` test.
	     *
	     * @example
	     * <pre>
	     * // Override the internal 'views' builder with a function that takes the state
	     * // definition, and a reference to the internal function being overridden:
	     * $stateProvider.decorator('views', function (state, parent) {
	     *   var result = {},
	     *       views = parent(state);
	     *
	     *   angular.forEach(views, function (config, name) {
	     *     var autoName = (state.name + '.' + name).replace('.', '/');
	     *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';
	     *     result[name] = config;
	     *   });
	     *   return result;
	     * });
	     *
	     * $stateProvider.state('home', {
	     *   views: {
	     *     'contact.list': { controller: 'ListController' },
	     *     'contact.item': { controller: 'ItemController' }
	     *   }
	     * });
	     *
	     * // ...
	     *
	     * $state.go('home');
	     * // Auto-populates list and item views with /partials/home/contact/list.html,
	     * // and /partials/home/contact/item.html, respectively.
	     * </pre>
	     *
	     * @param {string} name The name of the builder function to decorate. 
	     * @param {object} func A function that is responsible for decorating the original 
	     * builder function. The function receives two parameters:
	     *
	     *   - `{object}` - state - The state config object.
	     *   - `{object}` - super - The original builder function.
	     *
	     * @return {object} $stateProvider - $stateProvider instance
	     */
	    this.decorator = decorator;
	    function decorator(name, func) {
	      /*jshint validthis: true */
	      if (isString(name) && !isDefined(func)) {
	        return stateBuilder[name];
	      }
	      if (!isFunction(func) || !isString(name)) {
	        return this;
	      }
	      if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
	        stateBuilder.$delegates[name] = stateBuilder[name];
	      }
	      stateBuilder[name] = func;
	      return this;
	    }

	    /**
	     * @ngdoc function
	     * @name ui.router.state.$stateProvider#state
	     * @methodOf ui.router.state.$stateProvider
	     *
	     * @description
	     * Registers a state configuration under a given state name. The stateConfig object
	     * has the following acceptable properties.
	     *
	     * @param {string} name A unique state name, e.g. "home", "about", "contacts".
	     * To create a parent/child state use a dot, e.g. "about.sales", "home.newest".
	     * @param {object} stateConfig State configuration object.
	     * @param {string|function=} stateConfig.template
	     * <a id='template'></a>
	     *   html template as a string or a function that returns
	     *   an html template as a string which should be used by the uiView directives. This property 
	     *   takes precedence over templateUrl.
	     *   
	     *   If `template` is a function, it will be called with the following parameters:
	     *
	     *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by
	     *     applying the current state
	     *
	     * <pre>template:
	     *   "<h1>inline template definition</h1>" +
	     *   "<div ui-view></div>"</pre>
	     * <pre>template: function(params) {
	     *       return "<h1>generated template</h1>"; }</pre>
	     * </div>
	     *
	     * @param {string|function=} stateConfig.templateUrl
	     * <a id='templateUrl'></a>
	     *
	     *   path or function that returns a path to an html
	     *   template that should be used by uiView.
	     *   
	     *   If `templateUrl` is a function, it will be called with the following parameters:
	     *
	     *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by 
	     *     applying the current state
	     *
	     * <pre>templateUrl: "home.html"</pre>
	     * <pre>templateUrl: function(params) {
	     *     return myTemplates[params.pageId]; }</pre>
	     *
	     * @param {function=} stateConfig.templateProvider
	     * <a id='templateProvider'></a>
	     *    Provider function that returns HTML content string.
	     * <pre> templateProvider:
	     *       function(MyTemplateService, params) {
	     *         return MyTemplateService.getTemplate(params.pageId);
	     *       }</pre>
	     *
	     * @param {string|function=} stateConfig.controller
	     * <a id='controller'></a>
	     *
	     *  Controller fn that should be associated with newly
	     *   related scope or the name of a registered controller if passed as a string.
	     *   Optionally, the ControllerAs may be declared here.
	     * <pre>controller: "MyRegisteredController"</pre>
	     * <pre>controller:
	     *     "MyRegisteredController as fooCtrl"}</pre>
	     * <pre>controller: function($scope, MyService) {
	     *     $scope.data = MyService.getData(); }</pre>
	     *
	     * @param {function=} stateConfig.controllerProvider
	     * <a id='controllerProvider'></a>
	     *
	     * Injectable provider function that returns the actual controller or string.
	     * <pre>controllerProvider:
	     *   function(MyResolveData) {
	     *     if (MyResolveData.foo)
	     *       return "FooCtrl"
	     *     else if (MyResolveData.bar)
	     *       return "BarCtrl";
	     *     else return function($scope) {
	     *       $scope.baz = "Qux";
	     *     }
	     *   }</pre>
	     *
	     * @param {string=} stateConfig.controllerAs
	     * <a id='controllerAs'></a>
	     * 
	     * A controller alias name. If present the controller will be
	     *   published to scope under the controllerAs name.
	     * <pre>controllerAs: "myCtrl"</pre>
	     *
	     * @param {string|object=} stateConfig.parent
	     * <a id='parent'></a>
	     * Optionally specifies the parent state of this state.
	     *
	     * <pre>parent: 'parentState'</pre>
	     * <pre>parent: parentState // JS variable</pre>
	     *
	     * @param {object=} stateConfig.resolve
	     * <a id='resolve'></a>
	     *
	     * An optional map&lt;string, function&gt; of dependencies which
	     *   should be injected into the controller. If any of these dependencies are promises, 
	     *   the router will wait for them all to be resolved before the controller is instantiated.
	     *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired
	     *   and the values of the resolved promises are injected into any controllers that reference them.
	     *   If any  of the promises are rejected the $stateChangeError event is fired.
	     *
	     *   The map object is:
	     *   
	     *   - key - {string}: name of dependency to be injected into controller
	     *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, 
	     *     it is injected and return value it treated as dependency. If result is a promise, it is 
	     *     resolved before its value is injected into controller.
	     *
	     * <pre>resolve: {
	     *     myResolve1:
	     *       function($http, $stateParams) {
	     *         return $http.get("/api/foos/"+stateParams.fooID);
	     *       }
	     *     }</pre>
	     *
	     * @param {string=} stateConfig.url
	     * <a id='url'></a>
	     *
	     *   A url fragment with optional parameters. When a state is navigated or
	     *   transitioned to, the `$stateParams` service will be populated with any 
	     *   parameters that were passed.
	     *
	     *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for
	     *   more details on acceptable patterns )
	     *
	     * examples:
	     * <pre>url: "/home"
	     * url: "/users/:userid"
	     * url: "/books/{bookid:[a-zA-Z_-]}"
	     * url: "/books/{categoryid:int}"
	     * url: "/books/{publishername:string}/{categoryid:int}"
	     * url: "/messages?before&after"
	     * url: "/messages?{before:date}&{after:date}"
	     * url: "/messages/:mailboxid?{before:date}&{after:date}"
	     * </pre>
	     *
	     * @param {object=} stateConfig.views
	     * <a id='views'></a>
	     * an optional map&lt;string, object&gt; which defined multiple views, or targets views
	     * manually/explicitly.
	     *
	     * Examples:
	     *
	     * Targets three named `ui-view`s in the parent state's template
	     * <pre>views: {
	     *     header: {
	     *       controller: "headerCtrl",
	     *       templateUrl: "header.html"
	     *     }, body: {
	     *       controller: "bodyCtrl",
	     *       templateUrl: "body.html"
	     *     }, footer: {
	     *       controller: "footCtrl",
	     *       templateUrl: "footer.html"
	     *     }
	     *   }</pre>
	     *
	     * Targets named `ui-view="header"` from grandparent state 'top''s template, and named `ui-view="body" from parent state's template.
	     * <pre>views: {
	     *     'header@top': {
	     *       controller: "msgHeaderCtrl",
	     *       templateUrl: "msgHeader.html"
	     *     }, 'body': {
	     *       controller: "messagesCtrl",
	     *       templateUrl: "messages.html"
	     *     }
	     *   }</pre>
	     *
	     * @param {boolean=} [stateConfig.abstract=false]
	     * <a id='abstract'></a>
	     * An abstract state will never be directly activated,
	     *   but can provide inherited properties to its common children states.
	     * <pre>abstract: true</pre>
	     *
	     * @param {function=} stateConfig.onEnter
	     * <a id='onEnter'></a>
	     *
	     * Callback function for when a state is entered. Good way
	     *   to trigger an action or dispatch an event, such as opening a dialog.
	     * If minifying your scripts, make sure to explicitly annotate this function,
	     * because it won't be automatically annotated by your build tools.
	     *
	     * <pre>onEnter: function(MyService, $stateParams) {
	     *     MyService.foo($stateParams.myParam);
	     * }</pre>
	     *
	     * @param {function=} stateConfig.onExit
	     * <a id='onExit'></a>
	     *
	     * Callback function for when a state is exited. Good way to
	     *   trigger an action or dispatch an event, such as opening a dialog.
	     * If minifying your scripts, make sure to explicitly annotate this function,
	     * because it won't be automatically annotated by your build tools.
	     *
	     * <pre>onExit: function(MyService, $stateParams) {
	     *     MyService.cleanup($stateParams.myParam);
	     * }</pre>
	     *
	     * @param {boolean=} [stateConfig.reloadOnSearch=true]
	     * <a id='reloadOnSearch'></a>
	     *
	     * If `false`, will not retrigger the same state
	     *   just because a search/query parameter has changed (via $location.search() or $location.hash()). 
	     *   Useful for when you'd like to modify $location.search() without triggering a reload.
	     * <pre>reloadOnSearch: false</pre>
	     *
	     * @param {object=} stateConfig.data
	     * <a id='data'></a>
	     *
	     * Arbitrary data object, useful for custom configuration.  The parent state's `data` is
	     *   prototypally inherited.  In other words, adding a data property to a state adds it to
	     *   the entire subtree via prototypal inheritance.
	     *
	     * <pre>data: {
	     *     requiredRole: 'foo'
	     * } </pre>
	     *
	     * @param {object=} stateConfig.params
	     * <a id='params'></a>
	     *
	     * A map which optionally configures parameters declared in the `url`, or
	     *   defines additional non-url parameters.  For each parameter being
	     *   configured, add a configuration object keyed to the name of the parameter.
	     *
	     *   Each parameter configuration object may contain the following properties:
	     *
	     *   - ** value ** - {object|function=}: specifies the default value for this
	     *     parameter.  This implicitly sets this parameter as optional.
	     *
	     *     When UI-Router routes to a state and no value is
	     *     specified for this parameter in the URL or transition, the
	     *     default value will be used instead.  If `value` is a function,
	     *     it will be injected and invoked, and the return value used.
	     *
	     *     *Note*: `undefined` is treated as "no default value" while `null`
	     *     is treated as "the default value is `null`".
	     *
	     *     *Shorthand*: If you only need to configure the default value of the
	     *     parameter, you may use a shorthand syntax.   In the **`params`**
	     *     map, instead mapping the param name to a full parameter configuration
	     *     object, simply set map it to the default parameter value, e.g.:
	     *
	     * <pre>// define a parameter's default value
	     * params: {
	     *     param1: { value: "defaultValue" }
	     * }
	     * // shorthand default values
	     * params: {
	     *     param1: "defaultValue",
	     *     param2: "param2Default"
	     * }</pre>
	     *
	     *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be
	     *     treated as an array of values.  If you specified a Type, the value will be
	     *     treated as an array of the specified Type.  Note: query parameter values
	     *     default to a special `"auto"` mode.
	     *
	     *     For query parameters in `"auto"` mode, if multiple  values for a single parameter
	     *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values
	     *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if
	     *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single
	     *     value (e.g.: `{ foo: '1' }`).
	     *
	     * <pre>params: {
	     *     param1: { array: true }
	     * }</pre>
	     *
	     *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when
	     *     the current parameter value is the same as the default value. If `squash` is not set, it uses the
	     *     configured default squash policy.
	     *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})
	     *
	     *   There are three squash settings:
	     *
	     *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL
	     *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed
	     *       by slashes in the state's `url` declaration, then one of those slashes are omitted.
	     *       This can allow for cleaner looking URLs.
	     *     - `"<arbitrary string>"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.
	     *
	     * <pre>params: {
	     *     param1: {
	     *       value: "defaultId",
	     *       squash: true
	     * } }
	     * // squash "defaultValue" to "~"
	     * params: {
	     *     param1: {
	     *       value: "defaultValue",
	     *       squash: "~"
	     * } }
	     * </pre>
	     *
	     *
	     * @example
	     * <pre>
	     * // Some state name examples
	     *
	     * // stateName can be a single top-level name (must be unique).
	     * $stateProvider.state("home", {});
	     *
	     * // Or it can be a nested state name. This state is a child of the
	     * // above "home" state.
	     * $stateProvider.state("home.newest", {});
	     *
	     * // Nest states as deeply as needed.
	     * $stateProvider.state("home.newest.abc.xyz.inception", {});
	     *
	     * // state() returns $stateProvider, so you can chain state declarations.
	     * $stateProvider
	     *   .state("home", {})
	     *   .state("about", {})
	     *   .state("contacts", {});
	     * </pre>
	     *
	     */
	    this.state = state;
	    function state(name, definition) {
	      /*jshint validthis: true */
	      if (isObject(name)) definition = name;else definition.name = name;
	      registerState(definition);
	      return this;
	    }

	    /**
	     * @ngdoc object
	     * @name ui.router.state.$state
	     *
	     * @requires $rootScope
	     * @requires $q
	     * @requires ui.router.state.$view
	     * @requires $injector
	     * @requires ui.router.util.$resolve
	     * @requires ui.router.state.$stateParams
	     * @requires ui.router.router.$urlRouter
	     *
	     * @property {object} params A param object, e.g. {sectionId: section.id)}, that 
	     * you'd like to test against the current active state.
	     * @property {object} current A reference to the state's config object. However 
	     * you passed it in. Useful for accessing custom data.
	     * @property {object} transition Currently pending transition. A promise that'll 
	     * resolve or reject.
	     *
	     * @description
	     * `$state` service is responsible for representing states as well as transitioning
	     * between them. It also provides interfaces to ask for current state or even states
	     * you're coming from.
	     */
	    this.$get = $get;
	    $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
	    function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {

	      var TransitionSupersededError = new Error('transition superseded');

	      var TransitionSuperseded = silenceUncaughtInPromise($q.reject(TransitionSupersededError));
	      var TransitionPrevented = silenceUncaughtInPromise($q.reject(new Error('transition prevented')));
	      var TransitionAborted = silenceUncaughtInPromise($q.reject(new Error('transition aborted')));
	      var TransitionFailed = silenceUncaughtInPromise($q.reject(new Error('transition failed')));

	      // Handles the case where a state which is the target of a transition is not found, and the user
	      // can optionally retry or defer the transition
	      function handleRedirect(redirect, state, params, options) {
	        /**
	         * @ngdoc event
	         * @name ui.router.state.$state#$stateNotFound
	         * @eventOf ui.router.state.$state
	         * @eventType broadcast on root scope
	         * @description
	         * Fired when a requested state **cannot be found** using the provided state name during transition.
	         * The event is broadcast allowing any handlers a single chance to deal with the error (usually by
	         * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,
	         * you can see its three properties in the example. You can use `event.preventDefault()` to abort the
	         * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.
	         *
	         * @param {Object} event Event object.
	         * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.
	         * @param {State} fromState Current state object.
	         * @param {Object} fromParams Current state params.
	         *
	         * @example
	         *
	         * <pre>
	         * // somewhere, assume lazy.state has not been defined
	         * $state.go("lazy.state", {a:1, b:2}, {inherit:false});
	         *
	         * // somewhere else
	         * $scope.$on('$stateNotFound',
	         * function(event, unfoundState, fromState, fromParams){
	         *     console.log(unfoundState.to); // "lazy.state"
	         *     console.log(unfoundState.toParams); // {a:1, b:2}
	         *     console.log(unfoundState.options); // {inherit:false} + default options
	         * })
	         * </pre>
	         */
	        var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);

	        if (evt.defaultPrevented) {
	          $urlRouter.update();
	          return TransitionAborted;
	        }

	        if (!evt.retry) {
	          return null;
	        }

	        // Allow the handler to return a promise to defer state lookup retry
	        if (options.$retry) {
	          $urlRouter.update();
	          return TransitionFailed;
	        }
	        var retryTransition = $state.transition = $q.when(evt.retry);

	        retryTransition.then(function () {
	          if (retryTransition !== $state.transition) {
	            $rootScope.$broadcast('$stateChangeCancel', redirect.to, redirect.toParams, state, params);
	            return TransitionSuperseded;
	          }
	          redirect.options.$retry = true;
	          return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
	        }, function () {
	          return TransitionAborted;
	        });
	        $urlRouter.update();

	        return retryTransition;
	      }

	      root.locals = { resolve: null, globals: { $stateParams: {} } };

	      $state = {
	        params: {},
	        current: root.self,
	        $current: root,
	        transition: null
	      };

	      /**
	       * @ngdoc function
	       * @name ui.router.state.$state#reload
	       * @methodOf ui.router.state.$state
	       *
	       * @description
	       * A method that force reloads the current state. All resolves are re-resolved,
	       * controllers reinstantiated, and events re-fired.
	       *
	       * @example
	       * <pre>
	       * var app angular.module('app', ['ui.router']);
	       *
	       * app.controller('ctrl', function ($scope, $state) {
	       *   $scope.reload = function(){
	       *     $state.reload();
	       *   }
	       * });
	       * </pre>
	       *
	       * `reload()` is just an alias for:
	       * <pre>
	       * $state.transitionTo($state.current, $stateParams, { 
	       *   reload: true, inherit: false, notify: true
	       * });
	       * </pre>
	       *
	       * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.
	       * @example
	       * <pre>
	       * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' 
	       * //and current state is 'contacts.detail.item'
	       * var app angular.module('app', ['ui.router']);
	       *
	       * app.controller('ctrl', function ($scope, $state) {
	       *   $scope.reload = function(){
	       *     //will reload 'contact.detail' and 'contact.detail.item' states
	       *     $state.reload('contact.detail');
	       *   }
	       * });
	       * </pre>
	       *
	       * `reload()` is just an alias for:
	       * <pre>
	       * $state.transitionTo($state.current, $stateParams, { 
	       *   reload: true, inherit: false, notify: true
	       * });
	       * </pre>
	        * @returns {promise} A promise representing the state of the new transition. See
	       * {@link ui.router.state.$state#methods_go $state.go}.
	       */
	      $state.reload = function reload(state) {
	        return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true });
	      };

	      /**
	       * @ngdoc function
	       * @name ui.router.state.$state#go
	       * @methodOf ui.router.state.$state
	       *
	       * @description
	       * Convenience method for transitioning to a new state. `$state.go` calls 
	       * `$state.transitionTo` internally but automatically sets options to 
	       * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. 
	       * This allows you to easily use an absolute or relative to path and specify 
	       * only the parameters you'd like to update (while letting unspecified parameters 
	       * inherit from the currently active ancestor states).
	       *
	       * @example
	       * <pre>
	       * var app = angular.module('app', ['ui.router']);
	       *
	       * app.controller('ctrl', function ($scope, $state) {
	       *   $scope.changeState = function () {
	       *     $state.go('contact.detail');
	       *   };
	       * });
	       * </pre>
	       * <img src='../ngdoc_assets/StateGoExamples.png'/>
	       *
	       * @param {string} to Absolute state name or relative state path. Some examples:
	       *
	       * - `$state.go('contact.detail')` - will go to the `contact.detail` state
	       * - `$state.go('^')` - will go to a parent state
	       * - `$state.go('^.sibling')` - will go to a sibling state
	       * - `$state.go('.child.grandchild')` - will go to grandchild state
	       *
	       * @param {object=} params A map of the parameters that will be sent to the state, 
	       * will populate $stateParams. Any parameters that are not specified will be inherited from currently 
	       * defined parameters. Only parameters specified in the state definition can be overridden, new 
	       * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters
	       * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.
	       * transitioning to a sibling will get you the parameters for all parents, transitioning to a child
	       * will get you all current parameters, etc.
	       * @param {object=} options Options object. The options are:
	       *
	       * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
	       *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
	       * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
	       * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), 
	       *    defines which state to be relative from.
	       * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
	       * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params
	       *    have changed.  It will reload the resolves and views of the current state and parent states.
	       *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \
	       *    the transition reloads the resolves and views for that matched state, and all its children states.
	       *
	       * @returns {promise} A promise representing the state of the new transition.
	       *
	       * Possible success values:
	       *
	       * - $state.current
	       *
	       * <br/>Possible rejection values:
	       *
	       * - 'transition superseded' - when a newer transition has been started after this one
	       * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener
	       * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or
	       *   when a `$stateNotFound` `event.retry` promise errors.
	       * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.
	       * - *resolve error* - when an error has occurred with a `resolve`
	       *
	       */
	      $state.go = function go(to, params, options) {
	        return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));
	      };

	      /**
	       * @ngdoc function
	       * @name ui.router.state.$state#transitionTo
	       * @methodOf ui.router.state.$state
	       *
	       * @description
	       * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}
	       * uses `transitionTo` internally. `$state.go` is recommended in most situations.
	       *
	       * @example
	       * <pre>
	       * var app = angular.module('app', ['ui.router']);
	       *
	       * app.controller('ctrl', function ($scope, $state) {
	       *   $scope.changeState = function () {
	       *     $state.transitionTo('contact.detail');
	       *   };
	       * });
	       * </pre>
	       *
	       * @param {string} to State name.
	       * @param {object=} toParams A map of the parameters that will be sent to the state,
	       * will populate $stateParams.
	       * @param {object=} options Options object. The options are:
	       *
	       * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
	       *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
	       * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.
	       * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), 
	       *    defines which state to be relative from.
	       * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
	       * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params 
	       *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd
	       *    use this when you want to force a reload when *everything* is the same, including search params.
	       *    if String, then will reload the state with the name given in reload, and any children.
	       *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.
	       *
	       * @returns {promise} A promise representing the state of the new transition. See
	       * {@link ui.router.state.$state#methods_go $state.go}.
	       */
	      $state.transitionTo = function transitionTo(to, toParams, options) {
	        toParams = toParams || {};
	        options = extend({
	          location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false
	        }, options || {});

	        var from = $state.$current,
	            fromParams = $state.params,
	            fromPath = from.path;
	        var evt,
	            toState = findState(to, options.relative);

	        // Store the hash param for later (since it will be stripped out by various methods)
	        var hash = toParams['#'];

	        if (!isDefined(toState)) {
	          var redirect = { to: to, toParams: toParams, options: options };
	          var redirectResult = handleRedirect(redirect, from.self, fromParams, options);

	          if (redirectResult) {
	            return redirectResult;
	          }

	          // Always retry once if the $stateNotFound was not prevented
	          // (handles either redirect changed or state lazy-definition)
	          to = redirect.to;
	          toParams = redirect.toParams;
	          options = redirect.options;
	          toState = findState(to, options.relative);

	          if (!isDefined(toState)) {
	            if (!options.relative) throw new Error("No such state '" + to + "'");
	            throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
	          }
	        }
	        if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
	        if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
	        if (!toState.params.$$validates(toParams)) return TransitionFailed;

	        toParams = toState.params.$$values(toParams);
	        to = toState;

	        var toPath = to.path;

	        // Starting from the root of the path, keep all levels that haven't changed
	        var keep = 0,
	            state = toPath[keep],
	            locals = root.locals,
	            toLocals = [];

	        if (!options.reload) {
	          while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
	            locals = toLocals[keep] = state.locals;
	            keep++;
	            state = toPath[keep];
	          }
	        } else if (isString(options.reload) || isObject(options.reload)) {
	          if (isObject(options.reload) && !options.reload.name) {
	            throw new Error('Invalid reload state object');
	          }

	          var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
	          if (options.reload && !reloadState) {
	            throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
	          }

	          while (state && state === fromPath[keep] && state !== reloadState) {
	            locals = toLocals[keep] = state.locals;
	            keep++;
	            state = toPath[keep];
	          }
	        }

	        // If we're going to the same state and all locals are kept, we've got nothing to do.
	        // But clear 'transition', as we still want to cancel any other pending transitions.
	        // TODO: We may not want to bump 'transition' if we're called from a location change
	        // that we've initiated ourselves, because we might accidentally abort a legitimate
	        // transition initiated from code?
	        if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
	          if (hash) toParams['#'] = hash;
	          $state.params = toParams;
	          copy($state.params, $stateParams);
	          copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);
	          if (options.location && to.navigable && to.navigable.url) {
	            $urlRouter.push(to.navigable.url, toParams, {
	              $$avoidResync: true, replace: options.location === 'replace'
	            });
	            $urlRouter.update(true);
	          }
	          $state.transition = null;
	          return $q.when($state.current);
	        }

	        // Filter parameters before we pass them to event handlers etc.
	        toParams = filterByKeys(to.params.$$keys(), toParams || {});

	        // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart
	        if (hash) toParams['#'] = hash;

	        // Broadcast start event and cancel the transition if requested
	        if (options.notify) {
	          /**
	           * @ngdoc event
	           * @name ui.router.state.$state#$stateChangeStart
	           * @eventOf ui.router.state.$state
	           * @eventType broadcast on root scope
	           * @description
	           * Fired when the state transition **begins**. You can use `event.preventDefault()`
	           * to prevent the transition from happening and then the transition promise will be
	           * rejected with a `'transition prevented'` value.
	           *
	           * @param {Object} event Event object.
	           * @param {State} toState The state being transitioned to.
	           * @param {Object} toParams The params supplied to the `toState`.
	           * @param {State} fromState The current state, pre-transition.
	           * @param {Object} fromParams The params supplied to the `fromState`.
	           *
	           * @example
	           *
	           * <pre>
	           * $rootScope.$on('$stateChangeStart',
	           * function(event, toState, toParams, fromState, fromParams){
	           *     event.preventDefault();
	           *     // transitionTo() promise will be rejected with
	           *     // a 'transition prevented' error
	           * })
	           * </pre>
	           */
	          if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {
	            $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
	            //Don't update and resync url if there's been a new transition started. see issue #2238, #600
	            if ($state.transition == null) $urlRouter.update();
	            return TransitionPrevented;
	          }
	        }

	        // Resolve locals for the remaining states, but don't update any global state just
	        // yet -- if anything fails to resolve the current state needs to remain untouched.
	        // We also set up an inheritance chain for the locals here. This allows the view directive
	        // to quickly look up the correct definition for each view in the current state. Even
	        // though we create the locals object itself outside resolveState(), it is initially
	        // empty and gets filled asynchronously. We need to keep track of the promise for the
	        // (fully resolved) current locals, and pass this down the chain.
	        var resolved = $q.when(locals);

	        for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
	          locals = toLocals[l] = inherit(locals);
	          resolved = resolveState(state, toParams, state === to, resolved, locals, options);
	        }

	        // Once everything is resolved, we are ready to perform the actual transition
	        // and return a promise for the new state. We also keep track of what the
	        // current promise is, so that we can detect overlapping transitions and
	        // keep only the outcome of the last transition.
	        var transition = $state.transition = resolved.then(function () {
	          var l, entering, exiting;

	          if ($state.transition !== transition) {
	            $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
	            return TransitionSuperseded;
	          }

	          // Exit 'from' states not kept
	          for (l = fromPath.length - 1; l >= keep; l--) {
	            exiting = fromPath[l];
	            if (exiting.self.onExit) {
	              $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
	            }
	            exiting.locals = null;
	          }

	          // Enter 'to' states not kept
	          for (l = keep; l < toPath.length; l++) {
	            entering = toPath[l];
	            entering.locals = toLocals[l];
	            if (entering.self.onEnter) {
	              $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
	            }
	          }

	          // Run it again, to catch any transitions in callbacks
	          if ($state.transition !== transition) {
	            $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
	            return TransitionSuperseded;
	          }

	          // Update globals in $state
	          $state.$current = to;
	          $state.current = to.self;
	          $state.params = toParams;
	          copy($state.params, $stateParams);
	          $state.transition = null;

	          if (options.location && to.navigable) {
	            $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
	              $$avoidResync: true, replace: options.location === 'replace'
	            });
	          }

	          if (options.notify) {
	            /**
	             * @ngdoc event
	             * @name ui.router.state.$state#$stateChangeSuccess
	             * @eventOf ui.router.state.$state
	             * @eventType broadcast on root scope
	             * @description
	             * Fired once the state transition is **complete**.
	             *
	             * @param {Object} event Event object.
	             * @param {State} toState The state being transitioned to.
	             * @param {Object} toParams The params supplied to the `toState`.
	             * @param {State} fromState The current state, pre-transition.
	             * @param {Object} fromParams The params supplied to the `fromState`.
	             */
	            $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
	          }
	          $urlRouter.update(true);

	          return $state.current;
	        }).then(null, function (error) {
	          // propagate TransitionSuperseded error without emitting $stateChangeCancel
	          // as it was already emitted in the success handler above
	          if (error === TransitionSupersededError) return TransitionSuperseded;

	          if ($state.transition !== transition) {
	            $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
	            return TransitionSuperseded;
	          }

	          $state.transition = null;
	          /**
	           * @ngdoc event
	           * @name ui.router.state.$state#$stateChangeError
	           * @eventOf ui.router.state.$state
	           * @eventType broadcast on root scope
	           * @description
	           * Fired when an **error occurs** during transition. It's important to note that if you
	           * have any errors in your resolve functions (javascript errors, non-existent services, etc)
	           * they will not throw traditionally. You must listen for this $stateChangeError event to
	           * catch **ALL** errors.
	           *
	           * @param {Object} event Event object.
	           * @param {State} toState The state being transitioned to.
	           * @param {Object} toParams The params supplied to the `toState`.
	           * @param {State} fromState The current state, pre-transition.
	           * @param {Object} fromParams The params supplied to the `fromState`.
	           * @param {Error} error The resolve error object.
	           */
	          evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);

	          if (!evt.defaultPrevented) {
	            $urlRouter.update();
	          }

	          return $q.reject(error);
	        });

	        return transition;
	      };

	      /**
	       * @ngdoc function
	       * @name ui.router.state.$state#is
	       * @methodOf ui.router.state.$state
	       *
	       * @description
	       * Similar to {@link ui.router.state.$state#methods_includes $state.includes},
	       * but only checks for the full state name. If params is supplied then it will be
	       * tested for strict equality against the current active params object, so all params
	       * must match with none missing and no extras.
	       *
	       * @example
	       * <pre>
	       * $state.$current.name = 'contacts.details.item';
	       *
	       * // absolute name
	       * $state.is('contact.details.item'); // returns true
	       * $state.is(contactDetailItemStateObject); // returns true
	       *
	       * // relative name (. and ^), typically from a template
	       * // E.g. from the 'contacts.details' template
	       * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
	       * </pre>
	       *
	       * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.
	       * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like
	       * to test against the current active state.
	       * @param {object=} options An options object.  The options are:
	       *
	       * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will
	       * test relative to `options.relative` state (or name).
	       *
	       * @returns {boolean} Returns true if it is the state.
	       */
	      $state.is = function is(stateOrName, params, options) {
	        options = extend({ relative: $state.$current }, options || {});
	        var state = findState(stateOrName, options.relative);

	        if (!isDefined(state)) {
	          return undefined;
	        }
	        if ($state.$current !== state) {
	          return false;
	        }
	        return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
	      };

	      /**
	       * @ngdoc function
	       * @name ui.router.state.$state#includes
	       * @methodOf ui.router.state.$state
	       *
	       * @description
	       * A method to determine if the current active state is equal to or is the child of the
	       * state stateName. If any params are passed then they will be tested for a match as well.
	       * Not all the parameters need to be passed, just the ones you'd like to test for equality.
	       *
	       * @example
	       * Partial and relative names
	       * <pre>
	       * $state.$current.name = 'contacts.details.item';
	       *
	       * // Using partial names
	       * $state.includes("contacts"); // returns true
	       * $state.includes("contacts.details"); // returns true
	       * $state.includes("contacts.details.item"); // returns true
	       * $state.includes("contacts.list"); // returns false
	       * $state.includes("about"); // returns false
	       *
	       * // Using relative names (. and ^), typically from a template
	       * // E.g. from the 'contacts.details' template
	       * <div ng-class="{highlighted: $state.includes('.item')}">Item</div>
	       * </pre>
	       *
	       * Basic globbing patterns
	       * <pre>
	       * $state.$current.name = 'contacts.details.item.url';
	       *
	       * $state.includes("*.details.*.*"); // returns true
	       * $state.includes("*.details.**"); // returns true
	       * $state.includes("**.item.**"); // returns true
	       * $state.includes("*.details.item.url"); // returns true
	       * $state.includes("*.details.*.url"); // returns true
	       * $state.includes("*.details.*"); // returns false
	       * $state.includes("item.**"); // returns false
	       * </pre>
	       *
	       * @param {string} stateOrName A partial name, relative name, or glob pattern
	       * to be searched for within the current state name.
	       * @param {object=} params A param object, e.g. `{sectionId: section.id}`,
	       * that you'd like to test against the current active state.
	       * @param {object=} options An options object.  The options are:
	       *
	       * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,
	       * .includes will test relative to `options.relative` state (or name).
	       *
	       * @returns {boolean} Returns true if it does include the state
	       */
	      $state.includes = function includes(stateOrName, params, options) {
	        options = extend({ relative: $state.$current }, options || {});
	        if (isString(stateOrName) && isGlob(stateOrName)) {
	          if (!doesStateMatchGlob(stateOrName)) {
	            return false;
	          }
	          stateOrName = $state.$current.name;
	        }

	        var state = findState(stateOrName, options.relative);
	        if (!isDefined(state)) {
	          return undefined;
	        }
	        if (!isDefined($state.$current.includes[state.name])) {
	          return false;
	        }
	        if (!params) {
	          return true;
	        }

	        var keys = objectKeys(params);
	        for (var i = 0; i < keys.length; i++) {
	          var key = keys[i],
	              paramDef = state.params[key];
	          if (paramDef && !paramDef.type.equals($stateParams[key], params[key])) {
	            return false;
	          }
	        }

	        return true;
	      };

	      /**
	       * @ngdoc function
	       * @name ui.router.state.$state#href
	       * @methodOf ui.router.state.$state
	       *
	       * @description
	       * A url generation method that returns the compiled url for the given state populated with the given params.
	       *
	       * @example
	       * <pre>
	       * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
	       * </pre>
	       *
	       * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.
	       * @param {object=} params An object of parameter values to fill the state's required parameters.
	       * @param {object=} options Options object. The options are:
	       *
	       * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the
	       *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka
	       *    ancestor with a valid url).
	       * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
	       * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), 
	       *    defines which state to be relative from.
	       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
	       * 
	       * @returns {string} compiled state url
	       */
	      $state.href = function href(stateOrName, params, options) {
	        options = extend({
	          lossy: true,
	          inherit: true,
	          absolute: false,
	          relative: $state.$current
	        }, options || {});

	        var state = findState(stateOrName, options.relative);

	        if (!isDefined(state)) return null;
	        if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);

	        var nav = state && options.lossy ? state.navigable : state;

	        if (!nav || nav.url === undefined || nav.url === null) {
	          return null;
	        }
	        return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {
	          absolute: options.absolute
	        });
	      };

	      /**
	       * @ngdoc function
	       * @name ui.router.state.$state#get
	       * @methodOf ui.router.state.$state
	       *
	       * @description
	       * Returns the state configuration object for any specific state or all states.
	       *
	       * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for
	       * the requested state. If not provided, returns an array of ALL state configs.
	       * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.
	       * @returns {Object|Array} State configuration object or array of all objects.
	       */
	      $state.get = function (stateOrName, context) {
	        if (arguments.length === 0) return map(objectKeys(states), function (name) {
	          return states[name].self;
	        });
	        var state = findState(stateOrName, context || $state.$current);
	        return state && state.self ? state.self : null;
	      };

	      function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
	        // Make a restricted $stateParams with only the parameters that apply to this state if
	        // necessary. In addition to being available to the controller and onEnter/onExit callbacks,
	        // we also need $stateParams to be available for any $injector calls we make during the
	        // dependency resolution process.
	        var $stateParams = paramsAreFiltered ? params : filterByKeys(state.params.$$keys(), params);
	        var locals = { $stateParams: $stateParams };

	        // Resolve 'global' dependencies for the state, i.e. those not specific to a view.
	        // We're also including $stateParams in this; that way the parameters are restricted
	        // to the set that should be visible to the state, and are independent of when we update
	        // the global $state and $stateParams values.
	        dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
	        var promises = [dst.resolve.then(function (globals) {
	          dst.globals = globals;
	        })];
	        if (inherited) promises.push(inherited);

	        function resolveViews() {
	          var viewsPromises = [];

	          // Resolve template and dependencies for all views.
	          forEach(state.views, function (view, name) {
	            var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};
	            injectables.$template = [function () {
	              return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';
	            }];

	            viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {
	              // References to the controller (only instantiated at link time)
	              if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
	                var injectLocals = angular.extend({}, injectables, dst.globals);
	                result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
	              } else {
	                result.$$controller = view.controller;
	              }
	              // Provide access to the state itself for internal use
	              result.$$state = state;
	              result.$$controllerAs = view.controllerAs;
	              result.$$resolveAs = view.resolveAs;
	              dst[name] = result;
	            }));
	          });

	          return $q.all(viewsPromises).then(function () {
	            return dst.globals;
	          });
	        }

	        // Wait for all the promises and then return the activation object
	        return $q.all(promises).then(resolveViews).then(function (values) {
	          return dst;
	        });
	      }

	      return $state;
	    }

	    function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
	      // Return true if there are no differences in non-search (path/object) params, false if there are differences
	      function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
	        // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.
	        function notSearchParam(key) {
	          return fromAndToState.params[key].location != "search";
	        }
	        var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
	        var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
	        var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
	        return nonQueryParamSet.$$equals(fromParams, toParams);
	      }

	      // If reload was not explicitly requested
	      // and we're transitioning to the same state we're already in
	      // and    the locals didn't change
	      //     or they changed in a way that doesn't merit reloading
	      //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)
	      // Then return true.
	      if (!options.reload && to === from && (locals === from.locals || to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams))) {
	        return true;
	      }
	    }
	  }

	  angular.module('ui.router.state').factory('$stateParams', function () {
	    return {};
	  }).constant("$state.runtime", { autoinject: true }).provider('$state', $StateProvider)
	  // Inject $state to initialize when entering runtime. #2574
	  .run(['$injector', function ($injector) {
	    // Allow tests (stateSpec.js) to turn this off by defining this constant
	    if ($injector.get("$state.runtime").autoinject) {
	      $injector.get('$state');
	    }
	  }]);

	  $ViewProvider.$inject = [];
	  function $ViewProvider() {

	    this.$get = $get;
	    /**
	     * @ngdoc object
	     * @name ui.router.state.$view
	     *
	     * @requires ui.router.util.$templateFactory
	     * @requires $rootScope
	     *
	     * @description
	     *
	     */
	    $get.$inject = ['$rootScope', '$templateFactory'];
	    function $get($rootScope, $templateFactory) {
	      return {
	        // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })
	        /**
	         * @ngdoc function
	         * @name ui.router.state.$view#load
	         * @methodOf ui.router.state.$view
	         *
	         * @description
	         *
	         * @param {string} name name
	         * @param {object} options option object.
	         */
	        load: function load(name, options) {
	          var result,
	              defaults = {
	            template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}
	          };
	          options = extend(defaults, options);

	          if (options.view) {
	            result = $templateFactory.fromConfig(options.view, options.params, options.locals);
	          }
	          return result;
	        }
	      };
	    }
	  }

	  angular.module('ui.router.state').provider('$view', $ViewProvider);

	  /**
	   * @ngdoc object
	   * @name ui.router.state.$uiViewScrollProvider
	   *
	   * @description
	   * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.
	   */
	  function $ViewScrollProvider() {

	    var useAnchorScroll = false;

	    /**
	     * @ngdoc function
	     * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll
	     * @methodOf ui.router.state.$uiViewScrollProvider
	     *
	     * @description
	     * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for
	     * scrolling based on the url anchor.
	     */
	    this.useAnchorScroll = function () {
	      useAnchorScroll = true;
	    };

	    /**
	     * @ngdoc object
	     * @name ui.router.state.$uiViewScroll
	     *
	     * @requires $anchorScroll
	     * @requires $timeout
	     *
	     * @description
	     * When called with a jqLite element, it scrolls the element into view (after a
	     * `$timeout` so the DOM has time to refresh).
	     *
	     * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,
	     * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.
	     */
	    this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {
	      if (useAnchorScroll) {
	        return $anchorScroll;
	      }

	      return function ($element) {
	        return $timeout(function () {
	          $element[0].scrollIntoView();
	        }, 0, false);
	      };
	    }];
	  }

	  angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);

	  /**
	   * @ngdoc directive
	   * @name ui.router.state.directive:ui-view
	   *
	   * @requires ui.router.state.$state
	   * @requires $compile
	   * @requires $controller
	   * @requires $injector
	   * @requires ui.router.state.$uiViewScroll
	   * @requires $document
	   *
	   * @restrict ECA
	   *
	   * @description
	   * The ui-view directive tells $state where to place your templates.
	   *
	   * @param {string=} name A view name. The name should be unique amongst the other views in the
	   * same state. You can have views of the same name that live in different states.
	   *
	   * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window
	   * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll
	   * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you
	   * scroll ui-view elements into view when they are populated during a state activation.
	   *
	   * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)
	   * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*
	   *
	   * @param {string=} onload Expression to evaluate whenever the view updates.
	   *
	   * @example
	   * A view can be unnamed or named.
	   * <pre>
	   * <!-- Unnamed -->
	   * <div ui-view></div>
	   *
	   * <!-- Named -->
	   * <div ui-view="viewName"></div>
	   * </pre>
	   *
	   * You can only have one unnamed view within any template (or root html). If you are only using a
	   * single view and it is unnamed then you can populate it like so:
	   * <pre>
	   * <div ui-view></div>
	   * $stateProvider.state("home", {
	   *   template: "<h1>HELLO!</h1>"
	   * })
	   * </pre>
	   *
	   * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#methods_state `views`}
	   * config property, by name, in this case an empty name:
	   * <pre>
	   * $stateProvider.state("home", {
	   *   views: {
	   *     "": {
	   *       template: "<h1>HELLO!</h1>"
	   *     }
	   *   }    
	   * })
	   * </pre>
	   *
	   * But typically you'll only use the views property if you name your view or have more than one view
	   * in the same template. There's not really a compelling reason to name a view if its the only one,
	   * but you could if you wanted, like so:
	   * <pre>
	   * <div ui-view="main"></div>
	   * </pre>
	   * <pre>
	   * $stateProvider.state("home", {
	   *   views: {
	   *     "main": {
	   *       template: "<h1>HELLO!</h1>"
	   *     }
	   *   }    
	   * })
	   * </pre>
	   *
	   * Really though, you'll use views to set up multiple views:
	   * <pre>
	   * <div ui-view></div>
	   * <div ui-view="chart"></div>
	   * <div ui-view="data"></div>
	   * </pre>
	   *
	   * <pre>
	   * $stateProvider.state("home", {
	   *   views: {
	   *     "": {
	   *       template: "<h1>HELLO!</h1>"
	   *     },
	   *     "chart": {
	   *       template: "<chart_thing/>"
	   *     },
	   *     "data": {
	   *       template: "<data_thing/>"
	   *     }
	   *   }    
	   * })
	   * </pre>
	   *
	   * Examples for `autoscroll`:
	   *
	   * <pre>
	   * <!-- If autoscroll present with no expression,
	   *      then scroll ui-view into view -->
	   * <ui-view autoscroll/>
	   *
	   * <!-- If autoscroll present with valid expression,
	   *      then scroll ui-view into view if expression evaluates to true -->
	   * <ui-view autoscroll='true'/>
	   * <ui-view autoscroll='false'/>
	   * <ui-view autoscroll='scopeVariable'/>
	   * </pre>
	   *
	   * Resolve data:
	   *
	   * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this
	   * can be customized using [[ViewDeclaration.resolveAs]]).  This can be then accessed from the template.
	   *
	   * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the
	   * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which
	   * depends on `$resolve` data.
	   *
	   * Example usage of $resolve in a view template
	   * <pre>
	   * $stateProvider.state('home', {
	   *   template: '<my-component user="$resolve.user"></my-component>',
	   *   resolve: {
	   *     user: function(UserService) { return UserService.fetchUser(); }
	   *   }
	   * });
	   * </pre>
	   */
	  $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate', '$q'];
	  function $ViewDirective($state, $injector, $uiViewScroll, $interpolate, $q) {

	    function getService() {
	      return $injector.has ? function (service) {
	        return $injector.has(service) ? $injector.get(service) : null;
	      } : function (service) {
	        try {
	          return $injector.get(service);
	        } catch (e) {
	          return null;
	        }
	      };
	    }

	    var service = getService(),
	        $animator = service('$animator'),
	        $animate = service('$animate');

	    // Returns a set of DOM manipulation functions based on which Angular version
	    // it should use
	    function getRenderer(attrs, scope) {
	      var statics = function statics() {
	        return {
	          enter: function enter(element, target, cb) {
	            target.after(element);cb();
	          },
	          leave: function leave(element, cb) {
	            element.remove();cb();
	          }
	        };
	      };

	      if ($animate) {
	        return {
	          enter: function enter(element, target, cb) {
	            if (angular.version.minor > 2) {
	              $animate.enter(element, null, target).then(cb);
	            } else {
	              $animate.enter(element, null, target, cb);
	            }
	          },
	          leave: function leave(element, cb) {
	            if (angular.version.minor > 2) {
	              $animate.leave(element).then(cb);
	            } else {
	              $animate.leave(element, cb);
	            }
	          }
	        };
	      }

	      if ($animator) {
	        var animate = $animator && $animator(scope, attrs);

	        return {
	          enter: function enter(element, target, cb) {
	            animate.enter(element, null, target);cb();
	          },
	          leave: function leave(element, cb) {
	            animate.leave(element);cb();
	          }
	        };
	      }

	      return statics();
	    }

	    var directive = {
	      restrict: 'ECA',
	      terminal: true,
	      priority: 400,
	      transclude: 'element',
	      compile: function compile(tElement, tAttrs, $transclude) {
	        return function (scope, $element, attrs) {
	          var previousEl,
	              currentEl,
	              currentScope,
	              latestLocals,
	              onloadExp = attrs.onload || '',
	              autoScrollExp = attrs.autoscroll,
	              renderer = getRenderer(attrs, scope),
	              inherited = $element.inheritedData('$uiView');

	          scope.$on('$stateChangeSuccess', function () {
	            updateView(false);
	          });

	          updateView(true);

	          function cleanupLastView() {
	            if (previousEl) {
	              previousEl.remove();
	              previousEl = null;
	            }

	            if (currentScope) {
	              currentScope.$destroy();
	              currentScope = null;
	            }

	            if (currentEl) {
	              var $uiViewData = currentEl.data('$uiViewAnim');
	              renderer.leave(currentEl, function () {
	                $uiViewData.$$animLeave.resolve();
	                previousEl = null;
	              });

	              previousEl = currentEl;
	              currentEl = null;
	            }
	          }

	          function updateView(firstTime) {
	            var newScope,
	                name = getUiViewName(scope, attrs, $element, $interpolate),
	                previousLocals = name && $state.$current && $state.$current.locals[name];

	            if (!firstTime && previousLocals === latestLocals) return; // nothing to do
	            newScope = scope.$new();
	            latestLocals = $state.$current.locals[name];

	            /**
	             * @ngdoc event
	             * @name ui.router.state.directive:ui-view#$viewContentLoading
	             * @eventOf ui.router.state.directive:ui-view
	             * @eventType emits on ui-view directive scope
	             * @description
	             *
	             * Fired once the view **begins loading**, *before* the DOM is rendered.
	             *
	             * @param {Object} event Event object.
	             * @param {string} viewName Name of the view.
	             */
	            newScope.$emit('$viewContentLoading', name);

	            var clone = $transclude(newScope, function (clone) {
	              var animEnter = $q.defer(),
	                  animLeave = $q.defer();
	              var viewAnimData = {
	                $animEnter: animEnter.promise,
	                $animLeave: animLeave.promise,
	                $$animLeave: animLeave
	              };

	              clone.data('$uiViewAnim', viewAnimData);
	              renderer.enter(clone, $element, function onUiViewEnter() {
	                animEnter.resolve();
	                if (currentScope) {
	                  currentScope.$emit('$viewContentAnimationEnded');
	                }

	                if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
	                  $uiViewScroll(clone);
	                }
	              });
	              cleanupLastView();
	            });

	            currentEl = clone;
	            currentScope = newScope;
	            /**
	             * @ngdoc event
	             * @name ui.router.state.directive:ui-view#$viewContentLoaded
	             * @eventOf ui.router.state.directive:ui-view
	             * @eventType emits on ui-view directive scope
	             * @description
	             * Fired once the view is **loaded**, *after* the DOM is rendered.
	             *
	             * @param {Object} event Event object.
	             * @param {string} viewName Name of the view.
	             */
	            currentScope.$emit('$viewContentLoaded', name);
	            currentScope.$eval(onloadExp);
	          }
	        };
	      }
	    };

	    return directive;
	  }

	  $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
	  function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
	    return {
	      restrict: 'ECA',
	      priority: -400,
	      compile: function compile(tElement) {
	        var initial = tElement.html();
	        return function (scope, $element, attrs) {
	          var current = $state.$current,
	              name = getUiViewName(scope, attrs, $element, $interpolate),
	              locals = current && current.locals[name];

	          if (!locals) {
	            return;
	          }

	          $element.data('$uiView', { name: name, state: locals.$$state });
	          $element.html(locals.$template ? locals.$template : initial);

	          var resolveData = angular.extend({}, locals);
	          scope[locals.$$resolveAs] = resolveData;

	          var link = $compile($element.contents());

	          if (locals.$$controller) {
	            locals.$scope = scope;
	            locals.$element = $element;
	            var controller = $controller(locals.$$controller, locals);
	            if (locals.$$controllerAs) {
	              scope[locals.$$controllerAs] = controller;
	              scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData;
	            }
	            if (isFunction(controller.$onInit)) controller.$onInit();
	            $element.data('$ngControllerController', controller);
	            $element.children().data('$ngControllerController', controller);
	          }

	          link(scope);
	        };
	      }
	    };
	  }

	  /**
	   * Shared ui-view code for both directives:
	   * Given scope, element, and its attributes, return the view's name
	   */
	  function getUiViewName(scope, attrs, element, $interpolate) {
	    var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
	    var uiViewCreatedBy = element.inheritedData('$uiView');
	    return name.indexOf('@') >= 0 ? name : name + '@' + (uiViewCreatedBy ? uiViewCreatedBy.state.name : '');
	  }

	  angular.module('ui.router.state').directive('uiView', $ViewDirective);
	  angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);

	  function parseStateRef(ref, current) {
	    var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
	        parsed;
	    if (preparsed) ref = current + '(' + preparsed[1] + ')';
	    parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
	    if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
	    return { state: parsed[1], paramExpr: parsed[3] || null };
	  }

	  function stateContext(el) {
	    var stateData = el.parent().inheritedData('$uiView');

	    if (stateData && stateData.state && stateData.state.name) {
	      return stateData.state;
	    }
	  }

	  function getTypeInfo(el) {
	    // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
	    var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
	    var isForm = el[0].nodeName === "FORM";

	    return {
	      attr: isForm ? "action" : isSvg ? 'xlink:href' : 'href',
	      isAnchor: el.prop("tagName").toUpperCase() === "A",
	      clickable: !isForm
	    };
	  }

	  function clickHook(el, $state, $timeout, type, current) {
	    return function (e) {
	      var button = e.which || e.button,
	          target = current();

	      if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
	        // HACK: This is to allow ng-clicks to be processed before the transition is initiated:
	        var transition = $timeout(function () {
	          $state.go(target.state, target.params, target.options);
	        });
	        e.preventDefault();

	        // if the state has no URL, ignore one preventDefault from the <a> directive.
	        var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;

	        e.preventDefault = function () {
	          if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);
	        };
	      }
	    };
	  }

	  function defaultOpts(el, $state) {
	    return { relative: stateContext(el) || $state.$current, inherit: true };
	  }

	  /**
	   * @ngdoc directive
	   * @name ui.router.state.directive:ui-sref
	   *
	   * @requires ui.router.state.$state
	   * @requires $timeout
	   *
	   * @restrict A
	   *
	   * @description
	   * A directive that binds a link (`<a>` tag) to a state. If the state has an associated
	   * URL, the directive will automatically generate & update the `href` attribute via
	   * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking
	   * the link will trigger a state transition with optional parameters.
	   *
	   * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be
	   * handled natively by the browser.
	   *
	   * You can also use relative state paths within ui-sref, just like the relative
	   * paths passed to `$state.go()`. You just need to be aware that the path is relative
	   * to the state that the link lives in, in other words the state that loaded the
	   * template containing the link.
	   *
	   * You can specify options to pass to {@link ui.router.state.$state#methods_go $state.go()}
	   * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,
	   * and `reload`.
	   *
	   * @example
	   * Here's an example of how you'd use ui-sref and how it would compile. If you have the
	   * following template:
	   * <pre>
	   * <a ui-sref="home">Home</a> | <a ui-sref="about">About</a> | <a ui-sref="{page: 2}">Next page</a>
	   *
	   * <ul>
	   *     <li ng-repeat="contact in contacts">
	   *         <a ui-sref="contacts.detail({ id: contact.id })">{{ contact.name }}</a>
	   *     </li>
	   * </ul>
	   * </pre>
	   *
	   * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):
	   * <pre>
	   * <a href="#/home" ui-sref="home">Home</a> | <a href="#/about" ui-sref="about">About</a> | <a href="#/contacts?page=2" ui-sref="{page: 2}">Next page</a>
	   *
	   * <ul>
	   *     <li ng-repeat="contact in contacts">
	   *         <a href="#/contacts/1" ui-sref="contacts.detail({ id: contact.id })">Joe</a>
	   *     </li>
	   *     <li ng-repeat="contact in contacts">
	   *         <a href="#/contacts/2" ui-sref="contacts.detail({ id: contact.id })">Alice</a>
	   *     </li>
	   *     <li ng-repeat="contact in contacts">
	   *         <a href="#/contacts/3" ui-sref="contacts.detail({ id: contact.id })">Bob</a>
	   *     </li>
	   * </ul>
	   *
	   * <a ui-sref="home" ui-sref-opts="{reload: true}">Home</a>
	   * </pre>
	   *
	   * @param {string} ui-sref 'stateName' can be any valid absolute or relative state
	   * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}
	   */
	  $StateRefDirective.$inject = ['$state', '$timeout'];
	  function $StateRefDirective($state, $timeout) {
	    return {
	      restrict: 'A',
	      require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
	      link: function link(scope, element, attrs, uiSrefActive) {
	        var ref = parseStateRef(attrs.uiSref, $state.current.name);
	        var def = { state: ref.state, href: null, params: null };
	        var type = getTypeInfo(element);
	        var active = uiSrefActive[1] || uiSrefActive[0];
	        var unlinkInfoFn = null;
	        var hookFn;

	        def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});

	        var update = function update(val) {
	          if (val) def.params = angular.copy(val);
	          def.href = $state.href(ref.state, def.params, def.options);

	          if (unlinkInfoFn) unlinkInfoFn();
	          if (active) unlinkInfoFn = active.$$addStateInfo(ref.state, def.params);
	          if (def.href !== null) attrs.$set(type.attr, def.href);
	        };

	        if (ref.paramExpr) {
	          scope.$watch(ref.paramExpr, function (val) {
	            if (val !== def.params) update(val);
	          }, true);
	          def.params = angular.copy(scope.$eval(ref.paramExpr));
	        }
	        update();

	        if (!type.clickable) return;
	        hookFn = clickHook(element, $state, $timeout, type, function () {
	          return def;
	        });
	        element[element.on ? 'on' : 'bind']("click", hookFn);
	        scope.$on('$destroy', function () {
	          element[element.off ? 'off' : 'unbind']("click", hookFn);
	        });
	      }
	    };
	  }

	  /**
	   * @ngdoc directive
	   * @name ui.router.state.directive:ui-state
	   *
	   * @requires ui.router.state.uiSref
	   *
	   * @restrict A
	   *
	   * @description
	   * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,
	   * params and override options.
	   *
	   * @param {string} ui-state 'stateName' can be any valid absolute or relative state
	   * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#methods_href $state.href()}
	   * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}
	   */
	  $StateRefDynamicDirective.$inject = ['$state', '$timeout'];
	  function $StateRefDynamicDirective($state, $timeout) {
	    return {
	      restrict: 'A',
	      require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
	      link: function link(scope, element, attrs, uiSrefActive) {
	        var type = getTypeInfo(element);
	        var active = uiSrefActive[1] || uiSrefActive[0];
	        var group = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];
	        var watch = '[' + group.map(function (val) {
	          return val || 'null';
	        }).join(', ') + ']';
	        var def = { state: null, params: null, options: null, href: null };
	        var unlinkInfoFn = null;
	        var hookFn;

	        function runStateRefLink(group) {
	          def.state = group[0];def.params = group[1];def.options = group[2];
	          def.href = $state.href(def.state, def.params, def.options);

	          if (unlinkInfoFn) unlinkInfoFn();
	          if (active) unlinkInfoFn = active.$$addStateInfo(def.state, def.params);
	          if (def.href) attrs.$set(type.attr, def.href);
	        }

	        scope.$watch(watch, runStateRefLink, true);
	        runStateRefLink(scope.$eval(watch));

	        if (!type.clickable) return;
	        hookFn = clickHook(element, $state, $timeout, type, function () {
	          return def;
	        });
	        element[element.on ? 'on' : 'bind']("click", hookFn);
	        scope.$on('$destroy', function () {
	          element[element.off ? 'off' : 'unbind']("click", hookFn);
	        });
	      }
	    };
	  }

	  /**
	   * @ngdoc directive
	   * @name ui.router.state.directive:ui-sref-active
	   *
	   * @requires ui.router.state.$state
	   * @requires ui.router.state.$stateParams
	   * @requires $interpolate
	   *
	   * @restrict A
	   *
	   * @description
	   * A directive working alongside ui-sref to add classes to an element when the
	   * related ui-sref directive's state is active, and removing them when it is inactive.
	   * The primary use-case is to simplify the special appearance of navigation menus
	   * relying on `ui-sref`, by having the "active" state's menu button appear different,
	   * distinguishing it from the inactive menu items.
	   *
	   * ui-sref-active can live on the same element as ui-sref or on a parent element. The first
	   * ui-sref-active found at the same level or above the ui-sref will be used.
	   *
	   * Will activate when the ui-sref's target state or any child state is active. If you
	   * need to activate only when the ui-sref target state is active and *not* any of
	   * it's children, then you will use
	   * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}
	   *
	   * @example
	   * Given the following template:
	   * <pre>
	   * <ul>
	   *   <li ui-sref-active="active" class="item">
	   *     <a href ui-sref="app.user({user: 'bilbobaggins'})">@bilbobaggins</a>
	   *   </li>
	   * </ul>
	   * </pre>
	   *
	   *
	   * When the app state is "app.user" (or any children states), and contains the state parameter "user" with value "bilbobaggins",
	   * the resulting HTML will appear as (note the 'active' class):
	   * <pre>
	   * <ul>
	   *   <li ui-sref-active="active" class="item active">
	   *     <a ui-sref="app.user({user: 'bilbobaggins'})" href="/users/bilbobaggins">@bilbobaggins</a>
	   *   </li>
	   * </ul>
	   * </pre>
	   *
	   * The class name is interpolated **once** during the directives link time (any further changes to the
	   * interpolated value are ignored).
	   *
	   * Multiple classes may be specified in a space-separated format:
	   * <pre>
	   * <ul>
	   *   <li ui-sref-active='class1 class2 class3'>
	   *     <a ui-sref="app.user">link</a>
	   *   </li>
	   * </ul>
	   * </pre>
	   *
	   * It is also possible to pass ui-sref-active an expression that evaluates
	   * to an object hash, whose keys represent active class names and whose
	   * values represent the respective state names/globs.
	   * ui-sref-active will match if the current active state **includes** any of
	   * the specified state names/globs, even the abstract ones.
	   *
	   * @Example
	   * Given the following template, with "admin" being an abstract state:
	   * <pre>
	   * <div ui-sref-active="{'active': 'admin.*'}">
	   *   <a ui-sref-active="active" ui-sref="admin.roles">Roles</a>
	   * </div>
	   * </pre>
	   *
	   * When the current state is "admin.roles" the "active" class will be applied
	   * to both the <div> and <a> elements. It is important to note that the state
	   * names/globs passed to ui-sref-active shadow the state provided by ui-sref.
	   */

	  /**
	   * @ngdoc directive
	   * @name ui.router.state.directive:ui-sref-active-eq
	   *
	   * @requires ui.router.state.$state
	   * @requires ui.router.state.$stateParams
	   * @requires $interpolate
	   *
	   * @restrict A
	   *
	   * @description
	   * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate
	   * when the exact target state used in the `ui-sref` is active; no child states.
	   *
	   */
	  $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
	  function $StateRefActiveDirective($state, $stateParams, $interpolate) {
	    return {
	      restrict: "A",
	      controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {
	        var states = [],
	            activeClasses = {},
	            activeEqClass,
	            uiSrefActive;

	        // There probably isn't much point in $observing this
	        // uiSrefActive and uiSrefActiveEq share the same directive object with some
	        // slight difference in logic routing
	        activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);

	        try {
	          uiSrefActive = $scope.$eval($attrs.uiSrefActive);
	        } catch (e) {
	          // Do nothing. uiSrefActive is not a valid expression.
	          // Fall back to using $interpolate below
	        }
	        uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
	        if (isObject(uiSrefActive)) {
	          forEach(uiSrefActive, function (stateOrName, activeClass) {
	            if (isString(stateOrName)) {
	              var ref = parseStateRef(stateOrName, $state.current.name);
	              addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
	            }
	          });
	        }

	        // Allow uiSref to communicate with uiSrefActive[Equals]
	        this.$$addStateInfo = function (newState, newParams) {
	          // we already got an explicit state provided by ui-sref-active, so we
	          // shadow the one that comes from ui-sref
	          if (isObject(uiSrefActive) && states.length > 0) {
	            return;
	          }
	          var deregister = addState(newState, newParams, uiSrefActive);
	          update();
	          return deregister;
	        };

	        $scope.$on('$stateChangeSuccess', update);

	        function addState(stateName, stateParams, activeClass) {
	          var state = $state.get(stateName, stateContext($element));
	          var stateHash = createStateHash(stateName, stateParams);

	          var stateInfo = {
	            state: state || { name: stateName },
	            params: stateParams,
	            hash: stateHash
	          };

	          states.push(stateInfo);
	          activeClasses[stateHash] = activeClass;

	          return function removeState() {
	            var idx = states.indexOf(stateInfo);
	            if (idx !== -1) states.splice(idx, 1);
	          };
	        }

	        /**
	         * @param {string} state
	         * @param {Object|string} [params]
	         * @return {string}
	         */
	        function createStateHash(state, params) {
	          if (!isString(state)) {
	            throw new Error('state should be a string');
	          }
	          if (isObject(params)) {
	            return state + toJson(params);
	          }
	          params = $scope.$eval(params);
	          if (isObject(params)) {
	            return state + toJson(params);
	          }
	          return state;
	        }

	        // Update route state
	        function update() {
	          for (var i = 0; i < states.length; i++) {
	            if (anyMatch(states[i].state, states[i].params)) {
	              addClass($element, activeClasses[states[i].hash]);
	            } else {
	              removeClass($element, activeClasses[states[i].hash]);
	            }

	            if (exactMatch(states[i].state, states[i].params)) {
	              addClass($element, activeEqClass);
	            } else {
	              removeClass($element, activeEqClass);
	            }
	          }
	        }

	        function addClass(el, className) {
	          $timeout(function () {
	            el.addClass(className);
	          });
	        }
	        function removeClass(el, className) {
	          el.removeClass(className);
	        }
	        function anyMatch(state, params) {
	          return $state.includes(state.name, params);
	        }
	        function exactMatch(state, params) {
	          return $state.is(state.name, params);
	        }

	        update();
	      }]
	    };
	  }

	  angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective).directive('uiState', $StateRefDynamicDirective);

	  /**
	   * @ngdoc filter
	   * @name ui.router.state.filter:isState
	   *
	   * @requires ui.router.state.$state
	   *
	   * @description
	   * Translates to {@link ui.router.state.$state#methods_is $state.is("stateName")}.
	   */
	  $IsStateFilter.$inject = ['$state'];
	  function $IsStateFilter($state) {
	    var isFilter = function isFilter(state, params) {
	      return $state.is(state, params);
	    };
	    isFilter.$stateful = true;
	    return isFilter;
	  }

	  /**
	   * @ngdoc filter
	   * @name ui.router.state.filter:includedByState
	   *
	   * @requires ui.router.state.$state
	   *
	   * @description
	   * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.
	   */
	  $IncludedByStateFilter.$inject = ['$state'];
	  function $IncludedByStateFilter($state) {
	    var includesFilter = function includesFilter(state, params, options) {
	      return $state.includes(state, params, options);
	    };
	    includesFilter.$stateful = true;
	    return includesFilter;
	  }

	  angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
	})(window, window.angular);

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(80);

	module.exports = 'ui.bootstrap';

/***/ }),
/* 80 */
/***/ (function(module, exports) {

	"use strict";

	/*
	 * angular-ui-bootstrap
	 * http://angular-ui.github.io/bootstrap/

	 * Version: 2.5.6 - 2017-10-14
	 * License: MIT
	 */angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.tabindex", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.datepicker", "ui.bootstrap.position", "ui.bootstrap.datepickerPopup", "ui.bootstrap.debounce", "ui.bootstrap.multiMap", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.paging", "ui.bootstrap.pager", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"]);
	angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html", "uib/template/accordion/accordion.html", "uib/template/alert/alert.html", "uib/template/carousel/carousel.html", "uib/template/carousel/slide.html", "uib/template/datepicker/datepicker.html", "uib/template/datepicker/day.html", "uib/template/datepicker/month.html", "uib/template/datepicker/year.html", "uib/template/datepickerPopup/popup.html", "uib/template/modal/window.html", "uib/template/pager/pager.html", "uib/template/pagination/pagination.html", "uib/template/tooltip/tooltip-html-popup.html", "uib/template/tooltip/tooltip-popup.html", "uib/template/tooltip/tooltip-template-popup.html", "uib/template/popover/popover-html.html", "uib/template/popover/popover-template.html", "uib/template/popover/popover.html", "uib/template/progressbar/bar.html", "uib/template/progressbar/progress.html", "uib/template/progressbar/progressbar.html", "uib/template/rating/rating.html", "uib/template/tabs/tab.html", "uib/template/tabs/tabset.html", "uib/template/timepicker/timepicker.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html"]);
	angular.module('ui.bootstrap.collapse', []).directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function ($animate, $q, $parse, $injector) {
	  var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
	  return {
	    link: function link(scope, element, attrs) {
	      var expandingExpr = $parse(attrs.expanding),
	          expandedExpr = $parse(attrs.expanded),
	          collapsingExpr = $parse(attrs.collapsing),
	          collapsedExpr = $parse(attrs.collapsed),
	          horizontal = false,
	          css = {},
	          cssTo = {};

	      init();

	      function init() {
	        horizontal = !!('horizontal' in attrs);
	        if (horizontal) {
	          css = {
	            width: ''
	          };
	          cssTo = { width: '0' };
	        } else {
	          css = {
	            height: ''
	          };
	          cssTo = { height: '0' };
	        }
	        if (!scope.$eval(attrs.uibCollapse)) {
	          element.addClass('in').addClass('collapse').attr('aria-expanded', true).attr('aria-hidden', false).css(css);
	        }
	      }

	      function getScrollFromElement(element) {
	        if (horizontal) {
	          return { width: element.scrollWidth + 'px' };
	        }
	        return { height: element.scrollHeight + 'px' };
	      }

	      function expand() {
	        if (element.hasClass('collapse') && element.hasClass('in')) {
	          return;
	        }

	        $q.resolve(expandingExpr(scope)).then(function () {
	          element.removeClass('collapse').addClass('collapsing').attr('aria-expanded', true).attr('aria-hidden', false);

	          if ($animateCss) {
	            $animateCss(element, {
	              addClass: 'in',
	              easing: 'ease',
	              css: {
	                overflow: 'hidden'
	              },
	              to: getScrollFromElement(element[0])
	            }).start()['finally'](expandDone);
	          } else {
	            $animate.addClass(element, 'in', {
	              css: {
	                overflow: 'hidden'
	              },
	              to: getScrollFromElement(element[0])
	            }).then(expandDone);
	          }
	        }, angular.noop);
	      }

	      function expandDone() {
	        element.removeClass('collapsing').addClass('collapse').css(css);
	        expandedExpr(scope);
	      }

	      function collapse() {
	        if (!element.hasClass('collapse') && !element.hasClass('in')) {
	          return collapseDone();
	        }

	        $q.resolve(collapsingExpr(scope)).then(function () {
	          element
	          // IMPORTANT: The width must be set before adding "collapsing" class.
	          // Otherwise, the browser attempts to animate from width 0 (in
	          // collapsing class) to the given width here.
	          .css(getScrollFromElement(element[0]))
	          // initially all panel collapse have the collapse class, this removal
	          // prevents the animation from jumping to collapsed state
	          .removeClass('collapse').addClass('collapsing').attr('aria-expanded', false).attr('aria-hidden', true);

	          if ($animateCss) {
	            $animateCss(element, {
	              removeClass: 'in',
	              to: cssTo
	            }).start()['finally'](collapseDone);
	          } else {
	            $animate.removeClass(element, 'in', {
	              to: cssTo
	            }).then(collapseDone);
	          }
	        }, angular.noop);
	      }

	      function collapseDone() {
	        element.css(cssTo); // Required so that collapse works when animation is disabled
	        element.removeClass('collapsing').addClass('collapse');
	        collapsedExpr(scope);
	      }

	      scope.$watch(attrs.uibCollapse, function (shouldCollapse) {
	        if (shouldCollapse) {
	          collapse();
	        } else {
	          expand();
	        }
	      });
	    }
	  };
	}]);

	angular.module('ui.bootstrap.tabindex', []).directive('uibTabindexToggle', function () {
	  return {
	    restrict: 'A',
	    link: function link(scope, elem, attrs) {
	      attrs.$observe('disabled', function (disabled) {
	        attrs.$set('tabindex', disabled ? -1 : null);
	      });
	    }
	  };
	});

	angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse', 'ui.bootstrap.tabindex']).constant('uibAccordionConfig', {
	  closeOthers: true
	}).controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function ($scope, $attrs, accordionConfig) {
	  // This array keeps track of the accordion groups
	  this.groups = [];

	  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
	  this.closeOthers = function (openGroup) {
	    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
	    if (closeOthers) {
	      angular.forEach(this.groups, function (group) {
	        if (group !== openGroup) {
	          group.isOpen = false;
	        }
	      });
	    }
	  };

	  // This is called from the accordion-group directive to add itself to the accordion
	  this.addGroup = function (groupScope) {
	    var that = this;
	    this.groups.push(groupScope);

	    groupScope.$on('$destroy', function (event) {
	      that.removeGroup(groupScope);
	    });
	  };

	  // This is called from the accordion-group directive when to remove itself
	  this.removeGroup = function (group) {
	    var index = this.groups.indexOf(group);
	    if (index !== -1) {
	      this.groups.splice(index, 1);
	    }
	  };
	}])

	// The accordion directive simply sets up the directive controller
	// and adds an accordion CSS class to itself element.
	.directive('uibAccordion', function () {
	  return {
	    controller: 'UibAccordionController',
	    controllerAs: 'accordion',
	    transclude: true,
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.templateUrl || 'uib/template/accordion/accordion.html';
	    }
	  };
	})

	// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
	.directive('uibAccordionGroup', function () {
	  return {
	    require: '^uibAccordion', // We need this directive to be inside an accordion
	    transclude: true, // It transcludes the contents of the directive into the template
	    restrict: 'A',
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
	    },
	    scope: {
	      heading: '@', // Interpolate the heading attribute onto this scope
	      panelClass: '@?', // Ditto with panelClass
	      isOpen: '=?',
	      isDisabled: '=?'
	    },
	    controller: function controller() {
	      this.setHeading = function (element) {
	        this.heading = element;
	      };
	    },
	    link: function link(scope, element, attrs, accordionCtrl) {
	      element.addClass('panel');
	      accordionCtrl.addGroup(scope);

	      scope.openClass = attrs.openClass || 'panel-open';
	      scope.panelClass = attrs.panelClass || 'panel-default';
	      scope.$watch('isOpen', function (value) {
	        element.toggleClass(scope.openClass, !!value);
	        if (value) {
	          accordionCtrl.closeOthers(scope);
	        }
	      });

	      scope.toggleOpen = function ($event) {
	        if (!scope.isDisabled) {
	          if (!$event || $event.which === 32) {
	            scope.isOpen = !scope.isOpen;
	          }
	        }
	      };

	      var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
	      scope.headingId = id + '-tab';
	      scope.panelId = id + '-panel';
	    }
	  };
	})

	// Use accordion-heading below an accordion-group to provide a heading containing HTML
	.directive('uibAccordionHeading', function () {
	  return {
	    transclude: true, // Grab the contents to be used as the heading
	    template: '', // In effect remove this element!
	    replace: true,
	    require: '^uibAccordionGroup',
	    link: function link(scope, element, attrs, accordionGroupCtrl, transclude) {
	      // Pass the heading to the accordion-group controller
	      // so that it can be transcluded into the right place in the template
	      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
	      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
	    }
	  };
	})

	// Use in the accordion-group template to indicate where you want the heading to be transcluded
	// You must provide the property on the accordion-group controller that will hold the transcluded element
	.directive('uibAccordionTransclude', function () {
	  return {
	    require: '^uibAccordionGroup',
	    link: function link(scope, element, attrs, controller) {
	      scope.$watch(function () {
	        return controller[attrs.uibAccordionTransclude];
	      }, function (heading) {
	        if (heading) {
	          var elem = angular.element(element[0].querySelector(getHeaderSelectors()));
	          elem.html('');
	          elem.append(heading);
	        }
	      });
	    }
	  };

	  function getHeaderSelectors() {
	    return 'uib-accordion-header,' + 'data-uib-accordion-header,' + 'x-uib-accordion-header,' + 'uib\\:accordion-header,' + '[uib-accordion-header],' + '[data-uib-accordion-header],' + '[x-uib-accordion-header]';
	  }
	});

	angular.module('ui.bootstrap.alert', []).controller('UibAlertController', ['$scope', '$element', '$attrs', '$interpolate', '$timeout', function ($scope, $element, $attrs, $interpolate, $timeout) {
	  $scope.closeable = !!$attrs.close;
	  $element.addClass('alert');
	  $attrs.$set('role', 'alert');
	  if ($scope.closeable) {
	    $element.addClass('alert-dismissible');
	  }

	  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ? $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;

	  if (dismissOnTimeout) {
	    $timeout(function () {
	      $scope.close();
	    }, parseInt(dismissOnTimeout, 10));
	  }
	}]).directive('uibAlert', function () {
	  return {
	    controller: 'UibAlertController',
	    controllerAs: 'alert',
	    restrict: 'A',
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.templateUrl || 'uib/template/alert/alert.html';
	    },
	    transclude: true,
	    scope: {
	      close: '&'
	    }
	  };
	});

	angular.module('ui.bootstrap.buttons', []).constant('uibButtonConfig', {
	  activeClass: 'active',
	  toggleEvent: 'click'
	}).controller('UibButtonsController', ['uibButtonConfig', function (buttonConfig) {
	  this.activeClass = buttonConfig.activeClass || 'active';
	  this.toggleEvent = buttonConfig.toggleEvent || 'click';
	}]).directive('uibBtnRadio', ['$parse', function ($parse) {
	  return {
	    require: ['uibBtnRadio', 'ngModel'],
	    controller: 'UibButtonsController',
	    controllerAs: 'buttons',
	    link: function link(scope, element, attrs, ctrls) {
	      var buttonsCtrl = ctrls[0],
	          ngModelCtrl = ctrls[1];
	      var uncheckableExpr = $parse(attrs.uibUncheckable);

	      element.find('input').css({ display: 'none' });

	      //model -> UI
	      ngModelCtrl.$render = function () {
	        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
	      };

	      //ui->model
	      element.on(buttonsCtrl.toggleEvent, function () {
	        if (attrs.disabled) {
	          return;
	        }

	        var isActive = element.hasClass(buttonsCtrl.activeClass);

	        if (!isActive || angular.isDefined(attrs.uncheckable)) {
	          scope.$apply(function () {
	            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
	            ngModelCtrl.$render();
	          });
	        }
	      });

	      if (attrs.uibUncheckable) {
	        scope.$watch(uncheckableExpr, function (uncheckable) {
	          attrs.$set('uncheckable', uncheckable ? '' : undefined);
	        });
	      }
	    }
	  };
	}]).directive('uibBtnCheckbox', function () {
	  return {
	    require: ['uibBtnCheckbox', 'ngModel'],
	    controller: 'UibButtonsController',
	    controllerAs: 'button',
	    link: function link(scope, element, attrs, ctrls) {
	      var buttonsCtrl = ctrls[0],
	          ngModelCtrl = ctrls[1];

	      element.find('input').css({ display: 'none' });

	      function getTrueValue() {
	        return getCheckboxValue(attrs.btnCheckboxTrue, true);
	      }

	      function getFalseValue() {
	        return getCheckboxValue(attrs.btnCheckboxFalse, false);
	      }

	      function getCheckboxValue(attribute, defaultValue) {
	        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
	      }

	      //model -> UI
	      ngModelCtrl.$render = function () {
	        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
	      };

	      //ui->model
	      element.on(buttonsCtrl.toggleEvent, function () {
	        if (attrs.disabled) {
	          return;
	        }

	        scope.$apply(function () {
	          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
	          ngModelCtrl.$render();
	        });
	      });
	    }
	  };
	});

	angular.module('ui.bootstrap.carousel', []).controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function ($scope, $element, $interval, $timeout, $animate) {
	  var self = this,
	      slides = self.slides = $scope.slides = [],
	      SLIDE_DIRECTION = 'uib-slideDirection',
	      currentIndex = $scope.active,
	      currentInterval,
	      isPlaying;

	  var destroyed = false;
	  $element.addClass('carousel');

	  self.addSlide = function (slide, element) {
	    slides.push({
	      slide: slide,
	      element: element
	    });
	    slides.sort(function (a, b) {
	      return +a.slide.index - +b.slide.index;
	    });
	    //if this is the first slide or the slide is set to active, select it
	    if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {
	      if ($scope.$currentTransition) {
	        $scope.$currentTransition = null;
	      }

	      currentIndex = slide.index;
	      $scope.active = slide.index;
	      setActive(currentIndex);
	      self.select(slides[findSlideIndex(slide)]);
	      if (slides.length === 1) {
	        $scope.play();
	      }
	    }
	  };

	  self.getCurrentIndex = function () {
	    for (var i = 0; i < slides.length; i++) {
	      if (slides[i].slide.index === currentIndex) {
	        return i;
	      }
	    }
	  };

	  self.next = $scope.next = function () {
	    var newIndex = (self.getCurrentIndex() + 1) % slides.length;

	    if (newIndex === 0 && $scope.noWrap()) {
	      $scope.pause();
	      return;
	    }

	    return self.select(slides[newIndex], 'next');
	  };

	  self.prev = $scope.prev = function () {
	    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;

	    if ($scope.noWrap() && newIndex === slides.length - 1) {
	      $scope.pause();
	      return;
	    }

	    return self.select(slides[newIndex], 'prev');
	  };

	  self.removeSlide = function (slide) {
	    var index = findSlideIndex(slide);

	    //get the index of the slide inside the carousel
	    slides.splice(index, 1);
	    if (slides.length > 0 && currentIndex === index) {
	      if (index >= slides.length) {
	        currentIndex = slides.length - 1;
	        $scope.active = currentIndex;
	        setActive(currentIndex);
	        self.select(slides[slides.length - 1]);
	      } else {
	        currentIndex = index;
	        $scope.active = currentIndex;
	        setActive(currentIndex);
	        self.select(slides[index]);
	      }
	    } else if (currentIndex > index) {
	      currentIndex--;
	      $scope.active = currentIndex;
	    }

	    //clean the active value when no more slide
	    if (slides.length === 0) {
	      currentIndex = null;
	      $scope.active = null;
	    }
	  };

	  /* direction: "prev" or "next" */
	  self.select = $scope.select = function (nextSlide, direction) {
	    var nextIndex = findSlideIndex(nextSlide.slide);
	    //Decide direction if it's not given
	    if (direction === undefined) {
	      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
	    }
	    //Prevent this user-triggered transition from occurring if there is already one in progress
	    if (nextSlide.slide.index !== currentIndex && !$scope.$currentTransition) {
	      goNext(nextSlide.slide, nextIndex, direction);
	    }
	  };

	  /* Allow outside people to call indexOf on slides array */
	  $scope.indexOfSlide = function (slide) {
	    return +slide.slide.index;
	  };

	  $scope.isActive = function (slide) {
	    return $scope.active === slide.slide.index;
	  };

	  $scope.isPrevDisabled = function () {
	    return $scope.active === 0 && $scope.noWrap();
	  };

	  $scope.isNextDisabled = function () {
	    return $scope.active === slides.length - 1 && $scope.noWrap();
	  };

	  $scope.pause = function () {
	    if (!$scope.noPause) {
	      isPlaying = false;
	      resetTimer();
	    }
	  };

	  $scope.play = function () {
	    if (!isPlaying) {
	      isPlaying = true;
	      restartTimer();
	    }
	  };

	  $element.on('mouseenter', $scope.pause);
	  $element.on('mouseleave', $scope.play);

	  $scope.$on('$destroy', function () {
	    destroyed = true;
	    resetTimer();
	  });

	  $scope.$watch('noTransition', function (noTransition) {
	    $animate.enabled($element, !noTransition);
	  });

	  $scope.$watch('interval', restartTimer);

	  $scope.$watchCollection('slides', resetTransition);

	  $scope.$watch('active', function (index) {
	    if (angular.isNumber(index) && currentIndex !== index) {
	      for (var i = 0; i < slides.length; i++) {
	        if (slides[i].slide.index === index) {
	          index = i;
	          break;
	        }
	      }

	      var slide = slides[index];
	      if (slide) {
	        setActive(index);
	        self.select(slides[index]);
	        currentIndex = index;
	      }
	    }
	  });

	  function getSlideByIndex(index) {
	    for (var i = 0, l = slides.length; i < l; ++i) {
	      if (slides[i].index === index) {
	        return slides[i];
	      }
	    }
	  }

	  function setActive(index) {
	    for (var i = 0; i < slides.length; i++) {
	      slides[i].slide.active = i === index;
	    }
	  }

	  function goNext(slide, index, direction) {
	    if (destroyed) {
	      return;
	    }

	    angular.extend(slide, { direction: direction });
	    angular.extend(slides[currentIndex].slide || {}, { direction: direction });
	    if ($animate.enabled($element) && !$scope.$currentTransition && slides[index].element && self.slides.length > 1) {
	      slides[index].element.data(SLIDE_DIRECTION, slide.direction);
	      var currentIdx = self.getCurrentIndex();

	      if (angular.isNumber(currentIdx) && slides[currentIdx].element) {
	        slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
	      }

	      $scope.$currentTransition = true;
	      $animate.on('addClass', slides[index].element, function (element, phase) {
	        if (phase === 'close') {
	          $scope.$currentTransition = null;
	          $animate.off('addClass', element);
	        }
	      });
	    }

	    $scope.active = slide.index;
	    currentIndex = slide.index;
	    setActive(index);

	    //every time you change slides, reset the timer
	    restartTimer();
	  }

	  function findSlideIndex(slide) {
	    for (var i = 0; i < slides.length; i++) {
	      if (slides[i].slide === slide) {
	        return i;
	      }
	    }
	  }

	  function resetTimer() {
	    if (currentInterval) {
	      $interval.cancel(currentInterval);
	      currentInterval = null;
	    }
	  }

	  function resetTransition(slides) {
	    if (!slides.length) {
	      $scope.$currentTransition = null;
	    }
	  }

	  function restartTimer() {
	    resetTimer();
	    var interval = +$scope.interval;
	    if (!isNaN(interval) && interval > 0) {
	      currentInterval = $interval(timerFn, interval);
	    }
	  }

	  function timerFn() {
	    var interval = +$scope.interval;
	    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
	      $scope.next();
	    } else {
	      $scope.pause();
	    }
	  }
	}]).directive('uibCarousel', function () {
	  return {
	    transclude: true,
	    controller: 'UibCarouselController',
	    controllerAs: 'carousel',
	    restrict: 'A',
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.templateUrl || 'uib/template/carousel/carousel.html';
	    },
	    scope: {
	      active: '=',
	      interval: '=',
	      noTransition: '=',
	      noPause: '=',
	      noWrap: '&'
	    }
	  };
	}).directive('uibSlide', ['$animate', function ($animate) {
	  return {
	    require: '^uibCarousel',
	    restrict: 'A',
	    transclude: true,
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.templateUrl || 'uib/template/carousel/slide.html';
	    },
	    scope: {
	      actual: '=?',
	      index: '=?'
	    },
	    link: function link(scope, element, attrs, carouselCtrl) {
	      element.addClass('item');
	      carouselCtrl.addSlide(scope, element);
	      //when the scope is destroyed then remove the slide from the current slides array
	      scope.$on('$destroy', function () {
	        carouselCtrl.removeSlide(scope);
	      });

	      scope.$watch('active', function (active) {
	        $animate[active ? 'addClass' : 'removeClass'](element, 'active');
	      });
	    }
	  };
	}]).animation('.item', ['$animateCss', function ($animateCss) {
	  var SLIDE_DIRECTION = 'uib-slideDirection';

	  function removeClass(element, className, callback) {
	    element.removeClass(className);
	    if (callback) {
	      callback();
	    }
	  }

	  return {
	    beforeAddClass: function beforeAddClass(element, className, done) {
	      if (className === 'active') {
	        var stopped = false;
	        var direction = element.data(SLIDE_DIRECTION);
	        var directionClass = direction === 'next' ? 'left' : 'right';
	        var removeClassFn = removeClass.bind(this, element, directionClass + ' ' + direction, done);
	        element.addClass(direction);

	        $animateCss(element, { addClass: directionClass }).start().done(removeClassFn);

	        return function () {
	          stopped = true;
	        };
	      }
	      done();
	    },
	    beforeRemoveClass: function beforeRemoveClass(element, className, done) {
	      if (className === 'active') {
	        var stopped = false;
	        var direction = element.data(SLIDE_DIRECTION);
	        var directionClass = direction === 'next' ? 'left' : 'right';
	        var removeClassFn = removeClass.bind(this, element, directionClass, done);

	        $animateCss(element, { addClass: directionClass }).start().done(removeClassFn);

	        return function () {
	          stopped = true;
	        };
	      }
	      done();
	    }
	  };
	}]);

	angular.module('ui.bootstrap.dateparser', []).service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', 'filterFilter', function ($log, $locale, dateFilter, orderByFilter, filterFilter) {
	  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
	  var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

	  var localeId;
	  var formatCodeToRegex;

	  this.init = function () {
	    localeId = $locale.id;

	    this.parsers = {};
	    this.formatters = {};

	    formatCodeToRegex = [{
	      key: 'yyyy',
	      regex: '\\d{4}',
	      apply: function apply(value) {
	        this.year = +value;
	      },
	      formatter: function formatter(date) {
	        var _date = new Date();
	        _date.setFullYear(Math.abs(date.getFullYear()));
	        return dateFilter(_date, 'yyyy');
	      }
	    }, {
	      key: 'yy',
	      regex: '\\d{2}',
	      apply: function apply(value) {
	        value = +value;this.year = value < 69 ? value + 2000 : value + 1900;
	      },
	      formatter: function formatter(date) {
	        var _date = new Date();
	        _date.setFullYear(Math.abs(date.getFullYear()));
	        return dateFilter(_date, 'yy');
	      }
	    }, {
	      key: 'y',
	      regex: '\\d{1,4}',
	      apply: function apply(value) {
	        this.year = +value;
	      },
	      formatter: function formatter(date) {
	        var _date = new Date();
	        _date.setFullYear(Math.abs(date.getFullYear()));
	        return dateFilter(_date, 'y');
	      }
	    }, {
	      key: 'M!',
	      regex: '0?[1-9]|1[0-2]',
	      apply: function apply(value) {
	        this.month = value - 1;
	      },
	      formatter: function formatter(date) {
	        var value = date.getMonth();
	        if (/^[0-9]$/.test(value)) {
	          return dateFilter(date, 'MM');
	        }

	        return dateFilter(date, 'M');
	      }
	    }, {
	      key: 'MMMM',
	      regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
	      apply: function apply(value) {
	        this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'MMMM');
	      }
	    }, {
	      key: 'MMM',
	      regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
	      apply: function apply(value) {
	        this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'MMM');
	      }
	    }, {
	      key: 'MM',
	      regex: '0[1-9]|1[0-2]',
	      apply: function apply(value) {
	        this.month = value - 1;
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'MM');
	      }
	    }, {
	      key: 'M',
	      regex: '[1-9]|1[0-2]',
	      apply: function apply(value) {
	        this.month = value - 1;
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'M');
	      }
	    }, {
	      key: 'd!',
	      regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
	      apply: function apply(value) {
	        this.date = +value;
	      },
	      formatter: function formatter(date) {
	        var value = date.getDate();
	        if (/^[1-9]$/.test(value)) {
	          return dateFilter(date, 'dd');
	        }

	        return dateFilter(date, 'd');
	      }
	    }, {
	      key: 'dd',
	      regex: '[0-2][0-9]{1}|3[0-1]{1}',
	      apply: function apply(value) {
	        this.date = +value;
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'dd');
	      }
	    }, {
	      key: 'd',
	      regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
	      apply: function apply(value) {
	        this.date = +value;
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'd');
	      }
	    }, {
	      key: 'EEEE',
	      regex: $locale.DATETIME_FORMATS.DAY.join('|'),
	      formatter: function formatter(date) {
	        return dateFilter(date, 'EEEE');
	      }
	    }, {
	      key: 'EEE',
	      regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
	      formatter: function formatter(date) {
	        return dateFilter(date, 'EEE');
	      }
	    }, {
	      key: 'HH',
	      regex: '(?:0|1)[0-9]|2[0-3]',
	      apply: function apply(value) {
	        this.hours = +value;
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'HH');
	      }
	    }, {
	      key: 'hh',
	      regex: '0[0-9]|1[0-2]',
	      apply: function apply(value) {
	        this.hours = +value;
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'hh');
	      }
	    }, {
	      key: 'H',
	      regex: '1?[0-9]|2[0-3]',
	      apply: function apply(value) {
	        this.hours = +value;
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'H');
	      }
	    }, {
	      key: 'h',
	      regex: '[0-9]|1[0-2]',
	      apply: function apply(value) {
	        this.hours = +value;
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'h');
	      }
	    }, {
	      key: 'mm',
	      regex: '[0-5][0-9]',
	      apply: function apply(value) {
	        this.minutes = +value;
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'mm');
	      }
	    }, {
	      key: 'm',
	      regex: '[0-9]|[1-5][0-9]',
	      apply: function apply(value) {
	        this.minutes = +value;
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'm');
	      }
	    }, {
	      key: 'sss',
	      regex: '[0-9][0-9][0-9]',
	      apply: function apply(value) {
	        this.milliseconds = +value;
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'sss');
	      }
	    }, {
	      key: 'ss',
	      regex: '[0-5][0-9]',
	      apply: function apply(value) {
	        this.seconds = +value;
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'ss');
	      }
	    }, {
	      key: 's',
	      regex: '[0-9]|[1-5][0-9]',
	      apply: function apply(value) {
	        this.seconds = +value;
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 's');
	      }
	    }, {
	      key: 'a',
	      regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
	      apply: function apply(value) {
	        if (this.hours === 12) {
	          this.hours = 0;
	        }

	        if (value === 'PM') {
	          this.hours += 12;
	        }
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'a');
	      }
	    }, {
	      key: 'Z',
	      regex: '[+-]\\d{4}',
	      apply: function apply(value) {
	        var matches = value.match(/([+-])(\d{2})(\d{2})/),
	            sign = matches[1],
	            hours = matches[2],
	            minutes = matches[3];
	        this.hours += toInt(sign + hours);
	        this.minutes += toInt(sign + minutes);
	      },
	      formatter: function formatter(date) {
	        return dateFilter(date, 'Z');
	      }
	    }, {
	      key: 'ww',
	      regex: '[0-4][0-9]|5[0-3]',
	      formatter: function formatter(date) {
	        return dateFilter(date, 'ww');
	      }
	    }, {
	      key: 'w',
	      regex: '[0-9]|[1-4][0-9]|5[0-3]',
	      formatter: function formatter(date) {
	        return dateFilter(date, 'w');
	      }
	    }, {
	      key: 'GGGG',
	      regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
	      formatter: function formatter(date) {
	        return dateFilter(date, 'GGGG');
	      }
	    }, {
	      key: 'GGG',
	      regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
	      formatter: function formatter(date) {
	        return dateFilter(date, 'GGG');
	      }
	    }, {
	      key: 'GG',
	      regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
	      formatter: function formatter(date) {
	        return dateFilter(date, 'GG');
	      }
	    }, {
	      key: 'G',
	      regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
	      formatter: function formatter(date) {
	        return dateFilter(date, 'G');
	      }
	    }];

	    if (angular.version.major >= 1 && angular.version.minor > 4) {
	      formatCodeToRegex.push({
	        key: 'LLLL',
	        regex: $locale.DATETIME_FORMATS.STANDALONEMONTH.join('|'),
	        apply: function apply(value) {
	          this.month = $locale.DATETIME_FORMATS.STANDALONEMONTH.indexOf(value);
	        },
	        formatter: function formatter(date) {
	          return dateFilter(date, 'LLLL');
	        }
	      });
	    }
	  };

	  this.init();

	  function getFormatCodeToRegex(key) {
	    return filterFilter(formatCodeToRegex, { key: key }, true)[0];
	  }

	  this.getParser = function (key) {
	    var f = getFormatCodeToRegex(key);
	    return f && f.apply || null;
	  };

	  this.overrideParser = function (key, parser) {
	    var f = getFormatCodeToRegex(key);
	    if (f && angular.isFunction(parser)) {
	      this.parsers = {};
	      f.apply = parser;
	    }
	  }.bind(this);

	  function createParser(format) {
	    var map = [],
	        regex = format.split('');

	    // check for literal values
	    var quoteIndex = format.indexOf('\'');
	    if (quoteIndex > -1) {
	      var inLiteral = false;
	      format = format.split('');
	      for (var i = quoteIndex; i < format.length; i++) {
	        if (inLiteral) {
	          if (format[i] === '\'') {
	            if (i + 1 < format.length && format[i + 1] === '\'') {
	              // escaped single quote
	              format[i + 1] = '$';
	              regex[i + 1] = '';
	            } else {
	              // end of literal
	              regex[i] = '';
	              inLiteral = false;
	            }
	          }
	          format[i] = '$';
	        } else {
	          if (format[i] === '\'') {
	            // start of literal
	            format[i] = '$';
	            regex[i] = '';
	            inLiteral = true;
	          }
	        }
	      }

	      format = format.join('');
	    }

	    angular.forEach(formatCodeToRegex, function (data) {
	      var index = format.indexOf(data.key);

	      if (index > -1) {
	        format = format.split('');

	        regex[index] = '(' + data.regex + ')';
	        format[index] = '$'; // Custom symbol to define consumed part of format
	        for (var i = index + 1, n = index + data.key.length; i < n; i++) {
	          regex[i] = '';
	          format[i] = '$';
	        }
	        format = format.join('');

	        map.push({
	          index: index,
	          key: data.key,
	          apply: data.apply,
	          matcher: data.regex
	        });
	      }
	    });

	    return {
	      regex: new RegExp('^' + regex.join('') + '$'),
	      map: orderByFilter(map, 'index')
	    };
	  }

	  function createFormatter(format) {
	    var formatters = [];
	    var i = 0;
	    var formatter, literalIdx;
	    while (i < format.length) {
	      if (angular.isNumber(literalIdx)) {
	        if (format.charAt(i) === '\'') {
	          if (i + 1 >= format.length || format.charAt(i + 1) !== '\'') {
	            formatters.push(constructLiteralFormatter(format, literalIdx, i));
	            literalIdx = null;
	          }
	        } else if (i === format.length) {
	          while (literalIdx < format.length) {
	            formatter = constructFormatterFromIdx(format, literalIdx);
	            formatters.push(formatter);
	            literalIdx = formatter.endIdx;
	          }
	        }

	        i++;
	        continue;
	      }

	      if (format.charAt(i) === '\'') {
	        literalIdx = i;
	        i++;
	        continue;
	      }

	      formatter = constructFormatterFromIdx(format, i);

	      formatters.push(formatter.parser);
	      i = formatter.endIdx;
	    }

	    return formatters;
	  }

	  function constructLiteralFormatter(format, literalIdx, endIdx) {
	    return function () {
	      return format.substr(literalIdx + 1, endIdx - literalIdx - 1);
	    };
	  }

	  function constructFormatterFromIdx(format, i) {
	    var currentPosStr = format.substr(i);
	    for (var j = 0; j < formatCodeToRegex.length; j++) {
	      if (new RegExp('^' + formatCodeToRegex[j].key).test(currentPosStr)) {
	        var data = formatCodeToRegex[j];
	        return {
	          endIdx: i + data.key.length,
	          parser: data.formatter
	        };
	      }
	    }

	    return {
	      endIdx: i + 1,
	      parser: function parser() {
	        return currentPosStr.charAt(0);
	      }
	    };
	  }

	  this.filter = function (date, format) {
	    if (!angular.isDate(date) || isNaN(date) || !format) {
	      return '';
	    }

	    format = $locale.DATETIME_FORMATS[format] || format;

	    if ($locale.id !== localeId) {
	      this.init();
	    }

	    if (!this.formatters[format]) {
	      this.formatters[format] = createFormatter(format);
	    }

	    var formatters = this.formatters[format];

	    return formatters.reduce(function (str, formatter) {
	      return str + formatter(date);
	    }, '');
	  };

	  this.parse = function (input, format, baseDate) {
	    if (!angular.isString(input) || !format) {
	      return input;
	    }

	    format = $locale.DATETIME_FORMATS[format] || format;
	    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');

	    if ($locale.id !== localeId) {
	      this.init();
	    }

	    if (!this.parsers[format]) {
	      this.parsers[format] = createParser(format, 'apply');
	    }

	    var parser = this.parsers[format],
	        regex = parser.regex,
	        map = parser.map,
	        results = input.match(regex),
	        tzOffset = false;
	    if (results && results.length) {
	      var fields, dt;
	      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
	        fields = {
	          year: baseDate.getFullYear(),
	          month: baseDate.getMonth(),
	          date: baseDate.getDate(),
	          hours: baseDate.getHours(),
	          minutes: baseDate.getMinutes(),
	          seconds: baseDate.getSeconds(),
	          milliseconds: baseDate.getMilliseconds()
	        };
	      } else {
	        if (baseDate) {
	          $log.warn('dateparser:', 'baseDate is not a valid date');
	        }
	        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
	      }

	      for (var i = 1, n = results.length; i < n; i++) {
	        var mapper = map[i - 1];
	        if (mapper.matcher === 'Z') {
	          tzOffset = true;
	        }

	        if (mapper.apply) {
	          mapper.apply.call(fields, results[i]);
	        }
	      }

	      var datesetter = tzOffset ? Date.prototype.setUTCFullYear : Date.prototype.setFullYear;
	      var timesetter = tzOffset ? Date.prototype.setUTCHours : Date.prototype.setHours;

	      if (isValid(fields.year, fields.month, fields.date)) {
	        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
	          dt = new Date(baseDate);
	          datesetter.call(dt, fields.year, fields.month, fields.date);
	          timesetter.call(dt, fields.hours, fields.minutes, fields.seconds, fields.milliseconds);
	        } else {
	          dt = new Date(0);
	          datesetter.call(dt, fields.year, fields.month, fields.date);
	          timesetter.call(dt, fields.hours || 0, fields.minutes || 0, fields.seconds || 0, fields.milliseconds || 0);
	        }
	      }

	      return dt;
	    }
	  };

	  // Check if date is valid for specific month (and year for February).
	  // Month: 0 = Jan, 1 = Feb, etc
	  function isValid(year, month, date) {
	    if (date < 1) {
	      return false;
	    }

	    if (month === 1 && date > 28) {
	      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
	    }

	    if (month === 3 || month === 5 || month === 8 || month === 10) {
	      return date < 31;
	    }

	    return true;
	  }

	  function toInt(str) {
	    return parseInt(str, 10);
	  }

	  this.toTimezone = toTimezone;
	  this.fromTimezone = fromTimezone;
	  this.timezoneToOffset = timezoneToOffset;
	  this.addDateMinutes = addDateMinutes;
	  this.convertTimezoneToLocal = convertTimezoneToLocal;

	  function toTimezone(date, timezone) {
	    return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
	  }

	  function fromTimezone(date, timezone) {
	    return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
	  }

	  //https://github.com/angular/angular.js/blob/622c42169699ec07fc6daaa19fe6d224e5d2f70e/src/Angular.js#L1207
	  function timezoneToOffset(timezone, fallback) {
	    timezone = timezone.replace(/:/g, '');
	    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
	    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
	  }

	  function addDateMinutes(date, minutes) {
	    date = new Date(date.getTime());
	    date.setMinutes(date.getMinutes() + minutes);
	    return date;
	  }

	  function convertTimezoneToLocal(date, timezone, reverse) {
	    reverse = reverse ? -1 : 1;
	    var dateTimezoneOffset = date.getTimezoneOffset();
	    var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
	    return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
	  }
	}]);

	// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to
	// at most one element.
	angular.module('ui.bootstrap.isClass', []).directive('uibIsClass', ['$animate', function ($animate) {
	  //                    11111111          22222222
	  var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
	  //                    11111111           22222222
	  var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;

	  var dataPerTracked = {};

	  return {
	    restrict: 'A',
	    compile: function compile(tElement, tAttrs) {
	      var linkedScopes = [];
	      var instances = [];
	      var expToData = {};
	      var lastActivated = null;
	      var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
	      var onExp = onExpMatches[2];
	      var expsStr = onExpMatches[1];
	      var exps = expsStr.split(',');

	      return linkFn;

	      function linkFn(scope, element, attrs) {
	        linkedScopes.push(scope);
	        instances.push({
	          scope: scope,
	          element: element
	        });

	        exps.forEach(function (exp, k) {
	          addForExp(exp, scope);
	        });

	        scope.$on('$destroy', removeScope);
	      }

	      function addForExp(exp, scope) {
	        var matches = exp.match(IS_REGEXP);
	        var clazz = scope.$eval(matches[1]);
	        var compareWithExp = matches[2];
	        var data = expToData[exp];
	        if (!data) {
	          var watchFn = function watchFn(compareWithVal) {
	            var newActivated = null;
	            instances.some(function (instance) {
	              var thisVal = instance.scope.$eval(onExp);
	              if (thisVal === compareWithVal) {
	                newActivated = instance;
	                return true;
	              }
	            });
	            if (data.lastActivated !== newActivated) {
	              if (data.lastActivated) {
	                $animate.removeClass(data.lastActivated.element, clazz);
	              }
	              if (newActivated) {
	                $animate.addClass(newActivated.element, clazz);
	              }
	              data.lastActivated = newActivated;
	            }
	          };
	          expToData[exp] = data = {
	            lastActivated: null,
	            scope: scope,
	            watchFn: watchFn,
	            compareWithExp: compareWithExp,
	            watcher: scope.$watch(compareWithExp, watchFn)
	          };
	        }
	        data.watchFn(scope.$eval(compareWithExp));
	      }

	      function removeScope(e) {
	        var removedScope = e.targetScope;
	        var index = linkedScopes.indexOf(removedScope);
	        linkedScopes.splice(index, 1);
	        instances.splice(index, 1);
	        if (linkedScopes.length) {
	          var newWatchScope = linkedScopes[0];
	          angular.forEach(expToData, function (data) {
	            if (data.scope === removedScope) {
	              data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
	              data.scope = newWatchScope;
	            }
	          });
	        } else {
	          expToData = {};
	        }
	      }
	    }
	  };
	}]);
	angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass']).value('$datepickerSuppressError', false).value('$datepickerLiteralWarning', true).constant('uibDatepickerConfig', {
	  datepickerMode: 'day',
	  formatDay: 'dd',
	  formatMonth: 'MMMM',
	  formatYear: 'yyyy',
	  formatDayHeader: 'EEE',
	  formatDayTitle: 'MMMM yyyy',
	  formatMonthTitle: 'yyyy',
	  maxDate: null,
	  maxMode: 'year',
	  minDate: null,
	  minMode: 'day',
	  monthColumns: 3,
	  ngModelOptions: {},
	  shortcutPropagation: false,
	  showWeeks: true,
	  yearColumns: 5,
	  yearRows: 4
	}).controller('UibDatepickerController', ['$scope', '$element', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser', function ($scope, $element, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
	  var self = this,
	      ngModelCtrl = { $setViewValue: angular.noop },
	      // nullModelCtrl;
	  ngModelOptions = {},
	      watchListeners = [];

	  $element.addClass('uib-datepicker');
	  $attrs.$set('role', 'application');

	  if (!$scope.datepickerOptions) {
	    $scope.datepickerOptions = {};
	  }

	  // Modes chain
	  this.modes = ['day', 'month', 'year'];

	  ['customClass', 'dateDisabled', 'datepickerMode', 'formatDay', 'formatDayHeader', 'formatDayTitle', 'formatMonth', 'formatMonthTitle', 'formatYear', 'maxDate', 'maxMode', 'minDate', 'minMode', 'monthColumns', 'showWeeks', 'shortcutPropagation', 'startingDay', 'yearColumns', 'yearRows'].forEach(function (key) {
	    switch (key) {
	      case 'customClass':
	      case 'dateDisabled':
	        $scope[key] = $scope.datepickerOptions[key] || angular.noop;
	        break;
	      case 'datepickerMode':
	        $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ? $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
	        break;
	      case 'formatDay':
	      case 'formatDayHeader':
	      case 'formatDayTitle':
	      case 'formatMonth':
	      case 'formatMonthTitle':
	      case 'formatYear':
	        self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $interpolate($scope.datepickerOptions[key])($scope.$parent) : datepickerConfig[key];
	        break;
	      case 'monthColumns':
	      case 'showWeeks':
	      case 'shortcutPropagation':
	      case 'yearColumns':
	      case 'yearRows':
	        self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $scope.datepickerOptions[key] : datepickerConfig[key];
	        break;
	      case 'startingDay':
	        if (angular.isDefined($scope.datepickerOptions.startingDay)) {
	          self.startingDay = $scope.datepickerOptions.startingDay;
	        } else if (angular.isNumber(datepickerConfig.startingDay)) {
	          self.startingDay = datepickerConfig.startingDay;
	        } else {
	          self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
	        }

	        break;
	      case 'maxDate':
	      case 'minDate':
	        $scope.$watch('datepickerOptions.' + key, function (value) {
	          if (value) {
	            if (angular.isDate(value)) {
	              self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.getOption('timezone'));
	            } else {
	              if ($datepickerLiteralWarning) {
	                $log.warn('Literal date support has been deprecated, please switch to date object usage');
	              }

	              self[key] = new Date(dateFilter(value, 'medium'));
	            }
	          } else {
	            self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.getOption('timezone')) : null;
	          }

	          self.refreshView();
	        });

	        break;
	      case 'maxMode':
	      case 'minMode':
	        if ($scope.datepickerOptions[key]) {
	          $scope.$watch(function () {
	            return $scope.datepickerOptions[key];
	          }, function (value) {
	            self[key] = $scope[key] = angular.isDefined(value) ? value : $scope.datepickerOptions[key];
	            if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) || key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {
	              $scope.datepickerMode = self[key];
	              $scope.datepickerOptions.datepickerMode = self[key];
	            }
	          });
	        } else {
	          self[key] = $scope[key] = datepickerConfig[key] || null;
	        }

	        break;
	    }
	  });

	  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

	  $scope.disabled = angular.isDefined($attrs.disabled) || false;
	  if (angular.isDefined($attrs.ngDisabled)) {
	    watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function (disabled) {
	      $scope.disabled = disabled;
	      self.refreshView();
	    }));
	  }

	  $scope.isActive = function (dateObject) {
	    if (self.compare(dateObject.date, self.activeDate) === 0) {
	      $scope.activeDateId = dateObject.uid;
	      return true;
	    }
	    return false;
	  };

	  this.init = function (ngModelCtrl_) {
	    ngModelCtrl = ngModelCtrl_;
	    ngModelOptions = extractOptions(ngModelCtrl);

	    if ($scope.datepickerOptions.initDate) {
	      self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.getOption('timezone')) || new Date();
	      $scope.$watch('datepickerOptions.initDate', function (initDate) {
	        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
	          self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.getOption('timezone'));
	          self.refreshView();
	        }
	      });
	    } else {
	      self.activeDate = new Date();
	    }

	    var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();
	    this.activeDate = !isNaN(date) ? dateParser.fromTimezone(date, ngModelOptions.getOption('timezone')) : dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));

	    ngModelCtrl.$render = function () {
	      self.render();
	    };
	  };

	  this.render = function () {
	    if (ngModelCtrl.$viewValue) {
	      var date = new Date(ngModelCtrl.$viewValue),
	          isValid = !isNaN(date);

	      if (isValid) {
	        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));
	      } else if (!$datepickerSuppressError) {
	        $log.error('Datepicker directive: "ng-model" value must be a Date object');
	      }
	    }
	    this.refreshView();
	  };

	  this.refreshView = function () {
	    if (this.element) {
	      $scope.selectedDt = null;
	      this._refreshView();
	      if ($scope.activeDt) {
	        $scope.activeDateId = $scope.activeDt.uid;
	      }

	      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
	      date = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));
	      ngModelCtrl.$setValidity('dateDisabled', !date || this.element && !this.isDisabled(date));
	    }
	  };

	  this.createDateObject = function (date, format) {
	    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
	    model = dateParser.fromTimezone(model, ngModelOptions.getOption('timezone'));
	    var today = new Date();
	    today = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));
	    var time = this.compare(date, today);
	    var dt = {
	      date: date,
	      label: dateParser.filter(date, format),
	      selected: model && this.compare(date, model) === 0,
	      disabled: this.isDisabled(date),
	      past: time < 0,
	      current: time === 0,
	      future: time > 0,
	      customClass: this.customClass(date) || null
	    };

	    if (model && this.compare(date, model) === 0) {
	      $scope.selectedDt = dt;
	    }

	    if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
	      $scope.activeDt = dt;
	    }

	    return dt;
	  };

	  this.isDisabled = function (date) {
	    return $scope.disabled || this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $scope.dateDisabled && $scope.dateDisabled({ date: date, mode: $scope.datepickerMode });
	  };

	  this.customClass = function (date) {
	    return $scope.customClass({ date: date, mode: $scope.datepickerMode });
	  };

	  // Split array into smaller arrays
	  this.split = function (arr, size) {
	    var arrays = [];
	    while (arr.length > 0) {
	      arrays.push(arr.splice(0, size));
	    }
	    return arrays;
	  };

	  $scope.select = function (date) {
	    if ($scope.datepickerMode === self.minMode) {
	      var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.getOption('timezone')) : new Date(0, 0, 0, 0, 0, 0, 0);
	      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	      dt = dateParser.toTimezone(dt, ngModelOptions.getOption('timezone'));
	      ngModelCtrl.$setViewValue(dt);
	      ngModelCtrl.$render();
	    } else {
	      self.activeDate = date;
	      setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);

	      $scope.$emit('uib:datepicker.mode');
	    }

	    $scope.$broadcast('uib:datepicker.focus');
	  };

	  $scope.move = function (direction) {
	    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
	        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
	    self.activeDate.setFullYear(year, month, 1);
	    self.refreshView();
	  };

	  $scope.toggleMode = function (direction) {
	    direction = direction || 1;

	    if ($scope.datepickerMode === self.maxMode && direction === 1 || $scope.datepickerMode === self.minMode && direction === -1) {
	      return;
	    }

	    setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);

	    $scope.$emit('uib:datepicker.mode');
	  };

	  // Key event mapper
	  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

	  var focusElement = function focusElement() {
	    self.element[0].focus();
	  };

	  // Listen for focus requests from popup directive
	  $scope.$on('uib:datepicker.focus', focusElement);

	  $scope.keydown = function (evt) {
	    var key = $scope.keys[evt.which];

	    if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
	      return;
	    }

	    evt.preventDefault();
	    if (!self.shortcutPropagation) {
	      evt.stopPropagation();
	    }

	    if (key === 'enter' || key === 'space') {
	      if (self.isDisabled(self.activeDate)) {
	        return; // do nothing
	      }
	      $scope.select(self.activeDate);
	    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
	      $scope.toggleMode(key === 'up' ? 1 : -1);
	    } else {
	      self.handleKeyDown(key, evt);
	      self.refreshView();
	    }
	  };

	  $element.on('keydown', function (evt) {
	    $scope.$apply(function () {
	      $scope.keydown(evt);
	    });
	  });

	  $scope.$on('$destroy', function () {
	    //Clear all watch listeners on destroy
	    while (watchListeners.length) {
	      watchListeners.shift()();
	    }
	  });

	  function setMode(mode) {
	    $scope.datepickerMode = mode;
	    $scope.datepickerOptions.datepickerMode = mode;
	  }

	  function extractOptions(ngModelCtrl) {
	    var ngModelOptions;

	    if (angular.version.minor < 6) {
	      // in angular < 1.6 $options could be missing
	      // guarantee a value
	      ngModelOptions = ngModelCtrl.$options || $scope.datepickerOptions.ngModelOptions || datepickerConfig.ngModelOptions || {};

	      // mimic 1.6+ api
	      ngModelOptions.getOption = function (key) {
	        return ngModelOptions[key];
	      };
	    } else {
	      // in angular >=1.6 $options is always present
	      // ng-model-options defaults timezone to null; don't let its precedence squash a non-null value
	      var timezone = ngModelCtrl.$options.getOption('timezone') || ($scope.datepickerOptions.ngModelOptions ? $scope.datepickerOptions.ngModelOptions.timezone : null) || (datepickerConfig.ngModelOptions ? datepickerConfig.ngModelOptions.timezone : null);

	      // values passed to createChild override existing values
	      ngModelOptions = ngModelCtrl.$options // start with a ModelOptions instance
	      .createChild(datepickerConfig.ngModelOptions) // lowest precedence
	      .createChild($scope.datepickerOptions.ngModelOptions).createChild(ngModelCtrl.$options) // highest precedence
	      .createChild({ timezone: timezone }); // to keep from squashing a non-null value
	    }

	    return ngModelOptions;
	  }
	}]).controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
	  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

	  this.step = { months: 1 };
	  this.element = $element;
	  function getDaysInMonth(year, month) {
	    return month === 1 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
	  }

	  this.init = function (ctrl) {
	    angular.extend(ctrl, this);
	    scope.showWeeks = ctrl.showWeeks;
	    ctrl.refreshView();
	  };

	  this.getDates = function (startDate, n) {
	    var dates = new Array(n),
	        current = new Date(startDate),
	        i = 0,
	        date;
	    while (i < n) {
	      date = new Date(current);
	      dates[i++] = date;
	      current.setDate(current.getDate() + 1);
	    }
	    return dates;
	  };

	  this._refreshView = function () {
	    var year = this.activeDate.getFullYear(),
	        month = this.activeDate.getMonth(),
	        firstDayOfMonth = new Date(this.activeDate);

	    firstDayOfMonth.setFullYear(year, month, 1);

	    var difference = this.startingDay - firstDayOfMonth.getDay(),
	        numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference,
	        firstDate = new Date(firstDayOfMonth);

	    if (numDisplayedFromPreviousMonth > 0) {
	      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
	    }

	    // 42 is the number of days on a six-week calendar
	    var days = this.getDates(firstDate, 42);
	    for (var i = 0; i < 42; i++) {
	      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
	        secondary: days[i].getMonth() !== month,
	        uid: scope.uniqueId + '-' + i
	      });
	    }

	    scope.labels = new Array(7);
	    for (var j = 0; j < 7; j++) {
	      scope.labels[j] = {
	        abbr: dateFilter(days[j].date, this.formatDayHeader),
	        full: dateFilter(days[j].date, 'EEEE')
	      };
	    }

	    scope.title = dateFilter(this.activeDate, this.formatDayTitle);
	    scope.rows = this.split(days, 7);

	    if (scope.showWeeks) {
	      scope.weekNumbers = [];
	      var thursdayIndex = (4 + 7 - this.startingDay) % 7,
	          numWeeks = scope.rows.length;
	      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
	        scope.weekNumbers.push(getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
	      }
	    }
	  };

	  this.compare = function (date1, date2) {
	    var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
	    var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
	    _date1.setFullYear(date1.getFullYear());
	    _date2.setFullYear(date2.getFullYear());
	    return _date1 - _date2;
	  };

	  function getISO8601WeekNumber(date) {
	    var checkDate = new Date(date);
	    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
	    var time = checkDate.getTime();
	    checkDate.setMonth(0); // Compare with Jan 1
	    checkDate.setDate(1);
	    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	  }

	  this.handleKeyDown = function (key, evt) {
	    var date = this.activeDate.getDate();

	    if (key === 'left') {
	      date = date - 1;
	    } else if (key === 'up') {
	      date = date - 7;
	    } else if (key === 'right') {
	      date = date + 1;
	    } else if (key === 'down') {
	      date = date + 7;
	    } else if (key === 'pageup' || key === 'pagedown') {
	      var month = this.activeDate.getMonth() + (key === 'pageup' ? -1 : 1);
	      this.activeDate.setMonth(month, 1);
	      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
	    } else if (key === 'home') {
	      date = 1;
	    } else if (key === 'end') {
	      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
	    }
	    this.activeDate.setDate(date);
	  };
	}]).controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
	  this.step = { years: 1 };
	  this.element = $element;

	  this.init = function (ctrl) {
	    angular.extend(ctrl, this);
	    ctrl.refreshView();
	  };

	  this._refreshView = function () {
	    var months = new Array(12),
	        year = this.activeDate.getFullYear(),
	        date;

	    for (var i = 0; i < 12; i++) {
	      date = new Date(this.activeDate);
	      date.setFullYear(year, i, 1);
	      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
	        uid: scope.uniqueId + '-' + i
	      });
	    }

	    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
	    scope.rows = this.split(months, this.monthColumns);
	    scope.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1;
	  };

	  this.compare = function (date1, date2) {
	    var _date1 = new Date(date1.getFullYear(), date1.getMonth());
	    var _date2 = new Date(date2.getFullYear(), date2.getMonth());
	    _date1.setFullYear(date1.getFullYear());
	    _date2.setFullYear(date2.getFullYear());
	    return _date1 - _date2;
	  };

	  this.handleKeyDown = function (key, evt) {
	    var date = this.activeDate.getMonth();

	    if (key === 'left') {
	      date = date - 1;
	    } else if (key === 'up') {
	      date = date - this.monthColumns;
	    } else if (key === 'right') {
	      date = date + 1;
	    } else if (key === 'down') {
	      date = date + this.monthColumns;
	    } else if (key === 'pageup' || key === 'pagedown') {
	      var year = this.activeDate.getFullYear() + (key === 'pageup' ? -1 : 1);
	      this.activeDate.setFullYear(year);
	    } else if (key === 'home') {
	      date = 0;
	    } else if (key === 'end') {
	      date = 11;
	    }
	    this.activeDate.setMonth(date);
	  };
	}]).controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
	  var columns, range;
	  this.element = $element;

	  function getStartingYear(year) {
	    return parseInt((year - 1) / range, 10) * range + 1;
	  }

	  this.yearpickerInit = function () {
	    columns = this.yearColumns;
	    range = this.yearRows * columns;
	    this.step = { years: range };
	  };

	  this._refreshView = function () {
	    var years = new Array(range),
	        date;

	    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
	      date = new Date(this.activeDate);
	      date.setFullYear(start + i, 0, 1);
	      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
	        uid: scope.uniqueId + '-' + i
	      });
	    }

	    scope.title = [years[0].label, years[range - 1].label].join(' - ');
	    scope.rows = this.split(years, columns);
	    scope.columns = columns;
	  };

	  this.compare = function (date1, date2) {
	    return date1.getFullYear() - date2.getFullYear();
	  };

	  this.handleKeyDown = function (key, evt) {
	    var date = this.activeDate.getFullYear();

	    if (key === 'left') {
	      date = date - 1;
	    } else if (key === 'up') {
	      date = date - columns;
	    } else if (key === 'right') {
	      date = date + 1;
	    } else if (key === 'down') {
	      date = date + columns;
	    } else if (key === 'pageup' || key === 'pagedown') {
	      date += (key === 'pageup' ? -1 : 1) * range;
	    } else if (key === 'home') {
	      date = getStartingYear(this.activeDate.getFullYear());
	    } else if (key === 'end') {
	      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
	    }
	    this.activeDate.setFullYear(date);
	  };
	}]).directive('uibDatepicker', function () {
	  return {
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
	    },
	    scope: {
	      datepickerOptions: '=?'
	    },
	    require: ['uibDatepicker', '^ngModel'],
	    restrict: 'A',
	    controller: 'UibDatepickerController',
	    controllerAs: 'datepicker',
	    link: function link(scope, element, attrs, ctrls) {
	      var datepickerCtrl = ctrls[0],
	          ngModelCtrl = ctrls[1];

	      datepickerCtrl.init(ngModelCtrl);
	    }
	  };
	}).directive('uibDaypicker', function () {
	  return {
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.templateUrl || 'uib/template/datepicker/day.html';
	    },
	    require: ['^uibDatepicker', 'uibDaypicker'],
	    restrict: 'A',
	    controller: 'UibDaypickerController',
	    link: function link(scope, element, attrs, ctrls) {
	      var datepickerCtrl = ctrls[0],
	          daypickerCtrl = ctrls[1];

	      daypickerCtrl.init(datepickerCtrl);
	    }
	  };
	}).directive('uibMonthpicker', function () {
	  return {
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.templateUrl || 'uib/template/datepicker/month.html';
	    },
	    require: ['^uibDatepicker', 'uibMonthpicker'],
	    restrict: 'A',
	    controller: 'UibMonthpickerController',
	    link: function link(scope, element, attrs, ctrls) {
	      var datepickerCtrl = ctrls[0],
	          monthpickerCtrl = ctrls[1];

	      monthpickerCtrl.init(datepickerCtrl);
	    }
	  };
	}).directive('uibYearpicker', function () {
	  return {
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.templateUrl || 'uib/template/datepicker/year.html';
	    },
	    require: ['^uibDatepicker', 'uibYearpicker'],
	    restrict: 'A',
	    controller: 'UibYearpickerController',
	    link: function link(scope, element, attrs, ctrls) {
	      var ctrl = ctrls[0];
	      angular.extend(ctrl, ctrls[1]);
	      ctrl.yearpickerInit();

	      ctrl.refreshView();
	    }
	  };
	});

	angular.module('ui.bootstrap.position', [])

	/**
	 * A set of utility methods for working with the DOM.
	 * It is meant to be used where we need to absolute-position elements in
	 * relation to another element (this is the case for tooltips, popovers,
	 * typeahead suggestions etc.).
	 */
	.factory('$uibPosition', ['$document', '$window', function ($document, $window) {
	  /**
	   * Used by scrollbarWidth() function to cache scrollbar's width.
	   * Do not access this variable directly, use scrollbarWidth() instead.
	   */
	  var SCROLLBAR_WIDTH;
	  /**
	   * scrollbar on body and html element in IE and Edge overlay
	   * content and should be considered 0 width.
	   */
	  var BODY_SCROLLBAR_WIDTH;
	  var OVERFLOW_REGEX = {
	    normal: /(auto|scroll)/,
	    hidden: /(auto|scroll|hidden)/
	  };
	  var PLACEMENT_REGEX = {
	    auto: /\s?auto?\s?/i,
	    primary: /^(top|bottom|left|right)$/,
	    secondary: /^(top|bottom|left|right|center)$/,
	    vertical: /^(top|bottom)$/
	  };
	  var BODY_REGEX = /(HTML|BODY)/;

	  return {

	    /**
	     * Provides a raw DOM element from a jQuery/jQLite element.
	     *
	     * @param {element} elem - The element to convert.
	     *
	     * @returns {element} A HTML element.
	     */
	    getRawNode: function getRawNode(elem) {
	      return elem.nodeName ? elem : elem[0] || elem;
	    },

	    /**
	     * Provides a parsed number for a style property.  Strips
	     * units and casts invalid numbers to 0.
	     *
	     * @param {string} value - The style value to parse.
	     *
	     * @returns {number} A valid number.
	     */
	    parseStyle: function parseStyle(value) {
	      value = parseFloat(value);
	      return isFinite(value) ? value : 0;
	    },

	    /**
	     * Provides the closest positioned ancestor.
	     *
	     * @param {element} element - The element to get the offest parent for.
	     *
	     * @returns {element} The closest positioned ancestor.
	     */
	    offsetParent: function offsetParent(elem) {
	      elem = this.getRawNode(elem);

	      var offsetParent = elem.offsetParent || $document[0].documentElement;

	      function isStaticPositioned(el) {
	        return ($window.getComputedStyle(el).position || 'static') === 'static';
	      }

	      while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
	        offsetParent = offsetParent.offsetParent;
	      }

	      return offsetParent || $document[0].documentElement;
	    },

	    /**
	     * Provides the scrollbar width, concept from TWBS measureScrollbar()
	     * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js
	     * In IE and Edge, scollbar on body and html element overlay and should
	     * return a width of 0.
	     *
	     * @returns {number} The width of the browser scollbar.
	     */
	    scrollbarWidth: function scrollbarWidth(isBody) {
	      if (isBody) {
	        if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
	          var bodyElem = $document.find('body');
	          bodyElem.addClass('uib-position-body-scrollbar-measure');
	          BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;
	          BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;
	          bodyElem.removeClass('uib-position-body-scrollbar-measure');
	        }
	        return BODY_SCROLLBAR_WIDTH;
	      }

	      if (angular.isUndefined(SCROLLBAR_WIDTH)) {
	        var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
	        $document.find('body').append(scrollElem);
	        SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
	        SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
	        scrollElem.remove();
	      }

	      return SCROLLBAR_WIDTH;
	    },

	    /**
	     * Provides the padding required on an element to replace the scrollbar.
	     *
	     * @returns {object} An object with the following properties:
	     *   <ul>
	     *     <li>**scrollbarWidth**: the width of the scrollbar</li>
	     *     <li>**widthOverflow**: whether the the width is overflowing</li>
	     *     <li>**right**: the amount of right padding on the element needed to replace the scrollbar</li>
	     *     <li>**rightOriginal**: the amount of right padding currently on the element</li>
	     *     <li>**heightOverflow**: whether the the height is overflowing</li>
	     *     <li>**bottom**: the amount of bottom padding on the element needed to replace the scrollbar</li>
	     *     <li>**bottomOriginal**: the amount of bottom padding currently on the element</li>
	     *   </ul>
	     */
	    scrollbarPadding: function scrollbarPadding(elem) {
	      elem = this.getRawNode(elem);

	      var elemStyle = $window.getComputedStyle(elem);
	      var paddingRight = this.parseStyle(elemStyle.paddingRight);
	      var paddingBottom = this.parseStyle(elemStyle.paddingBottom);
	      var scrollParent = this.scrollParent(elem, false, true);
	      var scrollbarWidth = this.scrollbarWidth(BODY_REGEX.test(scrollParent.tagName));

	      return {
	        scrollbarWidth: scrollbarWidth,
	        widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
	        right: paddingRight + scrollbarWidth,
	        originalRight: paddingRight,
	        heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
	        bottom: paddingBottom + scrollbarWidth,
	        originalBottom: paddingBottom
	      };
	    },

	    /**
	     * Checks to see if the element is scrollable.
	     *
	     * @param {element} elem - The element to check.
	     * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
	     *   default is false.
	     *
	     * @returns {boolean} Whether the element is scrollable.
	     */
	    isScrollable: function isScrollable(elem, includeHidden) {
	      elem = this.getRawNode(elem);

	      var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
	      var elemStyle = $window.getComputedStyle(elem);
	      return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
	    },

	    /**
	     * Provides the closest scrollable ancestor.
	     * A port of the jQuery UI scrollParent method:
	     * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js
	     *
	     * @param {element} elem - The element to find the scroll parent of.
	     * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
	     *   default is false.
	     * @param {boolean=} [includeSelf=false] - Should the element being passed be
	     * included in the scrollable llokup.
	     *
	     * @returns {element} A HTML element.
	     */
	    scrollParent: function scrollParent(elem, includeHidden, includeSelf) {
	      elem = this.getRawNode(elem);

	      var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
	      var documentEl = $document[0].documentElement;
	      var elemStyle = $window.getComputedStyle(elem);
	      if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {
	        return elem;
	      }
	      var excludeStatic = elemStyle.position === 'absolute';
	      var scrollParent = elem.parentElement || documentEl;

	      if (scrollParent === documentEl || elemStyle.position === 'fixed') {
	        return documentEl;
	      }

	      while (scrollParent.parentElement && scrollParent !== documentEl) {
	        var spStyle = $window.getComputedStyle(scrollParent);
	        if (excludeStatic && spStyle.position !== 'static') {
	          excludeStatic = false;
	        }

	        if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
	          break;
	        }
	        scrollParent = scrollParent.parentElement;
	      }

	      return scrollParent;
	    },

	    /**
	     * Provides read-only equivalent of jQuery's position function:
	     * http://api.jquery.com/position/ - distance to closest positioned
	     * ancestor.  Does not account for margins by default like jQuery position.
	     *
	     * @param {element} elem - The element to caclulate the position on.
	     * @param {boolean=} [includeMargins=false] - Should margins be accounted
	     * for, default is false.
	     *
	     * @returns {object} An object with the following properties:
	     *   <ul>
	     *     <li>**width**: the width of the element</li>
	     *     <li>**height**: the height of the element</li>
	     *     <li>**top**: distance to top edge of offset parent</li>
	     *     <li>**left**: distance to left edge of offset parent</li>
	     *   </ul>
	     */
	    position: function position(elem, includeMagins) {
	      elem = this.getRawNode(elem);

	      var elemOffset = this.offset(elem);
	      if (includeMagins) {
	        var elemStyle = $window.getComputedStyle(elem);
	        elemOffset.top -= this.parseStyle(elemStyle.marginTop);
	        elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
	      }
	      var parent = this.offsetParent(elem);
	      var parentOffset = { top: 0, left: 0 };

	      if (parent !== $document[0].documentElement) {
	        parentOffset = this.offset(parent);
	        parentOffset.top += parent.clientTop - parent.scrollTop;
	        parentOffset.left += parent.clientLeft - parent.scrollLeft;
	      }

	      return {
	        width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
	        height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
	        top: Math.round(elemOffset.top - parentOffset.top),
	        left: Math.round(elemOffset.left - parentOffset.left)
	      };
	    },

	    /**
	     * Provides read-only equivalent of jQuery's offset function:
	     * http://api.jquery.com/offset/ - distance to viewport.  Does
	     * not account for borders, margins, or padding on the body
	     * element.
	     *
	     * @param {element} elem - The element to calculate the offset on.
	     *
	     * @returns {object} An object with the following properties:
	     *   <ul>
	     *     <li>**width**: the width of the element</li>
	     *     <li>**height**: the height of the element</li>
	     *     <li>**top**: distance to top edge of viewport</li>
	     *     <li>**right**: distance to bottom edge of viewport</li>
	     *   </ul>
	     */
	    offset: function offset(elem) {
	      elem = this.getRawNode(elem);

	      var elemBCR = elem.getBoundingClientRect();
	      return {
	        width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
	        height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
	        top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
	        left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
	      };
	    },

	    /**
	     * Provides offset distance to the closest scrollable ancestor
	     * or viewport.  Accounts for border and scrollbar width.
	     *
	     * Right and bottom dimensions represent the distance to the
	     * respective edge of the viewport element.  If the element
	     * edge extends beyond the viewport, a negative value will be
	     * reported.
	     *
	     * @param {element} elem - The element to get the viewport offset for.
	     * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead
	     * of the first scrollable element, default is false.
	     * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element
	     * be accounted for, default is true.
	     *
	     * @returns {object} An object with the following properties:
	     *   <ul>
	     *     <li>**top**: distance to the top content edge of viewport element</li>
	     *     <li>**bottom**: distance to the bottom content edge of viewport element</li>
	     *     <li>**left**: distance to the left content edge of viewport element</li>
	     *     <li>**right**: distance to the right content edge of viewport element</li>
	     *   </ul>
	     */
	    viewportOffset: function viewportOffset(elem, useDocument, includePadding) {
	      elem = this.getRawNode(elem);
	      includePadding = includePadding !== false ? true : false;

	      var elemBCR = elem.getBoundingClientRect();
	      var offsetBCR = { top: 0, left: 0, bottom: 0, right: 0 };

	      var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
	      var offsetParentBCR = offsetParent.getBoundingClientRect();

	      offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
	      offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
	      if (offsetParent === $document[0].documentElement) {
	        offsetBCR.top += $window.pageYOffset;
	        offsetBCR.left += $window.pageXOffset;
	      }
	      offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
	      offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;

	      if (includePadding) {
	        var offsetParentStyle = $window.getComputedStyle(offsetParent);
	        offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
	        offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
	        offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
	        offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
	      }

	      return {
	        top: Math.round(elemBCR.top - offsetBCR.top),
	        bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
	        left: Math.round(elemBCR.left - offsetBCR.left),
	        right: Math.round(offsetBCR.right - elemBCR.right)
	      };
	    },

	    /**
	     * Provides an array of placement values parsed from a placement string.
	     * Along with the 'auto' indicator, supported placement strings are:
	     *   <ul>
	     *     <li>top: element on top, horizontally centered on host element.</li>
	     *     <li>top-left: element on top, left edge aligned with host element left edge.</li>
	     *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>
	     *     <li>bottom: element on bottom, horizontally centered on host element.</li>
	     *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>
	     *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>
	     *     <li>left: element on left, vertically centered on host element.</li>
	     *     <li>left-top: element on left, top edge aligned with host element top edge.</li>
	     *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>
	     *     <li>right: element on right, vertically centered on host element.</li>
	     *     <li>right-top: element on right, top edge aligned with host element top edge.</li>
	     *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>
	     *   </ul>
	     * A placement string with an 'auto' indicator is expected to be
	     * space separated from the placement, i.e: 'auto bottom-left'  If
	     * the primary and secondary placement values do not match 'top,
	     * bottom, left, right' then 'top' will be the primary placement and
	     * 'center' will be the secondary placement.  If 'auto' is passed, true
	     * will be returned as the 3rd value of the array.
	     *
	     * @param {string} placement - The placement string to parse.
	     *
	     * @returns {array} An array with the following values
	     * <ul>
	     *   <li>**[0]**: The primary placement.</li>
	     *   <li>**[1]**: The secondary placement.</li>
	     *   <li>**[2]**: If auto is passed: true, else undefined.</li>
	     * </ul>
	     */
	    parsePlacement: function parsePlacement(placement) {
	      var autoPlace = PLACEMENT_REGEX.auto.test(placement);
	      if (autoPlace) {
	        placement = placement.replace(PLACEMENT_REGEX.auto, '');
	      }

	      placement = placement.split('-');

	      placement[0] = placement[0] || 'top';
	      if (!PLACEMENT_REGEX.primary.test(placement[0])) {
	        placement[0] = 'top';
	      }

	      placement[1] = placement[1] || 'center';
	      if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
	        placement[1] = 'center';
	      }

	      if (autoPlace) {
	        placement[2] = true;
	      } else {
	        placement[2] = false;
	      }

	      return placement;
	    },

	    /**
	     * Provides coordinates for an element to be positioned relative to
	     * another element.  Passing 'auto' as part of the placement parameter
	     * will enable smart placement - where the element fits. i.e:
	     * 'auto left-top' will check to see if there is enough space to the left
	     * of the hostElem to fit the targetElem, if not place right (same for secondary
	     * top placement).  Available space is calculated using the viewportOffset
	     * function.
	     *
	     * @param {element} hostElem - The element to position against.
	     * @param {element} targetElem - The element to position.
	     * @param {string=} [placement=top] - The placement for the targetElem,
	     *   default is 'top'. 'center' is assumed as secondary placement for
	     *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:
	     *   <ul>
	     *     <li>top</li>
	     *     <li>top-right</li>
	     *     <li>top-left</li>
	     *     <li>bottom</li>
	     *     <li>bottom-left</li>
	     *     <li>bottom-right</li>
	     *     <li>left</li>
	     *     <li>left-top</li>
	     *     <li>left-bottom</li>
	     *     <li>right</li>
	     *     <li>right-top</li>
	     *     <li>right-bottom</li>
	     *   </ul>
	     * @param {boolean=} [appendToBody=false] - Should the top and left values returned
	     *   be calculated from the body element, default is false.
	     *
	     * @returns {object} An object with the following properties:
	     *   <ul>
	     *     <li>**top**: Value for targetElem top.</li>
	     *     <li>**left**: Value for targetElem left.</li>
	     *     <li>**placement**: The resolved placement.</li>
	     *   </ul>
	     */
	    positionElements: function positionElements(hostElem, targetElem, placement, appendToBody) {
	      hostElem = this.getRawNode(hostElem);
	      targetElem = this.getRawNode(targetElem);

	      // need to read from prop to support tests.
	      var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
	      var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');

	      placement = this.parsePlacement(placement);

	      var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
	      var targetElemPos = { top: 0, left: 0, placement: '' };

	      if (placement[2]) {
	        var viewportOffset = this.viewportOffset(hostElem, appendToBody);

	        var targetElemStyle = $window.getComputedStyle(targetElem);
	        var adjustedSize = {
	          width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
	          height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
	        };

	        placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' : placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' : placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' : placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' : placement[0];

	        placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' : placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' : placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' : placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' : placement[1];

	        if (placement[1] === 'center') {
	          if (PLACEMENT_REGEX.vertical.test(placement[0])) {
	            var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
	            if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
	              placement[1] = 'left';
	            } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
	              placement[1] = 'right';
	            }
	          } else {
	            var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
	            if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
	              placement[1] = 'top';
	            } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
	              placement[1] = 'bottom';
	            }
	          }
	        }
	      }

	      switch (placement[0]) {
	        case 'top':
	          targetElemPos.top = hostElemPos.top - targetHeight;
	          break;
	        case 'bottom':
	          targetElemPos.top = hostElemPos.top + hostElemPos.height;
	          break;
	        case 'left':
	          targetElemPos.left = hostElemPos.left - targetWidth;
	          break;
	        case 'right':
	          targetElemPos.left = hostElemPos.left + hostElemPos.width;
	          break;
	      }

	      switch (placement[1]) {
	        case 'top':
	          targetElemPos.top = hostElemPos.top;
	          break;
	        case 'bottom':
	          targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
	          break;
	        case 'left':
	          targetElemPos.left = hostElemPos.left;
	          break;
	        case 'right':
	          targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
	          break;
	        case 'center':
	          if (PLACEMENT_REGEX.vertical.test(placement[0])) {
	            targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
	          } else {
	            targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
	          }
	          break;
	      }

	      targetElemPos.top = Math.round(targetElemPos.top);
	      targetElemPos.left = Math.round(targetElemPos.left);
	      targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];

	      return targetElemPos;
	    },

	    /**
	     * Provides a way to adjust the top positioning after first
	     * render to correctly align element to top after content
	     * rendering causes resized element height
	     *
	     * @param {array} placementClasses - The array of strings of classes
	     * element should have.
	     * @param {object} containerPosition - The object with container
	     * position information
	     * @param {number} initialHeight - The initial height for the elem.
	     * @param {number} currentHeight - The current height for the elem.
	     */
	    adjustTop: function adjustTop(placementClasses, containerPosition, initialHeight, currentHeight) {
	      if (placementClasses.indexOf('top') !== -1 && initialHeight !== currentHeight) {
	        return {
	          top: containerPosition.top - currentHeight + 'px'
	        };
	      }
	    },

	    /**
	     * Provides a way for positioning tooltip & dropdown
	     * arrows when using placement options beyond the standard
	     * left, right, top, or bottom.
	     *
	     * @param {element} elem - The tooltip/dropdown element.
	     * @param {string} placement - The placement for the elem.
	     */
	    positionArrow: function positionArrow(elem, placement) {
	      elem = this.getRawNode(elem);

	      var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
	      if (!innerElem) {
	        return;
	      }

	      var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');

	      var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
	      if (!arrowElem) {
	        return;
	      }

	      var arrowCss = {
	        top: '',
	        bottom: '',
	        left: '',
	        right: ''
	      };

	      placement = this.parsePlacement(placement);
	      if (placement[1] === 'center') {
	        // no adjustment necessary - just reset styles
	        angular.element(arrowElem).css(arrowCss);
	        return;
	      }

	      var borderProp = 'border-' + placement[0] + '-width';
	      var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];

	      var borderRadiusProp = 'border-';
	      if (PLACEMENT_REGEX.vertical.test(placement[0])) {
	        borderRadiusProp += placement[0] + '-' + placement[1];
	      } else {
	        borderRadiusProp += placement[1] + '-' + placement[0];
	      }
	      borderRadiusProp += '-radius';
	      var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];

	      switch (placement[0]) {
	        case 'top':
	          arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
	          break;
	        case 'bottom':
	          arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
	          break;
	        case 'left':
	          arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
	          break;
	        case 'right':
	          arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
	          break;
	      }

	      arrowCss[placement[1]] = borderRadius;

	      angular.element(arrowElem).css(arrowCss);
	    }
	  };
	}]);

	angular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position']).value('$datepickerPopupLiteralWarning', true).constant('uibDatepickerPopupConfig', {
	  altInputFormats: [],
	  appendToBody: false,
	  clearText: 'Clear',
	  closeOnDateSelection: true,
	  closeText: 'Done',
	  currentText: 'Today',
	  datepickerPopup: 'yyyy-MM-dd',
	  datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',
	  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
	  html5Types: {
	    date: 'yyyy-MM-dd',
	    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
	    'month': 'yyyy-MM'
	  },
	  onOpenFocus: true,
	  showButtonBar: true,
	  placement: 'auto bottom-left'
	}).controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning', function ($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
	  var cache = {},
	      isHtml5DateInput = false;
	  var dateFormat,
	      closeOnDateSelection,
	      appendToBody,
	      onOpenFocus,
	      datepickerPopupTemplateUrl,
	      datepickerTemplateUrl,
	      popupEl,
	      datepickerEl,
	      scrollParentEl,
	      ngModel,
	      ngModelOptions,
	      $popup,
	      altInputFormats,
	      watchListeners = [];

	  this.init = function (_ngModel_) {
	    ngModel = _ngModel_;
	    ngModelOptions = extractOptions(ngModel);
	    closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ? $scope.$parent.$eval($attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
	    appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ? $scope.$parent.$eval($attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
	    onOpenFocus = angular.isDefined($attrs.onOpenFocus) ? $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
	    datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ? $attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;
	    datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ? $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
	    altInputFormats = angular.isDefined($attrs.altInputFormats) ? $scope.$parent.$eval($attrs.altInputFormats) : datepickerPopupConfig.altInputFormats;

	    $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ? $scope.$parent.$eval($attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;

	    if (datepickerPopupConfig.html5Types[$attrs.type]) {
	      dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
	      isHtml5DateInput = true;
	    } else {
	      dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
	      $attrs.$observe('uibDatepickerPopup', function (value, oldValue) {
	        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
	        // Invalidate the $modelValue to ensure that formatters re-run
	        // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
	        if (newDateFormat !== dateFormat) {
	          dateFormat = newDateFormat;
	          ngModel.$modelValue = null;

	          if (!dateFormat) {
	            throw new Error('uibDatepickerPopup must have a date format specified.');
	          }
	        }
	      });
	    }

	    if (!dateFormat) {
	      throw new Error('uibDatepickerPopup must have a date format specified.');
	    }

	    if (isHtml5DateInput && $attrs.uibDatepickerPopup) {
	      throw new Error('HTML5 date input types do not support custom formats.');
	    }

	    // popup element used to display calendar
	    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');

	    popupEl.attr({
	      'ng-model': 'date',
	      'ng-change': 'dateSelection(date)',
	      'template-url': datepickerPopupTemplateUrl
	    });

	    // datepicker element
	    datepickerEl = angular.element(popupEl.children()[0]);
	    datepickerEl.attr('template-url', datepickerTemplateUrl);

	    if (!$scope.datepickerOptions) {
	      $scope.datepickerOptions = {};
	    }

	    if (isHtml5DateInput) {
	      if ($attrs.type === 'month') {
	        $scope.datepickerOptions.datepickerMode = 'month';
	        $scope.datepickerOptions.minMode = 'month';
	      }
	    }

	    datepickerEl.attr('datepicker-options', 'datepickerOptions');

	    if (!isHtml5DateInput) {
	      // Internal API to maintain the correct ng-invalid-[key] class
	      ngModel.$$parserName = 'date';
	      ngModel.$validators.date = validator;
	      ngModel.$parsers.unshift(parseDate);
	      ngModel.$formatters.push(function (value) {
	        if (ngModel.$isEmpty(value)) {
	          $scope.date = value;
	          return value;
	        }

	        if (angular.isNumber(value)) {
	          value = new Date(value);
	        }

	        $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));

	        return dateParser.filter($scope.date, dateFormat);
	      });
	    } else {
	      ngModel.$formatters.push(function (value) {
	        $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));
	        return value;
	      });
	    }

	    // Detect changes in the view from the text box
	    ngModel.$viewChangeListeners.push(function () {
	      $scope.date = parseDateString(ngModel.$viewValue);
	    });

	    $element.on('keydown', inputKeydownBind);

	    $popup = $compile(popupEl)($scope);
	    // Prevent jQuery cache memory leak (template is now redundant after linking)
	    popupEl.remove();

	    if (appendToBody) {
	      $document.find('body').append($popup);
	    } else {
	      $element.after($popup);
	    }

	    $scope.$on('$destroy', function () {
	      if ($scope.isOpen === true) {
	        if (!$rootScope.$$phase) {
	          $scope.$apply(function () {
	            $scope.isOpen = false;
	          });
	        }
	      }

	      $popup.remove();
	      $element.off('keydown', inputKeydownBind);
	      $document.off('click', documentClickBind);
	      if (scrollParentEl) {
	        scrollParentEl.off('scroll', positionPopup);
	      }
	      angular.element($window).off('resize', positionPopup);

	      //Clear all watch listeners on destroy
	      while (watchListeners.length) {
	        watchListeners.shift()();
	      }
	    });
	  };

	  $scope.getText = function (key) {
	    return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
	  };

	  $scope.isDisabled = function (date) {
	    if (date === 'today') {
	      date = dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));
	    }

	    var dates = {};
	    angular.forEach(['minDate', 'maxDate'], function (key) {
	      if (!$scope.datepickerOptions[key]) {
	        dates[key] = null;
	      } else if (angular.isDate($scope.datepickerOptions[key])) {
	        dates[key] = new Date($scope.datepickerOptions[key]);
	      } else {
	        if ($datepickerPopupLiteralWarning) {
	          $log.warn('Literal date support has been deprecated, please switch to date object usage');
	        }

	        dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));
	      }
	    });

	    return $scope.datepickerOptions && dates.minDate && $scope.compare(date, dates.minDate) < 0 || dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
	  };

	  $scope.compare = function (date1, date2) {
	    return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
	  };

	  // Inner change
	  $scope.dateSelection = function (dt) {
	    $scope.date = dt;
	    var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
	    $element.val(date);
	    ngModel.$setViewValue(date);

	    if (closeOnDateSelection) {
	      $scope.isOpen = false;
	      $element[0].focus();
	    }
	  };

	  $scope.keydown = function (evt) {
	    if (evt.which === 27) {
	      evt.stopPropagation();
	      $scope.isOpen = false;
	      $element[0].focus();
	    }
	  };

	  $scope.select = function (date, evt) {
	    evt.stopPropagation();

	    if (date === 'today') {
	      var today = new Date();
	      if (angular.isDate($scope.date)) {
	        date = new Date($scope.date);
	        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
	      } else {
	        date = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));
	        date.setHours(0, 0, 0, 0);
	      }
	    }
	    $scope.dateSelection(date);
	  };

	  $scope.close = function (evt) {
	    evt.stopPropagation();

	    $scope.isOpen = false;
	    $element[0].focus();
	  };

	  $scope.disabled = angular.isDefined($attrs.disabled) || false;
	  if ($attrs.ngDisabled) {
	    watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function (disabled) {
	      $scope.disabled = disabled;
	    }));
	  }

	  $scope.$watch('isOpen', function (value) {
	    if (value) {
	      if (!$scope.disabled) {
	        $timeout(function () {
	          positionPopup();

	          if (onOpenFocus) {
	            $scope.$broadcast('uib:datepicker.focus');
	          }

	          $document.on('click', documentClickBind);

	          var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
	          if (appendToBody || $position.parsePlacement(placement)[2]) {
	            scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));
	            if (scrollParentEl) {
	              scrollParentEl.on('scroll', positionPopup);
	            }
	          } else {
	            scrollParentEl = null;
	          }

	          angular.element($window).on('resize', positionPopup);
	        }, 0, false);
	      } else {
	        $scope.isOpen = false;
	      }
	    } else {
	      $document.off('click', documentClickBind);
	      if (scrollParentEl) {
	        scrollParentEl.off('scroll', positionPopup);
	      }
	      angular.element($window).off('resize', positionPopup);
	    }
	  });

	  function cameltoDash(string) {
	    return string.replace(/([A-Z])/g, function ($1) {
	      return '-' + $1.toLowerCase();
	    });
	  }

	  function parseDateString(viewValue) {
	    var date = dateParser.parse(viewValue, dateFormat, $scope.date);
	    if (isNaN(date)) {
	      for (var i = 0; i < altInputFormats.length; i++) {
	        date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
	        if (!isNaN(date)) {
	          return date;
	        }
	      }
	    }
	    return date;
	  }

	  function parseDate(viewValue) {
	    if (angular.isNumber(viewValue)) {
	      // presumably timestamp to date object
	      viewValue = new Date(viewValue);
	    }

	    if (!viewValue) {
	      return null;
	    }

	    if (angular.isDate(viewValue) && !isNaN(viewValue)) {
	      return viewValue;
	    }

	    if (angular.isString(viewValue)) {
	      var date = parseDateString(viewValue);
	      if (!isNaN(date)) {
	        return dateParser.toTimezone(date, ngModelOptions.getOption('timezone'));
	      }
	    }

	    return ngModelOptions.getOption('allowInvalid') ? viewValue : undefined;
	  }

	  function validator(modelValue, viewValue) {
	    var value = modelValue || viewValue;

	    if (!$attrs.ngRequired && !value) {
	      return true;
	    }

	    if (angular.isNumber(value)) {
	      value = new Date(value);
	    }

	    if (!value) {
	      return true;
	    }

	    if (angular.isDate(value) && !isNaN(value)) {
	      return true;
	    }

	    if (angular.isString(value)) {
	      return !isNaN(parseDateString(value));
	    }

	    return false;
	  }

	  function documentClickBind(event) {
	    if (!$scope.isOpen && $scope.disabled) {
	      return;
	    }

	    var popup = $popup[0];
	    var dpContainsTarget = $element[0].contains(event.target);
	    // The popup node may not be an element node
	    // In some browsers (IE) only element nodes have the 'contains' function
	    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
	    if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
	      $scope.$apply(function () {
	        $scope.isOpen = false;
	      });
	    }
	  }

	  function inputKeydownBind(evt) {
	    if (evt.which === 27 && $scope.isOpen) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      $scope.$apply(function () {
	        $scope.isOpen = false;
	      });
	      $element[0].focus();
	    } else if (evt.which === 40 && !$scope.isOpen) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      $scope.$apply(function () {
	        $scope.isOpen = true;
	      });
	    }
	  }

	  function positionPopup() {
	    if ($scope.isOpen) {
	      var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));
	      var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
	      var position = $position.positionElements($element, dpElement, placement, appendToBody);
	      dpElement.css({ top: position.top + 'px', left: position.left + 'px' });
	      if (dpElement.hasClass('uib-position-measure')) {
	        dpElement.removeClass('uib-position-measure');
	      }
	    }
	  }

	  function extractOptions(ngModelCtrl) {
	    var ngModelOptions;

	    if (angular.version.minor < 6) {
	      // in angular < 1.6 $options could be missing
	      // guarantee a value
	      ngModelOptions = angular.isObject(ngModelCtrl.$options) ? ngModelCtrl.$options : {
	        timezone: null
	      };

	      // mimic 1.6+ api
	      ngModelOptions.getOption = function (key) {
	        return ngModelOptions[key];
	      };
	    } else {
	      // in angular >=1.6 $options is always present
	      ngModelOptions = ngModelCtrl.$options;
	    }

	    return ngModelOptions;
	  }

	  $scope.$on('uib:datepicker.mode', function () {
	    $timeout(positionPopup, 0, false);
	  });
	}]).directive('uibDatepickerPopup', function () {
	  return {
	    require: ['ngModel', 'uibDatepickerPopup'],
	    controller: 'UibDatepickerPopupController',
	    scope: {
	      datepickerOptions: '=?',
	      isOpen: '=?',
	      currentText: '@',
	      clearText: '@',
	      closeText: '@'
	    },
	    link: function link(scope, element, attrs, ctrls) {
	      var ngModel = ctrls[0],
	          ctrl = ctrls[1];

	      ctrl.init(ngModel);
	    }
	  };
	}).directive('uibDatepickerPopupWrap', function () {
	  return {
	    restrict: 'A',
	    transclude: true,
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';
	    }
	  };
	});

	angular.module('ui.bootstrap.debounce', [])
	/**
	 * A helper, internal service that debounces a function
	 */
	.factory('$$debounce', ['$timeout', function ($timeout) {
	  return function (callback, debounceTime) {
	    var timeoutPromise;

	    return function () {
	      var self = this;
	      var args = Array.prototype.slice.call(arguments);
	      if (timeoutPromise) {
	        $timeout.cancel(timeoutPromise);
	      }

	      timeoutPromise = $timeout(function () {
	        callback.apply(self, args);
	      }, debounceTime);
	    };
	  };
	}]);

	angular.module('ui.bootstrap.multiMap', [])
	/**
	 * A helper, internal data structure that stores all references attached to key
	 */
	.factory('$$multiMap', function () {
	  return {
	    createNew: function createNew() {
	      var map = {};

	      return {
	        entries: function entries() {
	          return Object.keys(map).map(function (key) {
	            return {
	              key: key,
	              value: map[key]
	            };
	          });
	        },
	        get: function get(key) {
	          return map[key];
	        },
	        hasKey: function hasKey(key) {
	          return !!map[key];
	        },
	        keys: function keys() {
	          return Object.keys(map);
	        },
	        put: function put(key, value) {
	          if (!map[key]) {
	            map[key] = [];
	          }

	          map[key].push(value);
	        },
	        remove: function remove(key, value) {
	          var values = map[key];

	          if (!values) {
	            return;
	          }

	          var idx = values.indexOf(value);

	          if (idx !== -1) {
	            values.splice(idx, 1);
	          }

	          if (!values.length) {
	            delete map[key];
	          }
	        }
	      };
	    }
	  };
	});

	angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.multiMap', 'ui.bootstrap.position']).constant('uibDropdownConfig', {
	  appendToOpenClass: 'uib-dropdown-open',
	  openClass: 'open'
	}).service('uibDropdownService', ['$document', '$rootScope', '$$multiMap', function ($document, $rootScope, $$multiMap) {
	  var openScope = null;
	  var openedContainers = $$multiMap.createNew();

	  this.isOnlyOpen = function (dropdownScope, appendTo) {
	    var openedDropdowns = openedContainers.get(appendTo);
	    if (openedDropdowns) {
	      var openDropdown = openedDropdowns.reduce(function (toClose, dropdown) {
	        if (dropdown.scope === dropdownScope) {
	          return dropdown;
	        }

	        return toClose;
	      }, {});
	      if (openDropdown) {
	        return openedDropdowns.length === 1;
	      }
	    }

	    return false;
	  };

	  this.open = function (dropdownScope, element, appendTo) {
	    if (!openScope) {
	      $document.on('click', closeDropdown);
	    }

	    if (openScope && openScope !== dropdownScope) {
	      openScope.isOpen = false;
	    }

	    openScope = dropdownScope;

	    if (!appendTo) {
	      return;
	    }

	    var openedDropdowns = openedContainers.get(appendTo);
	    if (openedDropdowns) {
	      var openedScopes = openedDropdowns.map(function (dropdown) {
	        return dropdown.scope;
	      });
	      if (openedScopes.indexOf(dropdownScope) === -1) {
	        openedContainers.put(appendTo, {
	          scope: dropdownScope
	        });
	      }
	    } else {
	      openedContainers.put(appendTo, {
	        scope: dropdownScope
	      });
	    }
	  };

	  this.close = function (dropdownScope, element, appendTo) {
	    if (openScope === dropdownScope) {
	      $document.off('click', closeDropdown);
	      $document.off('keydown', this.keybindFilter);
	      openScope = null;
	    }

	    if (!appendTo) {
	      return;
	    }

	    var openedDropdowns = openedContainers.get(appendTo);
	    if (openedDropdowns) {
	      var dropdownToClose = openedDropdowns.reduce(function (toClose, dropdown) {
	        if (dropdown.scope === dropdownScope) {
	          return dropdown;
	        }

	        return toClose;
	      }, {});
	      if (dropdownToClose) {
	        openedContainers.remove(appendTo, dropdownToClose);
	      }
	    }
	  };

	  var closeDropdown = function closeDropdown(evt) {
	    // This method may still be called during the same mouse event that
	    // unbound this event handler. So check openScope before proceeding.
	    if (!openScope || !openScope.isOpen) {
	      return;
	    }

	    if (evt && openScope.getAutoClose() === 'disabled') {
	      return;
	    }

	    if (evt && evt.which === 3) {
	      return;
	    }

	    var toggleElement = openScope.getToggleElement();
	    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
	      return;
	    }

	    var dropdownElement = openScope.getDropdownElement();
	    if (evt && openScope.getAutoClose() === 'outsideClick' && dropdownElement && dropdownElement[0].contains(evt.target)) {
	      return;
	    }

	    openScope.focusToggleElement();
	    openScope.isOpen = false;

	    if (!$rootScope.$$phase) {
	      openScope.$apply();
	    }
	  };

	  this.keybindFilter = function (evt) {
	    if (!openScope) {
	      // see this.close as ESC could have been pressed which kills the scope so we can not proceed
	      return;
	    }

	    var dropdownElement = openScope.getDropdownElement();
	    var toggleElement = openScope.getToggleElement();
	    var dropdownElementTargeted = dropdownElement && dropdownElement[0].contains(evt.target);
	    var toggleElementTargeted = toggleElement && toggleElement[0].contains(evt.target);
	    if (evt.which === 27) {
	      evt.stopPropagation();
	      openScope.focusToggleElement();
	      closeDropdown();
	    } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen && (dropdownElementTargeted || toggleElementTargeted)) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      openScope.focusDropdownEntry(evt.which);
	    }
	  };
	}]).controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function ($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
	  var self = this,
	      scope = $scope.$new(),
	      // create a child scope so we are not polluting original one
	  templateScope,
	      appendToOpenClass = dropdownConfig.appendToOpenClass,
	      openClass = dropdownConfig.openClass,
	      getIsOpen,
	      setIsOpen = angular.noop,
	      toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
	      keynavEnabled = false,
	      selectedOption = null,
	      body = $document.find('body');

	  $element.addClass('dropdown');

	  this.init = function () {
	    if ($attrs.isOpen) {
	      getIsOpen = $parse($attrs.isOpen);
	      setIsOpen = getIsOpen.assign;

	      $scope.$watch(getIsOpen, function (value) {
	        scope.isOpen = !!value;
	      });
	    }

	    keynavEnabled = angular.isDefined($attrs.keyboardNav);
	  };

	  this.toggle = function (open) {
	    scope.isOpen = arguments.length ? !!open : !scope.isOpen;
	    if (angular.isFunction(setIsOpen)) {
	      setIsOpen(scope, scope.isOpen);
	    }

	    return scope.isOpen;
	  };

	  // Allow other directives to watch status
	  this.isOpen = function () {
	    return scope.isOpen;
	  };

	  scope.getToggleElement = function () {
	    return self.toggleElement;
	  };

	  scope.getAutoClose = function () {
	    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
	  };

	  scope.getElement = function () {
	    return $element;
	  };

	  scope.isKeynavEnabled = function () {
	    return keynavEnabled;
	  };

	  scope.focusDropdownEntry = function (keyCode) {
	    var elems = self.dropdownMenu ? //If append to body is used.
	    angular.element(self.dropdownMenu).find('a') : $element.find('ul').eq(0).find('a');

	    switch (keyCode) {
	      case 40:
	        {
	          if (!angular.isNumber(self.selectedOption)) {
	            self.selectedOption = 0;
	          } else {
	            self.selectedOption = self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1;
	          }
	          break;
	        }
	      case 38:
	        {
	          if (!angular.isNumber(self.selectedOption)) {
	            self.selectedOption = elems.length - 1;
	          } else {
	            self.selectedOption = self.selectedOption === 0 ? 0 : self.selectedOption - 1;
	          }
	          break;
	        }
	    }
	    elems[self.selectedOption].focus();
	  };

	  scope.getDropdownElement = function () {
	    return self.dropdownMenu;
	  };

	  scope.focusToggleElement = function () {
	    if (self.toggleElement) {
	      self.toggleElement[0].focus();
	    }
	  };

	  function removeDropdownMenu() {
	    $element.append(self.dropdownMenu);
	  }

	  scope.$watch('isOpen', function (isOpen, wasOpen) {
	    var appendTo = null,
	        appendToBody = false;

	    if (angular.isDefined($attrs.dropdownAppendTo)) {
	      var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
	      if (appendToEl) {
	        appendTo = angular.element(appendToEl);
	      }
	    }

	    if (angular.isDefined($attrs.dropdownAppendToBody)) {
	      var appendToBodyValue = $parse($attrs.dropdownAppendToBody)(scope);
	      if (appendToBodyValue !== false) {
	        appendToBody = true;
	      }
	    }

	    if (appendToBody && !appendTo) {
	      appendTo = body;
	    }

	    if (appendTo && self.dropdownMenu) {
	      if (isOpen) {
	        appendTo.append(self.dropdownMenu);
	        $element.on('$destroy', removeDropdownMenu);
	      } else {
	        $element.off('$destroy', removeDropdownMenu);
	        removeDropdownMenu();
	      }
	    }

	    if (appendTo && self.dropdownMenu) {
	      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),
	          css,
	          rightalign,
	          scrollbarPadding,
	          scrollbarWidth = 0;

	      css = {
	        top: pos.top + 'px',
	        display: isOpen ? 'block' : 'none'
	      };

	      rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
	      if (!rightalign) {
	        css.left = pos.left + 'px';
	        css.right = 'auto';
	      } else {
	        css.left = 'auto';
	        scrollbarPadding = $position.scrollbarPadding(appendTo);

	        if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
	          scrollbarWidth = scrollbarPadding.scrollbarWidth;
	        }

	        css.right = window.innerWidth - scrollbarWidth - (pos.left + $element.prop('offsetWidth')) + 'px';
	      }

	      // Need to adjust our positioning to be relative to the appendTo container
	      // if it's not the body element
	      if (!appendToBody) {
	        var appendOffset = $position.offset(appendTo);

	        css.top = pos.top - appendOffset.top + 'px';

	        if (!rightalign) {
	          css.left = pos.left - appendOffset.left + 'px';
	        } else {
	          css.right = window.innerWidth - (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
	        }
	      }

	      self.dropdownMenu.css(css);
	    }

	    var openContainer = appendTo ? appendTo : $element;
	    var dropdownOpenClass = appendTo ? appendToOpenClass : openClass;
	    var hasOpenClass = openContainer.hasClass(dropdownOpenClass);
	    var isOnlyOpen = uibDropdownService.isOnlyOpen($scope, appendTo);

	    if (hasOpenClass === !isOpen) {
	      var toggleClass;
	      if (appendTo) {
	        toggleClass = !isOnlyOpen ? 'addClass' : 'removeClass';
	      } else {
	        toggleClass = isOpen ? 'addClass' : 'removeClass';
	      }
	      $animate[toggleClass](openContainer, dropdownOpenClass).then(function () {
	        if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
	          toggleInvoker($scope, { open: !!isOpen });
	        }
	      });
	    }

	    if (isOpen) {
	      if (self.dropdownMenuTemplateUrl) {
	        $templateRequest(self.dropdownMenuTemplateUrl).then(function (tplContent) {
	          templateScope = scope.$new();
	          $compile(tplContent.trim())(templateScope, function (dropdownElement) {
	            var newEl = dropdownElement;
	            self.dropdownMenu.replaceWith(newEl);
	            self.dropdownMenu = newEl;
	            $document.on('keydown', uibDropdownService.keybindFilter);
	          });
	        });
	      } else {
	        $document.on('keydown', uibDropdownService.keybindFilter);
	      }

	      scope.focusToggleElement();
	      uibDropdownService.open(scope, $element, appendTo);
	    } else {
	      uibDropdownService.close(scope, $element, appendTo);
	      if (self.dropdownMenuTemplateUrl) {
	        if (templateScope) {
	          templateScope.$destroy();
	        }
	        var newEl = angular.element('<ul class="dropdown-menu"></ul>');
	        self.dropdownMenu.replaceWith(newEl);
	        self.dropdownMenu = newEl;
	      }

	      self.selectedOption = null;
	    }

	    if (angular.isFunction(setIsOpen)) {
	      setIsOpen($scope, isOpen);
	    }
	  });
	}]).directive('uibDropdown', function () {
	  return {
	    controller: 'UibDropdownController',
	    link: function link(scope, element, attrs, dropdownCtrl) {
	      dropdownCtrl.init();
	    }
	  };
	}).directive('uibDropdownMenu', function () {
	  return {
	    restrict: 'A',
	    require: '?^uibDropdown',
	    link: function link(scope, element, attrs, dropdownCtrl) {
	      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
	        return;
	      }

	      element.addClass('dropdown-menu');

	      var tplUrl = attrs.templateUrl;
	      if (tplUrl) {
	        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
	      }

	      if (!dropdownCtrl.dropdownMenu) {
	        dropdownCtrl.dropdownMenu = element;
	      }
	    }
	  };
	}).directive('uibDropdownToggle', function () {
	  return {
	    require: '?^uibDropdown',
	    link: function link(scope, element, attrs, dropdownCtrl) {
	      if (!dropdownCtrl) {
	        return;
	      }

	      element.addClass('dropdown-toggle');

	      dropdownCtrl.toggleElement = element;

	      var toggleDropdown = function toggleDropdown(event) {
	        event.preventDefault();

	        if (!element.hasClass('disabled') && !attrs.disabled) {
	          scope.$apply(function () {
	            dropdownCtrl.toggle();
	          });
	        }
	      };

	      element.on('click', toggleDropdown);

	      // WAI-ARIA
	      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
	      scope.$watch(dropdownCtrl.isOpen, function (isOpen) {
	        element.attr('aria-expanded', !!isOpen);
	      });

	      scope.$on('$destroy', function () {
	        element.off('click', toggleDropdown);
	      });
	    }
	  };
	});

	angular.module('ui.bootstrap.stackedMap', [])
	/**
	 * A helper, internal data structure that acts as a map but also allows getting / removing
	 * elements in the LIFO order
	 */
	.factory('$$stackedMap', function () {
	  return {
	    createNew: function createNew() {
	      var stack = [];

	      return {
	        add: function add(key, value) {
	          stack.push({
	            key: key,
	            value: value
	          });
	        },
	        get: function get(key) {
	          for (var i = 0; i < stack.length; i++) {
	            if (key === stack[i].key) {
	              return stack[i];
	            }
	          }
	        },
	        keys: function keys() {
	          var keys = [];
	          for (var i = 0; i < stack.length; i++) {
	            keys.push(stack[i].key);
	          }
	          return keys;
	        },
	        top: function top() {
	          return stack[stack.length - 1];
	        },
	        remove: function remove(key) {
	          var idx = -1;
	          for (var i = 0; i < stack.length; i++) {
	            if (key === stack[i].key) {
	              idx = i;
	              break;
	            }
	          }
	          return stack.splice(idx, 1)[0];
	        },
	        removeTop: function removeTop() {
	          return stack.pop();
	        },
	        length: function length() {
	          return stack.length;
	        }
	      };
	    }
	  };
	});
	angular.module('ui.bootstrap.modal', ['ui.bootstrap.multiMap', 'ui.bootstrap.stackedMap', 'ui.bootstrap.position'])
	/**
	 * Pluggable resolve mechanism for the modal resolve resolution
	 * Supports UI Router's $resolve service
	 */
	.provider('$uibResolve', function () {
	  var resolve = this;
	  this.resolver = null;

	  this.setResolver = function (resolver) {
	    this.resolver = resolver;
	  };

	  this.$get = ['$injector', '$q', function ($injector, $q) {
	    var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
	    return {
	      resolve: function resolve(invocables, locals, parent, self) {
	        if (resolver) {
	          return resolver.resolve(invocables, locals, parent, self);
	        }

	        var promises = [];

	        angular.forEach(invocables, function (value) {
	          if (angular.isFunction(value) || angular.isArray(value)) {
	            promises.push($q.resolve($injector.invoke(value)));
	          } else if (angular.isString(value)) {
	            promises.push($q.resolve($injector.get(value)));
	          } else {
	            promises.push($q.resolve(value));
	          }
	        });

	        return $q.all(promises).then(function (resolves) {
	          var resolveObj = {};
	          var resolveIter = 0;
	          angular.forEach(invocables, function (value, key) {
	            resolveObj[key] = resolves[resolveIter++];
	          });

	          return resolveObj;
	        });
	      }
	    };
	  }];
	})

	/**
	 * A helper directive for the $modal service. It creates a backdrop element.
	 */
	.directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack', function ($animate, $injector, $modalStack) {
	  return {
	    restrict: 'A',
	    compile: function compile(tElement, tAttrs) {
	      tElement.addClass(tAttrs.backdropClass);
	      return linkFn;
	    }
	  };

	  function linkFn(scope, element, attrs) {
	    if (attrs.modalInClass) {
	      $animate.addClass(element, attrs.modalInClass);

	      scope.$on($modalStack.NOW_CLOSING_EVENT, function (e, setIsAsync) {
	        var done = setIsAsync();
	        if (scope.modalOptions.animation) {
	          $animate.removeClass(element, attrs.modalInClass).then(done);
	        } else {
	          done();
	        }
	      });
	    }
	  }
	}]).directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document', function ($modalStack, $q, $animateCss, $document) {
	  return {
	    scope: {
	      index: '@'
	    },
	    restrict: 'A',
	    transclude: true,
	    templateUrl: function templateUrl(tElement, tAttrs) {
	      return tAttrs.templateUrl || 'uib/template/modal/window.html';
	    },
	    link: function link(scope, element, attrs) {
	      element.addClass(attrs.windowTopClass || '');
	      scope.size = attrs.size;

	      scope.close = function (evt) {
	        var modal = $modalStack.getTop();
	        if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && evt.target === evt.currentTarget) {
	          evt.preventDefault();
	          evt.stopPropagation();
	          $modalStack.dismiss(modal.key, 'backdrop click');
	        }
	      };

	      // moved from template to fix issue #2280
	      element.on('click', scope.close);

	      // This property is only added to the scope for the purpose of detecting when this directive is rendered.
	      // We can detect that by using this property in the template associated with this directive and then use
	      // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
	      scope.$isRendered = true;

	      // Deferred object that will be resolved when this modal is rendered.
	      var modalRenderDeferObj = $q.defer();
	      // Resolve render promise post-digest
	      scope.$$postDigest(function () {
	        modalRenderDeferObj.resolve();
	      });

	      modalRenderDeferObj.promise.then(function () {
	        var animationPromise = null;

	        if (attrs.modalInClass) {
	          animationPromise = $animateCss(element, {
	            addClass: attrs.modalInClass
	          }).start();

	          scope.$on($modalStack.NOW_CLOSING_EVENT, function (e, setIsAsync) {
	            var done = setIsAsync();
	            $animateCss(element, {
	              removeClass: attrs.modalInClass
	            }).start().then(done);
	          });
	        }

	        $q.when(animationPromise).then(function () {
	          // Notify {@link $modalStack} that modal is rendered.
	          var modal = $modalStack.getTop();
	          if (modal) {
	            $modalStack.modalRendered(modal.key);
	          }

	          /**
	           * If something within the freshly-opened modal already has focus (perhaps via a
	           * directive that causes focus) then there's no need to try to focus anything.
	           */
	          if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
	            var inputWithAutofocus = element[0].querySelector('[autofocus]');
	            /**
	             * Auto-focusing of a freshly-opened modal element causes any child elements
	             * with the autofocus attribute to lose focus. This is an issue on touch
	             * based devices which will show and then hide the onscreen keyboard.
	             * Attempts to refocus the autofocus element via JavaScript will not reopen
	             * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
	             * the modal element if the modal does not contain an autofocus element.
	             */
	            if (inputWithAutofocus) {
	              inputWithAutofocus.focus();
	            } else {
	              element[0].focus();
	            }
	          }
	        });
	      });
	    }
	  };
	}]).directive('uibModalAnimationClass', function () {
	  return {
	    compile: function compile(tElement, tAttrs) {
	      if (tAttrs.modalAnimation) {
	        tElement.addClass(tAttrs.uibModalAnimationClass);
	      }
	    }
	  };
	}).directive('uibModalTransclude', ['$animate', function ($animate) {
	  return {
	    link: function link(scope, element, attrs, controller, transclude) {
	      transclude(scope.$parent, function (clone) {
	        element.empty();
	        $animate.enter(clone, element);
	      });
	    }
	  };
	}]).factory('$uibModalStack', ['$animate', '$animateCss', '$document', '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition', function ($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
	  var OPENED_MODAL_CLASS = 'modal-open';

	  var backdropDomEl, backdropScope;
	  var openedWindows = $$stackedMap.createNew();
	  var openedClasses = $$multiMap.createNew();
	  var $modalStack = {
	    NOW_CLOSING_EVENT: 'modal.stack.now-closing'
	  };
	  var topModalIndex = 0;
	  var previousTopOpenedModal = null;
	  var ARIA_HIDDEN_ATTRIBUTE_NAME = 'data-bootstrap-modal-aria-hidden-count';

	  //Modal focus behavior
	  var tabbableSelector = 'a[href], area[href], input:not([disabled]):not([tabindex=\'-1\']), ' + 'button:not([disabled]):not([tabindex=\'-1\']),select:not([disabled]):not([tabindex=\'-1\']), textarea:not([disabled]):not([tabindex=\'-1\']), ' + 'iframe, object, embed, *[tabindex]:not([tabindex=\'-1\']), *[contenteditable=true]';
	  var scrollbarPadding;
	  var SNAKE_CASE_REGEXP = /[A-Z]/g;

	  // TODO: extract into common dependency with tooltip
	  function snake_case(name) {
	    var separator = '-';
	    return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
	      return (pos ? separator : '') + letter.toLowerCase();
	    });
	  }

	  function isVisible(element) {
	    return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
	  }

	  function backdropIndex() {
	    var topBackdropIndex = -1;
	    var opened = openedWindows.keys();
	    for (var i = 0; i < opened.length; i++) {
	      if (openedWindows.get(opened[i]).value.backdrop) {
	        topBackdropIndex = i;
	      }
	    }

	    // If any backdrop exist, ensure that it's index is always
	    // right below the top modal
	    if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {
	      topBackdropIndex = topModalIndex;
	    }
	    return topBackdropIndex;
	  }

	  $rootScope.$watch(backdropIndex, function (newBackdropIndex) {
	    if (backdropScope) {
	      backdropScope.index = newBackdropIndex;
	    }
	  });

	  function removeModalWindow(modalInstance, elementToReceiveFocus) {
	    var modalWindow = openedWindows.get(modalInstance).value;
	    var appendToElement = modalWindow.appendTo;

	    //clean up the stack
	    openedWindows.remove(modalInstance);
	    previousTopOpenedModal = openedWindows.top();
	    if (previousTopOpenedModal) {
	      topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);
	    }

	    removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function () {
	      var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
	      openedClasses.remove(modalBodyClass, modalInstance);
	      var areAnyOpen = openedClasses.hasKey(modalBodyClass);
	      appendToElement.toggleClass(modalBodyClass, areAnyOpen);
	      if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
	        if (scrollbarPadding.originalRight) {
	          appendToElement.css({ paddingRight: scrollbarPadding.originalRight + 'px' });
	        } else {
	          appendToElement.css({ paddingRight: '' });
	        }
	        scrollbarPadding = null;
	      }
	      toggleTopWindowClass(true);
	    }, modalWindow.closedDeferred);
	    checkRemoveBackdrop();

	    //move focus to specified element if available, or else to body
	    if (elementToReceiveFocus && elementToReceiveFocus.focus) {
	      elementToReceiveFocus.focus();
	    } else if (appendToElement.focus) {
	      appendToElement.focus();
	    }
	  }

	  // Add or remove "windowTopClass" from the top window in the stack
	  function toggleTopWindowClass(toggleSwitch) {
	    var modalWindow;

	    if (openedWindows.length() > 0) {
	      modalWindow = openedWindows.top().value;
	      modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
	    }
	  }

	  function checkRemoveBackdrop() {
	    //remove backdrop if no longer needed
	    if (backdropDomEl && backdropIndex() === -1) {
	      var backdropScopeRef = backdropScope;
	      removeAfterAnimate(backdropDomEl, backdropScope, function () {
	        backdropScopeRef = null;
	      });
	      backdropDomEl = undefined;
	      backdropScope = undefined;
	    }
	  }

	  function removeAfterAnimate(domEl, scope, done, closedDeferred) {
	    var asyncDeferred;
	    var asyncPromise = null;
	    var setIsAsync = function setIsAsync() {
	      if (!asyncDeferred) {
	        asyncDeferred = $q.defer();
	        asyncPromise = asyncDeferred.promise;
	      }

	      return function asyncDone() {
	        asyncDeferred.resolve();
	      };
	    };
	    scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);

	    // Note that it's intentional that asyncPromise might be null.
	    // That's when setIsAsync has not been called during the
	    // NOW_CLOSING_EVENT broadcast.
	    return $q.when(asyncPromise).then(afterAnimating);

	    function afterAnimating() {
	      if (afterAnimating.done) {
	        return;
	      }
	      afterAnimating.done = true;

	      $animate.leave(domEl).then(function () {
	        if (done) {
	          done();
	        }

	        domEl.remove();
	        if (closedDeferred) {
	          closedDeferred.resolve();
	        }
	      });

	      scope.$destroy();
	    }
	  }

	  $document.on('keydown', keydownListener);

	  $rootScope.$on('$destroy', function () {
	    $document.off('keydown', keydownListener);
	  });

	  function keydownListener(evt) {
	    if (evt.isDefaultPrevented()) {
	      return evt;
	    }

	    var modal = openedWindows.top();
	    if (modal) {
	      switch (evt.which) {
	        case 27:
	          {
	            if (modal.value.keyboard) {
	              evt.preventDefault();
	              $rootScope.$apply(function () {
	                $modalStack.dismiss(modal.key, 'escape key press');
	              });
	            }
	            break;
	          }
	        case 9:
	          {
	            var list = $modalStack.loadFocusElementList(modal);
	            var focusChanged = false;
	            if (evt.shiftKey) {
	              if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {
	                focusChanged = $modalStack.focusLastFocusableElement(list);
	              }
	            } else {
	              if ($modalStack.isFocusInLastItem(evt, list)) {
	                focusChanged = $modalStack.focusFirstFocusableElement(list);
	              }
	            }

	            if (focusChanged) {
	              evt.preventDefault();
	              evt.stopPropagation();
	            }

	            break;
	          }
	      }
	    }
	  }

	  $modalStack.open = function (modalInstance, modal) {
	    var modalOpener = $document[0].activeElement,
	        modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;

	    toggleTopWindowClass(false);

	    // Store the current top first, to determine what index we ought to use
	    // for the current top modal
	    previousTopOpenedModal = openedWindows.top();

	    openedWindows.add(modalInstance, {
	      deferred: modal.deferred,
	      renderDeferred: modal.renderDeferred,
	      closedDeferred: modal.closedDeferred,
	      modalScope: modal.scope,
	      backdrop: modal.backdrop,
	      keyboard: modal.keyboard,
	      openedClass: modal.openedClass,
	      windowTopClass: modal.windowTopClass,
	      animation: modal.animation,
	      appendTo: modal.appendTo
	    });

	    openedClasses.put(modalBodyClass, modalInstance);

	    var appendToElement = modal.appendTo,
	        currBackdropIndex = backdropIndex();

	    if (currBackdropIndex >= 0 && !backdropDomEl) {
	      backdropScope = $rootScope.$new(true);
	      backdropScope.modalOptions = modal;
	      backdropScope.index = currBackdropIndex;
	      backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
	      backdropDomEl.attr({
	        'class': 'modal-backdrop',
	        'ng-style': '{\'z-index\': 1040 + (index && 1 || 0) + index*10}',
	        'uib-modal-animation-class': 'fade',
	        'modal-in-class': 'in'
	      });
	      if (modal.backdropClass) {
	        backdropDomEl.addClass(modal.backdropClass);
	      }

	      if (modal.animation) {
	        backdropDomEl.attr('modal-animation', 'true');
	      }
	      $compile(backdropDomEl)(backdropScope);
	      $animate.enter(backdropDomEl, appendToElement);
	      if ($uibPosition.isScrollable(appendToElement)) {
	        scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);
	        if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
	          appendToElement.css({ paddingRight: scrollbarPadding.right + 'px' });
	        }
	      }
	    }

	    var content;
	    if (modal.component) {
	      content = document.createElement(snake_case(modal.component.name));
	      content = angular.element(content);
	      content.attr({
	        resolve: '$resolve',
	        'modal-instance': '$uibModalInstance',
	        close: '$close($value)',
	        dismiss: '$dismiss($value)'
	      });
	    } else {
	      content = modal.content;
	    }

	    // Set the top modal index based on the index of the previous top modal
	    topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;
	    var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
	    angularDomEl.attr({
	      'class': 'modal',
	      'template-url': modal.windowTemplateUrl,
	      'window-top-class': modal.windowTopClass,
	      'role': 'dialog',
	      'aria-labelledby': modal.ariaLabelledBy,
	      'aria-describedby': modal.ariaDescribedBy,
	      'size': modal.size,
	      'index': topModalIndex,
	      'animate': 'animate',
	      'ng-style': '{\'z-index\': 1050 + $$topModalIndex*10, display: \'block\'}',
	      'tabindex': -1,
	      'uib-modal-animation-class': 'fade',
	      'modal-in-class': 'in'
	    }).append(content);
	    if (modal.windowClass) {
	      angularDomEl.addClass(modal.windowClass);
	    }

	    if (modal.animation) {
	      angularDomEl.attr('modal-animation', 'true');
	    }

	    appendToElement.addClass(modalBodyClass);
	    if (modal.scope) {
	      // we need to explicitly add the modal index to the modal scope
	      // because it is needed by ngStyle to compute the zIndex property.
	      modal.scope.$$topModalIndex = topModalIndex;
	    }
	    $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);

	    openedWindows.top().value.modalDomEl = angularDomEl;
	    openedWindows.top().value.modalOpener = modalOpener;

	    applyAriaHidden(angularDomEl);

	    function applyAriaHidden(el) {
	      if (!el || el[0].tagName === 'BODY') {
	        return;
	      }

	      getSiblings(el).forEach(function (sibling) {
	        var elemIsAlreadyHidden = sibling.getAttribute('aria-hidden') === 'true',
	            ariaHiddenCount = parseInt(sibling.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10);

	        if (!ariaHiddenCount) {
	          ariaHiddenCount = elemIsAlreadyHidden ? 1 : 0;
	        }

	        sibling.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, ariaHiddenCount + 1);
	        sibling.setAttribute('aria-hidden', 'true');
	      });

	      return applyAriaHidden(el.parent());

	      function getSiblings(el) {
	        var children = el.parent() ? el.parent().children() : [];

	        return Array.prototype.filter.call(children, function (child) {
	          return child !== el[0];
	        });
	      }
	    }
	  };

	  function broadcastClosing(modalWindow, resultOrReason, closing) {
	    return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
	  }

	  function unhideBackgroundElements() {
	    Array.prototype.forEach.call(document.querySelectorAll('[' + ARIA_HIDDEN_ATTRIBUTE_NAME + ']'), function (hiddenEl) {
	      var ariaHiddenCount = parseInt(hiddenEl.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10),
	          newHiddenCount = ariaHiddenCount - 1;
	      hiddenEl.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, newHiddenCount);

	      if (!newHiddenCount) {
	        hiddenEl.removeAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME);
	        hiddenEl.removeAttribute('aria-hidden');
	      }
	    });
	  }

	  $modalStack.close = function (modalInstance, result) {
	    var modalWindow = openedWindows.get(modalInstance);
	    unhideBackgroundElements();
	    if (modalWindow && broadcastClosing(modalWindow, result, true)) {
	      modalWindow.value.modalScope.$$uibDestructionScheduled = true;
	      modalWindow.value.deferred.resolve(result);
	      removeModalWindow(modalInstance, modalWindow.value.modalOpener);
	      return true;
	    }

	    return !modalWindow;
	  };

	  $modalStack.dismiss = function (modalInstance, reason) {
	    var modalWindow = openedWindows.get(modalInstance);
	    unhideBackgroundElements();
	    if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
	      modalWindow.value.modalScope.$$uibDestructionScheduled = true;
	      modalWindow.value.deferred.reject(reason);
	      removeModalWindow(modalInstance, modalWindow.value.modalOpener);
	      return true;
	    }
	    return !modalWindow;
	  };

	  $modalStack.dismissAll = function (reason) {
	    var topModal = this.getTop();
	    while (topModal && this.dismiss(topModal.key, reason)) {
	      topModal = this.getTop();
	    }
	  };

	  $modalStack.getTop = function () {
	    return openedWindows.top();
	  };

	  $modalStack.modalRendered = function (modalInstance) {
	    var modalWindow = openedWindows.get(modalInstance);
	    if (modalWindow) {
	      modalWindow.value.renderDeferred.resolve();
	    }
	  };

	  $modalStack.focusFirstFocusableElement = function (list) {
	    if (list.length > 0) {
	      list[0].focus();
	      return true;
	    }
	    return false;
	  };

	  $modalStack.focusLastFocusableElement = function (list) {
	    if (list.length > 0) {
	      list[list.length - 1].focus();
	      return true;
	    }
	    return false;
	  };

	  $modalStack.isModalFocused = function (evt, modalWindow) {
	    if (evt && modalWindow) {
	      var modalDomEl = modalWindow.value.modalDomEl;
	      if (modalDomEl && modalDomEl.length) {
	        return (evt.target || evt.srcElement) === modalDomEl[0];
	      }
	    }
	    return false;
	  };

	  $modalStack.isFocusInFirstItem = function (evt, list) {
	    if (list.length > 0) {
	      return (evt.target || evt.srcElement) === list[0];
	    }
	    return false;
	  };

	  $modalStack.isFocusInLastItem = function (evt, list) {
	    if (list.length > 0) {
	      return (evt.target || evt.srcElement) === list[list.length - 1];
	    }
	    return false;
	  };

	  $modalStack.loadFocusElementList = function (modalWindow) {
	    if (modalWindow) {
	      var modalDomE1 = modalWindow.value.modalDomEl;
	      if (modalDomE1 && modalDomE1.length) {
	        var elements = modalDomE1[0].querySelectorAll(tabbableSelector);
	        return elements ? Array.prototype.filter.call(elements, function (element) {
	          return isVisible(element);
	        }) : elements;
	      }
	    }
	  };

	  return $modalStack;
	}]).provider('$uibModal', function () {
	  var $modalProvider = {
	    options: {
	      animation: true,
	      backdrop: true, //can also be false or 'static'
	      keyboard: true
	    },
	    $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack', function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
	      var $modal = {};

	      function getTemplatePromise(options) {
	        return options.template ? $q.when(options.template) : $templateRequest(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl);
	      }

	      var promiseChain = null;
	      $modal.getPromiseChain = function () {
	        return promiseChain;
	      };

	      $modal.open = function (modalOptions) {
	        var modalResultDeferred = $q.defer();
	        var modalOpenedDeferred = $q.defer();
	        var modalClosedDeferred = $q.defer();
	        var modalRenderDeferred = $q.defer();

	        //prepare an instance of a modal to be injected into controllers and returned to a caller
	        var modalInstance = {
	          result: modalResultDeferred.promise,
	          opened: modalOpenedDeferred.promise,
	          closed: modalClosedDeferred.promise,
	          rendered: modalRenderDeferred.promise,
	          close: function close(result) {
	            return $modalStack.close(modalInstance, result);
	          },
	          dismiss: function dismiss(reason) {
	            return $modalStack.dismiss(modalInstance, reason);
	          }
	        };

	        //merge and clean up options
	        modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
	        modalOptions.resolve = modalOptions.resolve || {};
	        modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);

	        if (!modalOptions.appendTo.length) {
	          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
	        }

	        //verify options
	        if (!modalOptions.component && !modalOptions.template && !modalOptions.templateUrl) {
	          throw new Error('One of component or template or templateUrl options is required.');
	        }

	        var templateAndResolvePromise;
	        if (modalOptions.component) {
	          templateAndResolvePromise = $q.when($uibResolve.resolve(modalOptions.resolve, {}, null, null));
	        } else {
	          templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);
	        }

	        function resolveWithTemplate() {
	          return templateAndResolvePromise;
	        }

	        // Wait for the resolution of the existing promise chain.
	        // Then switch to our own combined promise dependency (regardless of how the previous modal fared).
	        // Then add to $modalStack and resolve opened.
	        // Finally clean up the chain variable if no subsequent modal has overwritten it.
	        var samePromise;
	        samePromise = promiseChain = $q.all([promiseChain]).then(resolveWithTemplate, resolveWithTemplate).then(function resolveSuccess(tplAndVars) {
	          var providedScope = modalOptions.scope || $rootScope;

	          var modalScope = providedScope.$new();
	          modalScope.$close = modalInstance.close;
	          modalScope.$dismiss = modalInstance.dismiss;

	          modalScope.$on('$destroy', function () {
	            if (!modalScope.$$uibDestructionScheduled) {
	              modalScope.$dismiss('$uibUnscheduledDestruction');
	            }
	          });

	          var modal = {
	            scope: modalScope,
	            deferred: modalResultDeferred,
	            renderDeferred: modalRenderDeferred,
	            closedDeferred: modalClosedDeferred,
	            animation: modalOptions.animation,
	            backdrop: modalOptions.backdrop,
	            keyboard: modalOptions.keyboard,
	            backdropClass: modalOptions.backdropClass,
	            windowTopClass: modalOptions.windowTopClass,
	            windowClass: modalOptions.windowClass,
	            windowTemplateUrl: modalOptions.windowTemplateUrl,
	            ariaLabelledBy: modalOptions.ariaLabelledBy,
	            ariaDescribedBy: modalOptions.ariaDescribedBy,
	            size: modalOptions.size,
	            openedClass: modalOptions.openedClass,
	            appendTo: modalOptions.appendTo
	          };

	          var component = {};
	          var ctrlInstance,
	              ctrlInstantiate,
	              ctrlLocals = {};

	          if (modalOptions.component) {
	            constructLocals(component, false, true, false);
	            component.name = modalOptions.component;
	            modal.component = component;
	          } else if (modalOptions.controller) {
	            constructLocals(ctrlLocals, true, false, true);

	            // the third param will make the controller instantiate later,private api
	            // @see https://github.com/angular/angular.js/blob/master/src/ng/controller.js#L126
	            ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);
	            if (modalOptions.controllerAs && modalOptions.bindToController) {
	              ctrlInstance = ctrlInstantiate.instance;
	              ctrlInstance.$close = modalScope.$close;
	              ctrlInstance.$dismiss = modalScope.$dismiss;
	              angular.extend(ctrlInstance, {
	                $resolve: ctrlLocals.$scope.$resolve
	              }, providedScope);
	            }

	            ctrlInstance = ctrlInstantiate();

	            if (angular.isFunction(ctrlInstance.$onInit)) {
	              ctrlInstance.$onInit();
	            }
	          }

	          if (!modalOptions.component) {
	            modal.content = tplAndVars[0];
	          }

	          $modalStack.open(modalInstance, modal);
	          modalOpenedDeferred.resolve(true);

	          function constructLocals(obj, template, instanceOnScope, injectable) {
	            obj.$scope = modalScope;
	            obj.$scope.$resolve = {};
	            if (instanceOnScope) {
	              obj.$scope.$uibModalInstance = modalInstance;
	            } else {
	              obj.$uibModalInstance = modalInstance;
	            }

	            var resolves = template ? tplAndVars[1] : tplAndVars;
	            angular.forEach(resolves, function (value, key) {
	              if (injectable) {
	                obj[key] = value;
	              }

	              obj.$scope.$resolve[key] = value;
	            });
	          }
	        }, function resolveError(reason) {
	          modalOpenedDeferred.reject(reason);
	          modalResultDeferred.reject(reason);
	        })['finally'](function () {
	          if (promiseChain === samePromise) {
	            promiseChain = null;
	          }
	        });

	        return modalInstance;
	      };

	      return $modal;
	    }]
	  };

	  return $modalProvider;
	});

	angular.module('ui.bootstrap.paging', [])
	/**
	 * Helper internal service for generating common controller code between the
	 * pager and pagination components
	 */
	.factory('uibPaging', ['$parse', function ($parse) {
	  return {
	    create: function create(ctrl, $scope, $attrs) {
	      ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
	      ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl
	      ctrl._watchers = [];

	      ctrl.init = function (ngModelCtrl, config) {
	        ctrl.ngModelCtrl = ngModelCtrl;
	        ctrl.config = config;

	        ngModelCtrl.$render = function () {
	          ctrl.render();
	        };

	        if ($attrs.itemsPerPage) {
	          ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function (value) {
	            ctrl.itemsPerPage = parseInt(value, 10);
	            $scope.totalPages = ctrl.calculateTotalPages();
	            ctrl.updatePage();
	          }));
	        } else {
	          ctrl.itemsPerPage = config.itemsPerPage;
	        }

	        $scope.$watch('totalItems', function (newTotal, oldTotal) {
	          if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
	            $scope.totalPages = ctrl.calculateTotalPages();
	            ctrl.updatePage();
	          }
	        });
	      };

	      ctrl.calculateTotalPages = function () {
	        var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
	        return Math.max(totalPages || 0, 1);
	      };

	      ctrl.render = function () {
	        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
	      };

	      $scope.selectPage = function (page, evt) {
	        if (evt) {
	          evt.preventDefault();
	        }

	        var clickAllowed = !$scope.ngDisabled || !evt;
	        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
	          if (evt && evt.target) {
	            evt.target.blur();
	          }
	          ctrl.ngModelCtrl.$setViewValue(page);
	          ctrl.ngModelCtrl.$render();
	        }
	      };

	      $scope.getText = function (key) {
	        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
	      };

	      $scope.noPrevious = function () {
	        return $scope.page === 1;
	      };

	      $scope.noNext = function () {
	        return $scope.page === $scope.totalPages;
	      };

	      ctrl.updatePage = function () {
	        ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable

	        if ($scope.page > $scope.totalPages) {
	          $scope.selectPage($scope.totalPages);
	        } else {
	          ctrl.ngModelCtrl.$render();
	        }
	      };

	      $scope.$on('$destroy', function () {
	        while (ctrl._watchers.length) {
	          ctrl._watchers.shift()();
	        }
	      });
	    }
	  };
	}]);

	angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex']).controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function ($scope, $attrs, uibPaging, uibPagerConfig) {
	  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;

	  uibPaging.create(this, $scope, $attrs);
	}]).constant('uibPagerConfig', {
	  itemsPerPage: 10,
	  previousText: '« Previous',
	  nextText: 'Next »',
	  align: true
	}).directive('uibPager', ['uibPagerConfig', function (uibPagerConfig) {
	  return {
	    scope: {
	      totalItems: '=',
	      previousText: '@',
	      nextText: '@',
	      ngDisabled: '='
	    },
	    require: ['uibPager', '?ngModel'],
	    restrict: 'A',
	    controller: 'UibPagerController',
	    controllerAs: 'pager',
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.templateUrl || 'uib/template/pager/pager.html';
	    },
	    link: function link(scope, element, attrs, ctrls) {
	      element.addClass('pager');
	      var paginationCtrl = ctrls[0],
	          ngModelCtrl = ctrls[1];

	      if (!ngModelCtrl) {
	        return; // do nothing if no ng-model
	      }

	      paginationCtrl.init(ngModelCtrl, uibPagerConfig);
	    }
	  };
	}]);

	angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex']).controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function ($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
	  var ctrl = this;
	  // Setup configuration parameters
	  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,
	      rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,
	      forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,
	      boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,
	      pageLabel = angular.isDefined($attrs.pageLabel) ? function (idx) {
	    return $scope.$parent.$eval($attrs.pageLabel, { $page: idx });
	  } : angular.identity;
	  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
	  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;
	  $attrs.$set('role', 'menu');

	  uibPaging.create(this, $scope, $attrs);

	  if ($attrs.maxSize) {
	    ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function (value) {
	      maxSize = parseInt(value, 10);
	      ctrl.render();
	    }));
	  }

	  // Create page object used in template
	  function makePage(number, text, isActive) {
	    return {
	      number: number,
	      text: text,
	      active: isActive
	    };
	  }

	  function getPages(currentPage, totalPages) {
	    var pages = [];

	    // Default page limits
	    var startPage = 1,
	        endPage = totalPages;
	    var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;

	    // recompute if maxSize
	    if (isMaxSized) {
	      if (rotate) {
	        // Current page is displayed in the middle of the visible ones
	        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
	        endPage = startPage + maxSize - 1;

	        // Adjust if limit is exceeded
	        if (endPage > totalPages) {
	          endPage = totalPages;
	          startPage = endPage - maxSize + 1;
	        }
	      } else {
	        // Visible pages are paginated with maxSize
	        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;

	        // Adjust last page if limit is exceeded
	        endPage = Math.min(startPage + maxSize - 1, totalPages);
	      }
	    }

	    // Add page number links
	    for (var number = startPage; number <= endPage; number++) {
	      var page = makePage(number, pageLabel(number), number === currentPage);
	      pages.push(page);
	    }

	    // Add links to move between page sets
	    if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
	      if (startPage > 1) {
	        if (!boundaryLinkNumbers || startPage > 3) {
	          //need ellipsis for all options unless range is too close to beginning
	          var previousPageSet = makePage(startPage - 1, '...', false);
	          pages.unshift(previousPageSet);
	        }
	        if (boundaryLinkNumbers) {
	          if (startPage === 3) {
	            //need to replace ellipsis when the buttons would be sequential
	            var secondPageLink = makePage(2, '2', false);
	            pages.unshift(secondPageLink);
	          }
	          //add the first page
	          var firstPageLink = makePage(1, '1', false);
	          pages.unshift(firstPageLink);
	        }
	      }

	      if (endPage < totalPages) {
	        if (!boundaryLinkNumbers || endPage < totalPages - 2) {
	          //need ellipsis for all options unless range is too close to end
	          var nextPageSet = makePage(endPage + 1, '...', false);
	          pages.push(nextPageSet);
	        }
	        if (boundaryLinkNumbers) {
	          if (endPage === totalPages - 2) {
	            //need to replace ellipsis when the buttons would be sequential
	            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
	            pages.push(secondToLastPageLink);
	          }
	          //add the last page
	          var lastPageLink = makePage(totalPages, totalPages, false);
	          pages.push(lastPageLink);
	        }
	      }
	    }
	    return pages;
	  }

	  var originalRender = this.render;
	  this.render = function () {
	    originalRender();
	    if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
	      $scope.pages = getPages($scope.page, $scope.totalPages);
	    }
	  };
	}]).constant('uibPaginationConfig', {
	  itemsPerPage: 10,
	  boundaryLinks: false,
	  boundaryLinkNumbers: false,
	  directionLinks: true,
	  firstText: 'First',
	  previousText: 'Previous',
	  nextText: 'Next',
	  lastText: 'Last',
	  rotate: true,
	  forceEllipses: false
	}).directive('uibPagination', ['$parse', 'uibPaginationConfig', function ($parse, uibPaginationConfig) {
	  return {
	    scope: {
	      totalItems: '=',
	      firstText: '@',
	      previousText: '@',
	      nextText: '@',
	      lastText: '@',
	      ngDisabled: '='
	    },
	    require: ['uibPagination', '?ngModel'],
	    restrict: 'A',
	    controller: 'UibPaginationController',
	    controllerAs: 'pagination',
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.templateUrl || 'uib/template/pagination/pagination.html';
	    },
	    link: function link(scope, element, attrs, ctrls) {
	      element.addClass('pagination');
	      var paginationCtrl = ctrls[0],
	          ngModelCtrl = ctrls[1];

	      if (!ngModelCtrl) {
	        return; // do nothing if no ng-model
	      }

	      paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
	    }
	  };
	}]);

	/**
	 * The following features are still outstanding: animation as a
	 * function, placement as a function, inside, support for more triggers than
	 * just mouse enter/leave, html tooltips, and selector delegation.
	 */
	angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])

	/**
	 * The $tooltip service creates tooltip- and popover-like directives as well as
	 * houses global options for them.
	 */
	.provider('$uibTooltip', function () {
	  // The default options tooltip and popover.
	  var defaultOptions = {
	    placement: 'top',
	    placementClassPrefix: '',
	    animation: true,
	    popupDelay: 0,
	    popupCloseDelay: 0,
	    useContentExp: false
	  };

	  // Default hide triggers for each show trigger
	  var triggerMap = {
	    'mouseenter': 'mouseleave',
	    'click': 'click',
	    'outsideClick': 'outsideClick',
	    'focus': 'blur',
	    'none': ''
	  };

	  // The options specified to the provider globally.
	  var globalOptions = {};

	  /**
	   * `options({})` allows global configuration of all tooltips in the
	   * application.
	   *
	   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
	   *     // place tooltips left instead of top by default
	   *     $tooltipProvider.options( { placement: 'left' } );
	   *   });
	   */
	  this.options = function (value) {
	    angular.extend(globalOptions, value);
	  };

	  /**
	   * This allows you to extend the set of trigger mappings available. E.g.:
	   *
	   *   $tooltipProvider.setTriggers( { 'openTrigger': 'closeTrigger' } );
	   */
	  this.setTriggers = function setTriggers(triggers) {
	    angular.extend(triggerMap, triggers);
	  };

	  /**
	   * This is a helper function for translating camel-case to snake_case.
	   */
	  function snake_case(name) {
	    var regexp = /[A-Z]/g;
	    var separator = '-';
	    return name.replace(regexp, function (letter, pos) {
	      return (pos ? separator : '') + letter.toLowerCase();
	    });
	  }

	  /**
	   * Returns the actual instance of the $tooltip service.
	   * TODO support multiple triggers
	   */
	  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function ($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
	    var openedTooltips = $$stackedMap.createNew();
	    $document.on('keyup', keypressListener);

	    $rootScope.$on('$destroy', function () {
	      $document.off('keyup', keypressListener);
	    });

	    function keypressListener(e) {
	      if (e.which === 27) {
	        var last = openedTooltips.top();
	        if (last) {
	          last.value.close();
	          last = null;
	        }
	      }
	    }

	    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
	      options = angular.extend({}, defaultOptions, globalOptions, options);

	      /**
	       * Returns an object of show and hide triggers.
	       *
	       * If a trigger is supplied,
	       * it is used to show the tooltip; otherwise, it will use the `trigger`
	       * option passed to the `$tooltipProvider.options` method; else it will
	       * default to the trigger supplied to this directive factory.
	       *
	       * The hide trigger is based on the show trigger. If the `trigger` option
	       * was passed to the `$tooltipProvider.options` method, it will use the
	       * mapped trigger from `triggerMap` or the passed trigger if the map is
	       * undefined; otherwise, it uses the `triggerMap` value of the show
	       * trigger; else it will just use the show trigger.
	       */
	      function getTriggers(trigger) {
	        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
	        var hide = show.map(function (trigger) {
	          return triggerMap[trigger] || trigger;
	        });
	        return {
	          show: show,
	          hide: hide
	        };
	      }

	      var directiveName = snake_case(ttType);

	      var startSym = $interpolate.startSymbol();
	      var endSym = $interpolate.endSymbol();
	      var template = '<div ' + directiveName + '-popup ' + 'uib-title="' + startSym + 'title' + endSym + '" ' + (options.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + startSym + 'content' + endSym + '" ') + 'origin-scope="origScope" ' + 'class="uib-position-measure ' + prefix + '" ' + 'tooltip-animation-class="fade"' + 'uib-tooltip-classes ' + 'ng-class="{ in: isOpen }" ' + '>' + '</div>';

	      return {
	        compile: function compile(tElem, tAttrs) {
	          var tooltipLinker = $compile(template);

	          return function link(scope, element, attrs, tooltipCtrl) {
	            var tooltip;
	            var tooltipLinkedScope;
	            var transitionTimeout;
	            var showTimeout;
	            var hideTimeout;
	            var positionTimeout;
	            var adjustmentTimeout;
	            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
	            var triggers = getTriggers(undefined);
	            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
	            var ttScope = scope.$new(true);
	            var repositionScheduled = false;
	            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
	            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
	            var observers = [];
	            var lastPlacement;

	            var positionTooltip = function positionTooltip() {
	              // check if tooltip exists and is not empty
	              if (!tooltip || !tooltip.html()) {
	                return;
	              }

	              if (!positionTimeout) {
	                positionTimeout = $timeout(function () {
	                  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
	                  var initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
	                  var elementPos = appendToBody ? $position.offset(element) : $position.position(element);
	                  tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });
	                  var placementClasses = ttPosition.placement.split('-');

	                  if (!tooltip.hasClass(placementClasses[0])) {
	                    tooltip.removeClass(lastPlacement.split('-')[0]);
	                    tooltip.addClass(placementClasses[0]);
	                  }

	                  if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {
	                    tooltip.removeClass(options.placementClassPrefix + lastPlacement);
	                    tooltip.addClass(options.placementClassPrefix + ttPosition.placement);
	                  }

	                  adjustmentTimeout = $timeout(function () {
	                    var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
	                    var adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);
	                    if (adjustment) {
	                      tooltip.css(adjustment);
	                    }
	                    adjustmentTimeout = null;
	                  }, 0, false);

	                  // first time through tt element will have the
	                  // uib-position-measure class or if the placement
	                  // has changed we need to position the arrow.
	                  if (tooltip.hasClass('uib-position-measure')) {
	                    $position.positionArrow(tooltip, ttPosition.placement);
	                    tooltip.removeClass('uib-position-measure');
	                  } else if (lastPlacement !== ttPosition.placement) {
	                    $position.positionArrow(tooltip, ttPosition.placement);
	                  }
	                  lastPlacement = ttPosition.placement;

	                  positionTimeout = null;
	                }, 0, false);
	              }
	            };

	            // Set up the correct scope to allow transclusion later
	            ttScope.origScope = scope;

	            // By default, the tooltip is not open.
	            // TODO add ability to start tooltip opened
	            ttScope.isOpen = false;

	            function toggleTooltipBind() {
	              if (!ttScope.isOpen) {
	                showTooltipBind();
	              } else {
	                hideTooltipBind();
	              }
	            }

	            // Show the tooltip with delay if specified, otherwise show it immediately
	            function showTooltipBind() {
	              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
	                return;
	              }

	              cancelHide();
	              prepareTooltip();

	              if (ttScope.popupDelay) {
	                // Do nothing if the tooltip was already scheduled to pop-up.
	                // This happens if show is triggered multiple times before any hide is triggered.
	                if (!showTimeout) {
	                  showTimeout = $timeout(show, ttScope.popupDelay, false);
	                }
	              } else {
	                show();
	              }
	            }

	            function hideTooltipBind() {
	              cancelShow();

	              if (ttScope.popupCloseDelay) {
	                if (!hideTimeout) {
	                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
	                }
	              } else {
	                hide();
	              }
	            }

	            // Show the tooltip popup element.
	            function show() {
	              cancelShow();
	              cancelHide();

	              // Don't show empty tooltips.
	              if (!ttScope.content) {
	                return angular.noop;
	              }

	              createTooltip();

	              // And show the tooltip.
	              ttScope.$evalAsync(function () {
	                ttScope.isOpen = true;
	                assignIsOpen(true);
	                positionTooltip();
	              });
	            }

	            function cancelShow() {
	              if (showTimeout) {
	                $timeout.cancel(showTimeout);
	                showTimeout = null;
	              }

	              if (positionTimeout) {
	                $timeout.cancel(positionTimeout);
	                positionTimeout = null;
	              }
	            }

	            // Hide the tooltip popup element.
	            function hide() {
	              if (!ttScope) {
	                return;
	              }

	              // First things first: we don't show it anymore.
	              ttScope.$evalAsync(function () {
	                if (ttScope) {
	                  ttScope.isOpen = false;
	                  assignIsOpen(false);
	                  // And now we remove it from the DOM. However, if we have animation, we
	                  // need to wait for it to expire beforehand.
	                  // FIXME: this is a placeholder for a port of the transitions library.
	                  // The fade transition in TWBS is 150ms.
	                  if (ttScope.animation) {
	                    if (!transitionTimeout) {
	                      transitionTimeout = $timeout(removeTooltip, 150, false);
	                    }
	                  } else {
	                    removeTooltip();
	                  }
	                }
	              });
	            }

	            function cancelHide() {
	              if (hideTimeout) {
	                $timeout.cancel(hideTimeout);
	                hideTimeout = null;
	              }

	              if (transitionTimeout) {
	                $timeout.cancel(transitionTimeout);
	                transitionTimeout = null;
	              }
	            }

	            function createTooltip() {
	              // There can only be one tooltip element per directive shown at once.
	              if (tooltip) {
	                return;
	              }

	              tooltipLinkedScope = ttScope.$new();
	              tooltip = tooltipLinker(tooltipLinkedScope, function (tooltip) {
	                if (appendToBody) {
	                  $document.find('body').append(tooltip);
	                } else {
	                  element.after(tooltip);
	                }
	              });

	              openedTooltips.add(ttScope, {
	                close: hide
	              });

	              prepObservers();
	            }

	            function removeTooltip() {
	              cancelShow();
	              cancelHide();
	              unregisterObservers();

	              if (tooltip) {
	                tooltip.remove();

	                tooltip = null;
	                if (adjustmentTimeout) {
	                  $timeout.cancel(adjustmentTimeout);
	                }
	              }

	              openedTooltips.remove(ttScope);

	              if (tooltipLinkedScope) {
	                tooltipLinkedScope.$destroy();
	                tooltipLinkedScope = null;
	              }
	            }

	            /**
	             * Set the initial scope values. Once
	             * the tooltip is created, the observers
	             * will be added to keep things in sync.
	             */
	            function prepareTooltip() {
	              ttScope.title = attrs[prefix + 'Title'];
	              if (contentParse) {
	                ttScope.content = contentParse(scope);
	              } else {
	                ttScope.content = attrs[ttType];
	              }

	              ttScope.popupClass = attrs[prefix + 'Class'];
	              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
	              var placement = $position.parsePlacement(ttScope.placement);
	              lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];

	              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
	              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
	              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
	              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
	            }

	            function assignIsOpen(isOpen) {
	              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
	                isOpenParse.assign(scope, isOpen);
	              }
	            }

	            ttScope.contentExp = function () {
	              return ttScope.content;
	            };

	            /**
	             * Observe the relevant attributes.
	             */
	            attrs.$observe('disabled', function (val) {
	              if (val) {
	                cancelShow();
	              }

	              if (val && ttScope.isOpen) {
	                hide();
	              }
	            });

	            if (isOpenParse) {
	              scope.$watch(isOpenParse, function (val) {
	                if (ttScope && !val === ttScope.isOpen) {
	                  toggleTooltipBind();
	                }
	              });
	            }

	            function prepObservers() {
	              observers.length = 0;

	              if (contentParse) {
	                observers.push(scope.$watch(contentParse, function (val) {
	                  ttScope.content = val;
	                  if (!val && ttScope.isOpen) {
	                    hide();
	                  }
	                }));

	                observers.push(tooltipLinkedScope.$watch(function () {
	                  if (!repositionScheduled) {
	                    repositionScheduled = true;
	                    tooltipLinkedScope.$$postDigest(function () {
	                      repositionScheduled = false;
	                      if (ttScope && ttScope.isOpen) {
	                        positionTooltip();
	                      }
	                    });
	                  }
	                }));
	              } else {
	                observers.push(attrs.$observe(ttType, function (val) {
	                  ttScope.content = val;
	                  if (!val && ttScope.isOpen) {
	                    hide();
	                  } else {
	                    positionTooltip();
	                  }
	                }));
	              }

	              observers.push(attrs.$observe(prefix + 'Title', function (val) {
	                ttScope.title = val;
	                if (ttScope.isOpen) {
	                  positionTooltip();
	                }
	              }));

	              observers.push(attrs.$observe(prefix + 'Placement', function (val) {
	                ttScope.placement = val ? val : options.placement;
	                if (ttScope.isOpen) {
	                  positionTooltip();
	                }
	              }));
	            }

	            function unregisterObservers() {
	              if (observers.length) {
	                angular.forEach(observers, function (observer) {
	                  observer();
	                });
	                observers.length = 0;
	              }
	            }

	            // hide tooltips/popovers for outsideClick trigger
	            function bodyHideTooltipBind(e) {
	              if (!ttScope || !ttScope.isOpen || !tooltip) {
	                return;
	              }
	              // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked
	              if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
	                hideTooltipBind();
	              }
	            }

	            // KeyboardEvent handler to hide the tooltip on Escape key press
	            function hideOnEscapeKey(e) {
	              if (e.which === 27) {
	                hideTooltipBind();
	              }
	            }

	            var unregisterTriggers = function unregisterTriggers() {
	              triggers.show.forEach(function (trigger) {
	                if (trigger === 'outsideClick') {
	                  element.off('click', toggleTooltipBind);
	                } else {
	                  element.off(trigger, showTooltipBind);
	                  element.off(trigger, toggleTooltipBind);
	                }
	                element.off('keypress', hideOnEscapeKey);
	              });
	              triggers.hide.forEach(function (trigger) {
	                if (trigger === 'outsideClick') {
	                  $document.off('click', bodyHideTooltipBind);
	                } else {
	                  element.off(trigger, hideTooltipBind);
	                }
	              });
	            };

	            function prepTriggers() {
	              var showTriggers = [],
	                  hideTriggers = [];
	              var val = scope.$eval(attrs[prefix + 'Trigger']);
	              unregisterTriggers();

	              if (angular.isObject(val)) {
	                Object.keys(val).forEach(function (key) {
	                  showTriggers.push(key);
	                  hideTriggers.push(val[key]);
	                });
	                triggers = {
	                  show: showTriggers,
	                  hide: hideTriggers
	                };
	              } else {
	                triggers = getTriggers(val);
	              }

	              if (triggers.show !== 'none') {
	                triggers.show.forEach(function (trigger, idx) {
	                  if (trigger === 'outsideClick') {
	                    element.on('click', toggleTooltipBind);
	                    $document.on('click', bodyHideTooltipBind);
	                  } else if (trigger === triggers.hide[idx]) {
	                    element.on(trigger, toggleTooltipBind);
	                  } else if (trigger) {
	                    element.on(trigger, showTooltipBind);
	                    element.on(triggers.hide[idx], hideTooltipBind);
	                  }
	                  element.on('keypress', hideOnEscapeKey);
	                });
	              }
	            }

	            prepTriggers();

	            var animation = scope.$eval(attrs[prefix + 'Animation']);
	            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

	            var appendToBodyVal;
	            var appendKey = prefix + 'AppendToBody';
	            if (appendKey in attrs && attrs[appendKey] === undefined) {
	              appendToBodyVal = true;
	            } else {
	              appendToBodyVal = scope.$eval(attrs[appendKey]);
	            }

	            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

	            // Make sure tooltip is destroyed and removed.
	            scope.$on('$destroy', function onDestroyTooltip() {
	              unregisterTriggers();
	              removeTooltip();
	              ttScope = null;
	            });
	          };
	        }
	      };
	    };
	  }];
	})

	// This is mostly ngInclude code but with a custom scope
	.directive('uibTooltipTemplateTransclude', ['$animate', '$sce', '$compile', '$templateRequest', function ($animate, $sce, $compile, $templateRequest) {
	  return {
	    link: function link(scope, elem, attrs) {
	      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

	      var changeCounter = 0,
	          currentScope,
	          previousElement,
	          currentElement;

	      var cleanupLastIncludeContent = function cleanupLastIncludeContent() {
	        if (previousElement) {
	          previousElement.remove();
	          previousElement = null;
	        }

	        if (currentScope) {
	          currentScope.$destroy();
	          currentScope = null;
	        }

	        if (currentElement) {
	          $animate.leave(currentElement).then(function () {
	            previousElement = null;
	          });
	          previousElement = currentElement;
	          currentElement = null;
	        }
	      };

	      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function (src) {
	        var thisChangeId = ++changeCounter;

	        if (src) {
	          //set the 2nd param to true to ignore the template request error so that the inner
	          //contents and scope can be cleaned up.
	          $templateRequest(src, true).then(function (response) {
	            if (thisChangeId !== changeCounter) {
	              return;
	            }
	            var newScope = origScope.$new();
	            var template = response;

	            var clone = $compile(template)(newScope, function (clone) {
	              cleanupLastIncludeContent();
	              $animate.enter(clone, elem);
	            });

	            currentScope = newScope;
	            currentElement = clone;

	            currentScope.$emit('$includeContentLoaded', src);
	          }, function () {
	            if (thisChangeId === changeCounter) {
	              cleanupLastIncludeContent();
	              scope.$emit('$includeContentError', src);
	            }
	          });
	          scope.$emit('$includeContentRequested', src);
	        } else {
	          cleanupLastIncludeContent();
	        }
	      });

	      scope.$on('$destroy', cleanupLastIncludeContent);
	    }
	  };
	}])

	/**
	 * Note that it's intentional that these classes are *not* applied through $animate.
	 * They must not be animated as they're expected to be present on the tooltip on
	 * initialization.
	 */
	.directive('uibTooltipClasses', ['$uibPosition', function ($uibPosition) {
	  return {
	    restrict: 'A',
	    link: function link(scope, element, attrs) {
	      // need to set the primary position so the
	      // arrow has space during position measure.
	      // tooltip.positionTooltip()
	      if (scope.placement) {
	        // // There are no top-left etc... classes
	        // // in TWBS, so we need the primary position.
	        var position = $uibPosition.parsePlacement(scope.placement);
	        element.addClass(position[0]);
	      }

	      if (scope.popupClass) {
	        element.addClass(scope.popupClass);
	      }

	      if (scope.animation) {
	        element.addClass(attrs.tooltipAnimationClass);
	      }
	    }
	  };
	}]).directive('uibTooltipPopup', function () {
	  return {
	    restrict: 'A',
	    scope: { content: '@' },
	    templateUrl: 'uib/template/tooltip/tooltip-popup.html'
	  };
	}).directive('uibTooltip', ['$uibTooltip', function ($uibTooltip) {
	  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
	}]).directive('uibTooltipTemplatePopup', function () {
	  return {
	    restrict: 'A',
	    scope: { contentExp: '&', originScope: '&' },
	    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
	  };
	}).directive('uibTooltipTemplate', ['$uibTooltip', function ($uibTooltip) {
	  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
	    useContentExp: true
	  });
	}]).directive('uibTooltipHtmlPopup', function () {
	  return {
	    restrict: 'A',
	    scope: { contentExp: '&' },
	    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
	  };
	}).directive('uibTooltipHtml', ['$uibTooltip', function ($uibTooltip) {
	  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
	    useContentExp: true
	  });
	}]);

	/**
	 * The following features are still outstanding: popup delay, animation as a
	 * function, placement as a function, inside, support for more triggers than
	 * just mouse enter/leave, and selector delegatation.
	 */
	angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip']).directive('uibPopoverTemplatePopup', function () {
	  return {
	    restrict: 'A',
	    scope: { uibTitle: '@', contentExp: '&', originScope: '&' },
	    templateUrl: 'uib/template/popover/popover-template.html'
	  };
	}).directive('uibPopoverTemplate', ['$uibTooltip', function ($uibTooltip) {
	  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
	    useContentExp: true
	  });
	}]).directive('uibPopoverHtmlPopup', function () {
	  return {
	    restrict: 'A',
	    scope: { contentExp: '&', uibTitle: '@' },
	    templateUrl: 'uib/template/popover/popover-html.html'
	  };
	}).directive('uibPopoverHtml', ['$uibTooltip', function ($uibTooltip) {
	  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
	    useContentExp: true
	  });
	}]).directive('uibPopoverPopup', function () {
	  return {
	    restrict: 'A',
	    scope: { uibTitle: '@', content: '@' },
	    templateUrl: 'uib/template/popover/popover.html'
	  };
	}).directive('uibPopover', ['$uibTooltip', function ($uibTooltip) {
	  return $uibTooltip('uibPopover', 'popover', 'click');
	}]);

	angular.module('ui.bootstrap.progressbar', []).constant('uibProgressConfig', {
	  animate: true,
	  max: 100
	}).controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function ($scope, $attrs, progressConfig) {
	  var self = this,
	      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

	  this.bars = [];
	  $scope.max = getMaxOrDefault();

	  this.addBar = function (bar, element, attrs) {
	    if (!animate) {
	      element.css({ 'transition': 'none' });
	    }

	    this.bars.push(bar);

	    bar.max = getMaxOrDefault();
	    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';

	    bar.$watch('value', function (value) {
	      bar.recalculatePercentage();
	    });

	    bar.recalculatePercentage = function () {
	      var totalPercentage = self.bars.reduce(function (total, bar) {
	        bar.percent = +(100 * bar.value / bar.max).toFixed(2);
	        return total + bar.percent;
	      }, 0);

	      if (totalPercentage > 100) {
	        bar.percent -= totalPercentage - 100;
	      }
	    };

	    bar.$on('$destroy', function () {
	      element = null;
	      self.removeBar(bar);
	    });
	  };

	  this.removeBar = function (bar) {
	    this.bars.splice(this.bars.indexOf(bar), 1);
	    this.bars.forEach(function (bar) {
	      bar.recalculatePercentage();
	    });
	  };

	  //$attrs.$observe('maxParam', function(maxParam) {
	  $scope.$watch('maxParam', function (maxParam) {
	    self.bars.forEach(function (bar) {
	      bar.max = getMaxOrDefault();
	      bar.recalculatePercentage();
	    });
	  });

	  function getMaxOrDefault() {
	    return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
	  }
	}]).directive('uibProgress', function () {
	  return {
	    replace: true,
	    transclude: true,
	    controller: 'UibProgressController',
	    require: 'uibProgress',
	    scope: {
	      maxParam: '=?max'
	    },
	    templateUrl: 'uib/template/progressbar/progress.html'
	  };
	}).directive('uibBar', function () {
	  return {
	    replace: true,
	    transclude: true,
	    require: '^uibProgress',
	    scope: {
	      value: '=',
	      type: '@'
	    },
	    templateUrl: 'uib/template/progressbar/bar.html',
	    link: function link(scope, element, attrs, progressCtrl) {
	      progressCtrl.addBar(scope, element, attrs);
	    }
	  };
	}).directive('uibProgressbar', function () {
	  return {
	    replace: true,
	    transclude: true,
	    controller: 'UibProgressController',
	    scope: {
	      value: '=',
	      maxParam: '=?max',
	      type: '@'
	    },
	    templateUrl: 'uib/template/progressbar/progressbar.html',
	    link: function link(scope, element, attrs, progressCtrl) {
	      progressCtrl.addBar(scope, angular.element(element.children()[0]), { title: attrs.title });
	    }
	  };
	});

	angular.module('ui.bootstrap.rating', []).constant('uibRatingConfig', {
	  max: 5,
	  stateOn: null,
	  stateOff: null,
	  enableReset: true,
	  titles: ['one', 'two', 'three', 'four', 'five']
	}).controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function ($scope, $attrs, ratingConfig) {
	  var ngModelCtrl = { $setViewValue: angular.noop },
	      self = this;

	  this.init = function (ngModelCtrl_) {
	    ngModelCtrl = ngModelCtrl_;
	    ngModelCtrl.$render = this.render;

	    ngModelCtrl.$formatters.push(function (value) {
	      if (angular.isNumber(value) && value << 0 !== value) {
	        value = Math.round(value);
	      }

	      return value;
	    });

	    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
	    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
	    this.enableReset = angular.isDefined($attrs.enableReset) ? $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
	    var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
	    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ? tmpTitles : ratingConfig.titles;

	    var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
	    $scope.range = this.buildTemplateObjects(ratingStates);
	  };

	  this.buildTemplateObjects = function (states) {
	    for (var i = 0, n = states.length; i < n; i++) {
	      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
	    }
	    return states;
	  };

	  this.getTitle = function (index) {
	    if (index >= this.titles.length) {
	      return index + 1;
	    }

	    return this.titles[index];
	  };

	  $scope.rate = function (value) {
	    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
	      var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
	      ngModelCtrl.$setViewValue(newViewValue);
	      ngModelCtrl.$render();
	    }
	  };

	  $scope.enter = function (value) {
	    if (!$scope.readonly) {
	      $scope.value = value;
	    }
	    $scope.onHover({ value: value });
	  };

	  $scope.reset = function () {
	    $scope.value = ngModelCtrl.$viewValue;
	    $scope.onLeave();
	  };

	  $scope.onKeydown = function (evt) {
	    if (/(37|38|39|40)/.test(evt.which)) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
	    }
	  };

	  this.render = function () {
	    $scope.value = ngModelCtrl.$viewValue;
	    $scope.title = self.getTitle($scope.value - 1);
	  };
	}]).directive('uibRating', function () {
	  return {
	    require: ['uibRating', 'ngModel'],
	    restrict: 'A',
	    scope: {
	      readonly: '=?readOnly',
	      onHover: '&',
	      onLeave: '&'
	    },
	    controller: 'UibRatingController',
	    templateUrl: 'uib/template/rating/rating.html',
	    link: function link(scope, element, attrs, ctrls) {
	      var ratingCtrl = ctrls[0],
	          ngModelCtrl = ctrls[1];
	      ratingCtrl.init(ngModelCtrl);
	    }
	  };
	});

	angular.module('ui.bootstrap.tabs', []).controller('UibTabsetController', ['$scope', function ($scope) {
	  var ctrl = this,
	      oldIndex;
	  ctrl.tabs = [];

	  ctrl.select = function (index, evt) {
	    if (!destroyed) {
	      var previousIndex = findTabIndex(oldIndex);
	      var previousSelected = ctrl.tabs[previousIndex];
	      if (previousSelected) {
	        previousSelected.tab.onDeselect({
	          $event: evt,
	          $selectedIndex: index
	        });
	        if (evt && evt.isDefaultPrevented()) {
	          return;
	        }
	        previousSelected.tab.active = false;
	      }

	      var selected = ctrl.tabs[index];
	      if (selected) {
	        selected.tab.onSelect({
	          $event: evt
	        });
	        selected.tab.active = true;
	        ctrl.active = selected.index;
	        oldIndex = selected.index;
	      } else if (!selected && angular.isDefined(oldIndex)) {
	        ctrl.active = null;
	        oldIndex = null;
	      }
	    }
	  };

	  ctrl.addTab = function addTab(tab) {
	    ctrl.tabs.push({
	      tab: tab,
	      index: tab.index
	    });
	    ctrl.tabs.sort(function (t1, t2) {
	      if (t1.index > t2.index) {
	        return 1;
	      }

	      if (t1.index < t2.index) {
	        return -1;
	      }

	      return 0;
	    });

	    if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {
	      var newActiveIndex = findTabIndex(tab.index);
	      ctrl.select(newActiveIndex);
	    }
	  };

	  ctrl.removeTab = function removeTab(tab) {
	    var index;
	    for (var i = 0; i < ctrl.tabs.length; i++) {
	      if (ctrl.tabs[i].tab === tab) {
	        index = i;
	        break;
	      }
	    }

	    if (ctrl.tabs[index].index === ctrl.active) {
	      var newActiveTabIndex = index === ctrl.tabs.length - 1 ? index - 1 : index + 1 % ctrl.tabs.length;
	      ctrl.select(newActiveTabIndex);
	    }

	    ctrl.tabs.splice(index, 1);
	  };

	  $scope.$watch('tabset.active', function (val) {
	    if (angular.isDefined(val) && val !== oldIndex) {
	      ctrl.select(findTabIndex(val));
	    }
	  });

	  var destroyed;
	  $scope.$on('$destroy', function () {
	    destroyed = true;
	  });

	  function findTabIndex(index) {
	    for (var i = 0; i < ctrl.tabs.length; i++) {
	      if (ctrl.tabs[i].index === index) {
	        return i;
	      }
	    }
	  }
	}]).directive('uibTabset', function () {
	  return {
	    transclude: true,
	    replace: true,
	    scope: {},
	    bindToController: {
	      active: '=?',
	      type: '@'
	    },
	    controller: 'UibTabsetController',
	    controllerAs: 'tabset',
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.templateUrl || 'uib/template/tabs/tabset.html';
	    },
	    link: function link(scope, element, attrs) {
	      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
	      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
	    }
	  };
	}).directive('uibTab', ['$parse', function ($parse) {
	  return {
	    require: '^uibTabset',
	    replace: true,
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.templateUrl || 'uib/template/tabs/tab.html';
	    },
	    transclude: true,
	    scope: {
	      heading: '@',
	      index: '=?',
	      classes: '@?',
	      onSelect: '&select', //This callback is called in contentHeadingTransclude
	      //once it inserts the tab's content into the dom
	      onDeselect: '&deselect'
	    },
	    controller: function controller() {
	      //Empty controller so other directives can require being 'under' a tab
	    },
	    controllerAs: 'tab',
	    link: function link(scope, elm, attrs, tabsetCtrl, transclude) {
	      scope.disabled = false;
	      if (attrs.disable) {
	        scope.$parent.$watch($parse(attrs.disable), function (value) {
	          scope.disabled = !!value;
	        });
	      }

	      if (angular.isUndefined(attrs.index)) {
	        if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {
	          scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function (t) {
	            return t.index;
	          })) + 1;
	        } else {
	          scope.index = 0;
	        }
	      }

	      if (angular.isUndefined(attrs.classes)) {
	        scope.classes = '';
	      }

	      scope.select = function (evt) {
	        if (!scope.disabled) {
	          var index;
	          for (var i = 0; i < tabsetCtrl.tabs.length; i++) {
	            if (tabsetCtrl.tabs[i].tab === scope) {
	              index = i;
	              break;
	            }
	          }

	          tabsetCtrl.select(index, evt);
	        }
	      };

	      tabsetCtrl.addTab(scope);
	      scope.$on('$destroy', function () {
	        tabsetCtrl.removeTab(scope);
	      });

	      //We need to transclude later, once the content container is ready.
	      //when this link happens, we're inside a tab heading.
	      scope.$transcludeFn = transclude;
	    }
	  };
	}]).directive('uibTabHeadingTransclude', function () {
	  return {
	    restrict: 'A',
	    require: '^uibTab',
	    link: function link(scope, elm) {
	      scope.$watch('headingElement', function updateHeadingElement(heading) {
	        if (heading) {
	          elm.html('');
	          elm.append(heading);
	        }
	      });
	    }
	  };
	}).directive('uibTabContentTransclude', function () {
	  return {
	    restrict: 'A',
	    require: '^uibTabset',
	    link: function link(scope, elm, attrs) {
	      var tab = scope.$eval(attrs.uibTabContentTransclude).tab;

	      //Now our tab is ready to be transcluded: both the tab heading area
	      //and the tab content area are loaded.  Transclude 'em both.
	      tab.$transcludeFn(tab.$parent, function (contents) {
	        angular.forEach(contents, function (node) {
	          if (isTabHeading(node)) {
	            //Let tabHeadingTransclude know.
	            tab.headingElement = node;
	          } else {
	            elm.append(node);
	          }
	        });
	      });
	    }
	  };

	  function isTabHeading(node) {
	    return node.tagName && (node.hasAttribute('uib-tab-heading') || node.hasAttribute('data-uib-tab-heading') || node.hasAttribute('x-uib-tab-heading') || node.tagName.toLowerCase() === 'uib-tab-heading' || node.tagName.toLowerCase() === 'data-uib-tab-heading' || node.tagName.toLowerCase() === 'x-uib-tab-heading' || node.tagName.toLowerCase() === 'uib:tab-heading');
	  }
	});

	angular.module('ui.bootstrap.timepicker', []).constant('uibTimepickerConfig', {
	  hourStep: 1,
	  minuteStep: 1,
	  secondStep: 1,
	  showMeridian: true,
	  showSeconds: false,
	  meridians: null,
	  readonlyInput: false,
	  mousewheel: true,
	  arrowkeys: true,
	  showSpinners: true,
	  templateUrl: 'uib/template/timepicker/timepicker.html'
	}).controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function ($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
	  var hoursModelCtrl, minutesModelCtrl, secondsModelCtrl;
	  var selected = new Date(),
	      watchers = [],
	      ngModelCtrl = { $setViewValue: angular.noop },
	      // nullModelCtrl
	  meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,
	      padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;

	  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
	  $element.removeAttr('tabindex');

	  this.init = function (ngModelCtrl_, inputs) {
	    ngModelCtrl = ngModelCtrl_;
	    ngModelCtrl.$render = this.render;

	    ngModelCtrl.$formatters.unshift(function (modelValue) {
	      return modelValue ? new Date(modelValue) : null;
	    });

	    var hoursInputEl = inputs.eq(0),
	        minutesInputEl = inputs.eq(1),
	        secondsInputEl = inputs.eq(2);

	    hoursModelCtrl = hoursInputEl.controller('ngModel');
	    minutesModelCtrl = minutesInputEl.controller('ngModel');
	    secondsModelCtrl = secondsInputEl.controller('ngModel');

	    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;

	    if (mousewheel) {
	      this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
	    }

	    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
	    if (arrowkeys) {
	      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
	    }

	    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
	    this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
	  };

	  var hourStep = timepickerConfig.hourStep;
	  if ($attrs.hourStep) {
	    watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function (value) {
	      hourStep = +value;
	    }));
	  }

	  var minuteStep = timepickerConfig.minuteStep;
	  if ($attrs.minuteStep) {
	    watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function (value) {
	      minuteStep = +value;
	    }));
	  }

	  var min;
	  watchers.push($scope.$parent.$watch($parse($attrs.min), function (value) {
	    var dt = new Date(value);
	    min = isNaN(dt) ? undefined : dt;
	  }));

	  var max;
	  watchers.push($scope.$parent.$watch($parse($attrs.max), function (value) {
	    var dt = new Date(value);
	    max = isNaN(dt) ? undefined : dt;
	  }));

	  var disabled = false;
	  if ($attrs.ngDisabled) {
	    watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function (value) {
	      disabled = value;
	    }));
	  }

	  $scope.noIncrementHours = function () {
	    var incrementedSelected = addMinutes(selected, hourStep * 60);
	    return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
	  };

	  $scope.noDecrementHours = function () {
	    var decrementedSelected = addMinutes(selected, -hourStep * 60);
	    return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
	  };

	  $scope.noIncrementMinutes = function () {
	    var incrementedSelected = addMinutes(selected, minuteStep);
	    return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
	  };

	  $scope.noDecrementMinutes = function () {
	    var decrementedSelected = addMinutes(selected, -minuteStep);
	    return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
	  };

	  $scope.noIncrementSeconds = function () {
	    var incrementedSelected = addSeconds(selected, secondStep);
	    return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
	  };

	  $scope.noDecrementSeconds = function () {
	    var decrementedSelected = addSeconds(selected, -secondStep);
	    return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
	  };

	  $scope.noToggleMeridian = function () {
	    if (selected.getHours() < 12) {
	      return disabled || addMinutes(selected, 12 * 60) > max;
	    }

	    return disabled || addMinutes(selected, -12 * 60) < min;
	  };

	  var secondStep = timepickerConfig.secondStep;
	  if ($attrs.secondStep) {
	    watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function (value) {
	      secondStep = +value;
	    }));
	  }

	  $scope.showSeconds = timepickerConfig.showSeconds;
	  if ($attrs.showSeconds) {
	    watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function (value) {
	      $scope.showSeconds = !!value;
	    }));
	  }

	  // 12H / 24H mode
	  $scope.showMeridian = timepickerConfig.showMeridian;
	  if ($attrs.showMeridian) {
	    watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function (value) {
	      $scope.showMeridian = !!value;

	      if (ngModelCtrl.$error.time) {
	        // Evaluate from template
	        var hours = getHoursFromTemplate(),
	            minutes = getMinutesFromTemplate();
	        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
	          selected.setHours(hours);
	          refresh();
	        }
	      } else {
	        updateTemplate();
	      }
	    }));
	  }

	  // Get $scope.hours in 24H mode if valid
	  function getHoursFromTemplate() {
	    var hours = +$scope.hours;
	    var valid = $scope.showMeridian ? hours > 0 && hours < 13 : hours >= 0 && hours < 24;
	    if (!valid || $scope.hours === '') {
	      return undefined;
	    }

	    if ($scope.showMeridian) {
	      if (hours === 12) {
	        hours = 0;
	      }
	      if ($scope.meridian === meridians[1]) {
	        hours = hours + 12;
	      }
	    }
	    return hours;
	  }

	  function getMinutesFromTemplate() {
	    var minutes = +$scope.minutes;
	    var valid = minutes >= 0 && minutes < 60;
	    if (!valid || $scope.minutes === '') {
	      return undefined;
	    }
	    return minutes;
	  }

	  function getSecondsFromTemplate() {
	    var seconds = +$scope.seconds;
	    return seconds >= 0 && seconds < 60 ? seconds : undefined;
	  }

	  function pad(value, noPad) {
	    if (value === null) {
	      return '';
	    }

	    return angular.isDefined(value) && value.toString().length < 2 && !noPad ? '0' + value : value.toString();
	  }

	  // Respond on mousewheel spin
	  this.setupMousewheelEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
	    var isScrollingUp = function isScrollingUp(e) {
	      if (e.originalEvent) {
	        e = e.originalEvent;
	      }
	      //pick correct delta variable depending on event
	      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
	      return e.detail || delta > 0;
	    };

	    hoursInputEl.on('mousewheel wheel', function (e) {
	      if (!disabled) {
	        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
	      }
	      e.preventDefault();
	    });

	    minutesInputEl.on('mousewheel wheel', function (e) {
	      if (!disabled) {
	        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
	      }
	      e.preventDefault();
	    });

	    secondsInputEl.on('mousewheel wheel', function (e) {
	      if (!disabled) {
	        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
	      }
	      e.preventDefault();
	    });
	  };

	  // Respond on up/down arrowkeys
	  this.setupArrowkeyEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
	    hoursInputEl.on('keydown', function (e) {
	      if (!disabled) {
	        if (e.which === 38) {
	          // up
	          e.preventDefault();
	          $scope.incrementHours();
	          $scope.$apply();
	        } else if (e.which === 40) {
	          // down
	          e.preventDefault();
	          $scope.decrementHours();
	          $scope.$apply();
	        }
	      }
	    });

	    minutesInputEl.on('keydown', function (e) {
	      if (!disabled) {
	        if (e.which === 38) {
	          // up
	          e.preventDefault();
	          $scope.incrementMinutes();
	          $scope.$apply();
	        } else if (e.which === 40) {
	          // down
	          e.preventDefault();
	          $scope.decrementMinutes();
	          $scope.$apply();
	        }
	      }
	    });

	    secondsInputEl.on('keydown', function (e) {
	      if (!disabled) {
	        if (e.which === 38) {
	          // up
	          e.preventDefault();
	          $scope.incrementSeconds();
	          $scope.$apply();
	        } else if (e.which === 40) {
	          // down
	          e.preventDefault();
	          $scope.decrementSeconds();
	          $scope.$apply();
	        }
	      }
	    });
	  };

	  this.setupInputEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
	    if ($scope.readonlyInput) {
	      $scope.updateHours = angular.noop;
	      $scope.updateMinutes = angular.noop;
	      $scope.updateSeconds = angular.noop;
	      return;
	    }

	    var invalidate = function invalidate(invalidHours, invalidMinutes, invalidSeconds) {
	      ngModelCtrl.$setViewValue(null);
	      ngModelCtrl.$setValidity('time', false);
	      if (angular.isDefined(invalidHours)) {
	        $scope.invalidHours = invalidHours;
	        if (hoursModelCtrl) {
	          hoursModelCtrl.$setValidity('hours', false);
	        }
	      }

	      if (angular.isDefined(invalidMinutes)) {
	        $scope.invalidMinutes = invalidMinutes;
	        if (minutesModelCtrl) {
	          minutesModelCtrl.$setValidity('minutes', false);
	        }
	      }

	      if (angular.isDefined(invalidSeconds)) {
	        $scope.invalidSeconds = invalidSeconds;
	        if (secondsModelCtrl) {
	          secondsModelCtrl.$setValidity('seconds', false);
	        }
	      }
	    };

	    $scope.updateHours = function () {
	      var hours = getHoursFromTemplate(),
	          minutes = getMinutesFromTemplate();

	      ngModelCtrl.$setDirty();

	      if (angular.isDefined(hours) && angular.isDefined(minutes)) {
	        selected.setHours(hours);
	        selected.setMinutes(minutes);
	        if (selected < min || selected > max) {
	          invalidate(true);
	        } else {
	          refresh('h');
	        }
	      } else {
	        invalidate(true);
	      }
	    };

	    hoursInputEl.on('blur', function (e) {
	      ngModelCtrl.$setTouched();
	      if (modelIsEmpty()) {
	        makeValid();
	      } else if ($scope.hours === null || $scope.hours === '') {
	        invalidate(true);
	      } else if (!$scope.invalidHours && $scope.hours < 10) {
	        $scope.$apply(function () {
	          $scope.hours = pad($scope.hours, !padHours);
	        });
	      }
	    });

	    $scope.updateMinutes = function () {
	      var minutes = getMinutesFromTemplate(),
	          hours = getHoursFromTemplate();

	      ngModelCtrl.$setDirty();

	      if (angular.isDefined(minutes) && angular.isDefined(hours)) {
	        selected.setHours(hours);
	        selected.setMinutes(minutes);
	        if (selected < min || selected > max) {
	          invalidate(undefined, true);
	        } else {
	          refresh('m');
	        }
	      } else {
	        invalidate(undefined, true);
	      }
	    };

	    minutesInputEl.on('blur', function (e) {
	      ngModelCtrl.$setTouched();
	      if (modelIsEmpty()) {
	        makeValid();
	      } else if ($scope.minutes === null) {
	        invalidate(undefined, true);
	      } else if (!$scope.invalidMinutes && $scope.minutes < 10) {
	        $scope.$apply(function () {
	          $scope.minutes = pad($scope.minutes);
	        });
	      }
	    });

	    $scope.updateSeconds = function () {
	      var seconds = getSecondsFromTemplate();

	      ngModelCtrl.$setDirty();

	      if (angular.isDefined(seconds)) {
	        selected.setSeconds(seconds);
	        refresh('s');
	      } else {
	        invalidate(undefined, undefined, true);
	      }
	    };

	    secondsInputEl.on('blur', function (e) {
	      if (modelIsEmpty()) {
	        makeValid();
	      } else if (!$scope.invalidSeconds && $scope.seconds < 10) {
	        $scope.$apply(function () {
	          $scope.seconds = pad($scope.seconds);
	        });
	      }
	    });
	  };

	  this.render = function () {
	    var date = ngModelCtrl.$viewValue;

	    if (isNaN(date)) {
	      ngModelCtrl.$setValidity('time', false);
	      $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
	    } else {
	      if (date) {
	        selected = date;
	      }

	      if (selected < min || selected > max) {
	        ngModelCtrl.$setValidity('time', false);
	        $scope.invalidHours = true;
	        $scope.invalidMinutes = true;
	      } else {
	        makeValid();
	      }
	      updateTemplate();
	    }
	  };

	  // Call internally when we know that model is valid.
	  function refresh(keyboardChange) {
	    makeValid();
	    ngModelCtrl.$setViewValue(new Date(selected));
	    updateTemplate(keyboardChange);
	  }

	  function makeValid() {
	    if (hoursModelCtrl) {
	      hoursModelCtrl.$setValidity('hours', true);
	    }

	    if (minutesModelCtrl) {
	      minutesModelCtrl.$setValidity('minutes', true);
	    }

	    if (secondsModelCtrl) {
	      secondsModelCtrl.$setValidity('seconds', true);
	    }

	    ngModelCtrl.$setValidity('time', true);
	    $scope.invalidHours = false;
	    $scope.invalidMinutes = false;
	    $scope.invalidSeconds = false;
	  }

	  function updateTemplate(keyboardChange) {
	    if (!ngModelCtrl.$modelValue) {
	      $scope.hours = null;
	      $scope.minutes = null;
	      $scope.seconds = null;
	      $scope.meridian = meridians[0];
	    } else {
	      var hours = selected.getHours(),
	          minutes = selected.getMinutes(),
	          seconds = selected.getSeconds();

	      if ($scope.showMeridian) {
	        hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system
	      }

	      $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);
	      if (keyboardChange !== 'm') {
	        $scope.minutes = pad(minutes);
	      }
	      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];

	      if (keyboardChange !== 's') {
	        $scope.seconds = pad(seconds);
	      }
	      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
	    }
	  }

	  function addSecondsToSelected(seconds) {
	    selected = addSeconds(selected, seconds);
	    refresh();
	  }

	  function addMinutes(selected, minutes) {
	    return addSeconds(selected, minutes * 60);
	  }

	  function addSeconds(date, seconds) {
	    var dt = new Date(date.getTime() + seconds * 1000);
	    var newDate = new Date(date);
	    newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
	    return newDate;
	  }

	  function modelIsEmpty() {
	    return ($scope.hours === null || $scope.hours === '') && ($scope.minutes === null || $scope.minutes === '') && (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));
	  }

	  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ? $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;

	  $scope.incrementHours = function () {
	    if (!$scope.noIncrementHours()) {
	      addSecondsToSelected(hourStep * 60 * 60);
	    }
	  };

	  $scope.decrementHours = function () {
	    if (!$scope.noDecrementHours()) {
	      addSecondsToSelected(-hourStep * 60 * 60);
	    }
	  };

	  $scope.incrementMinutes = function () {
	    if (!$scope.noIncrementMinutes()) {
	      addSecondsToSelected(minuteStep * 60);
	    }
	  };

	  $scope.decrementMinutes = function () {
	    if (!$scope.noDecrementMinutes()) {
	      addSecondsToSelected(-minuteStep * 60);
	    }
	  };

	  $scope.incrementSeconds = function () {
	    if (!$scope.noIncrementSeconds()) {
	      addSecondsToSelected(secondStep);
	    }
	  };

	  $scope.decrementSeconds = function () {
	    if (!$scope.noDecrementSeconds()) {
	      addSecondsToSelected(-secondStep);
	    }
	  };

	  $scope.toggleMeridian = function () {
	    var minutes = getMinutesFromTemplate(),
	        hours = getHoursFromTemplate();

	    if (!$scope.noToggleMeridian()) {
	      if (angular.isDefined(minutes) && angular.isDefined(hours)) {
	        addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
	      } else {
	        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
	      }
	    }
	  };

	  $scope.blur = function () {
	    ngModelCtrl.$setTouched();
	  };

	  $scope.$on('$destroy', function () {
	    while (watchers.length) {
	      watchers.shift()();
	    }
	  });
	}]).directive('uibTimepicker', ['uibTimepickerConfig', function (uibTimepickerConfig) {
	  return {
	    require: ['uibTimepicker', '?^ngModel'],
	    restrict: 'A',
	    controller: 'UibTimepickerController',
	    controllerAs: 'timepicker',
	    scope: {},
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.templateUrl || uibTimepickerConfig.templateUrl;
	    },
	    link: function link(scope, element, attrs, ctrls) {
	      var timepickerCtrl = ctrls[0],
	          ngModelCtrl = ctrls[1];

	      if (ngModelCtrl) {
	        timepickerCtrl.init(ngModelCtrl, element.find('input'));
	      }
	    }
	  };
	}]);

	angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])

	/**
	 * A helper service that can parse typeahead's syntax (string provided by users)
	 * Extracted to a separate service for ease of unit testing
	 */
	.factory('uibTypeaheadParser', ['$parse', function ($parse) {
	  //                      000001111111100000000000002222222200000000000000003333333333333330000000000044444444000
	  var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
	  return {
	    parse: function parse(input) {
	      var match = input.match(TYPEAHEAD_REGEXP);
	      if (!match) {
	        throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' + ' but got "' + input + '".');
	      }

	      return {
	        itemName: match[3],
	        source: $parse(match[4]),
	        viewMapper: $parse(match[2] || match[1]),
	        modelMapper: $parse(match[1])
	      };
	    }
	  };
	}]).controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser', function (originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
	  var HOT_KEYS = [9, 13, 27, 38, 40];
	  var eventDebounceTime = 200;
	  var modelCtrl, ngModelOptions;
	  //SUPPORTED ATTRIBUTES (OPTIONS)

	  //minimal no of characters that needs to be entered before typeahead kicks-in
	  var minLength = originalScope.$eval(attrs.typeaheadMinLength);
	  if (!minLength && minLength !== 0) {
	    minLength = 1;
	  }

	  originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {
	    minLength = !newVal && newVal !== 0 ? 1 : newVal;
	  });

	  //minimal wait time after last character typed before typeahead kicks-in
	  var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

	  //should it restrict model values to the ones selected from the popup only?
	  var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
	  originalScope.$watch(attrs.typeaheadEditable, function (newVal) {
	    isEditable = newVal !== false;
	  });

	  //binding to a variable that indicates if matches are being retrieved asynchronously
	  var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

	  //a function to determine if an event should cause selection
	  var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function (scope, vals) {
	    var evt = vals.$event;
	    return evt.which === 13 || evt.which === 9;
	  };

	  //a callback executed when a match is selected
	  var onSelectCallback = $parse(attrs.typeaheadOnSelect);

	  //should it select highlighted popup value when losing focus?
	  var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;

	  //binding to a variable that indicates if there were no results after the query is completed
	  var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;

	  var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

	  var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

	  var appendTo = attrs.typeaheadAppendTo ? originalScope.$eval(attrs.typeaheadAppendTo) : null;

	  var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

	  //If input matches an item of the list exactly, select it automatically
	  var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;

	  //binding to a variable that indicates if dropdown is open
	  var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;

	  var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;

	  //INTERNAL VARIABLES

	  //model setter executed upon match selection
	  var parsedModel = $parse(attrs.ngModel);
	  var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
	  var $setModelValue = function $setModelValue(scope, newValue) {
	    if (angular.isFunction(parsedModel(originalScope)) && ngModelOptions.getOption('getterSetter')) {
	      return invokeModelSetter(scope, { $$$p: newValue });
	    }

	    return parsedModel.assign(scope, newValue);
	  };

	  //expressions used by typeahead
	  var parserResult = typeaheadParser.parse(attrs.uibTypeahead);

	  var hasFocus;

	  //Used to avoid bug in iOS webview where iOS keyboard does not fire
	  //mousedown & mouseup events
	  //Issue #3699
	  var selected;

	  //create a child scope for the typeahead directive so we are not polluting original scope
	  //with typeahead-specific data (matches, query etc.)
	  var scope = originalScope.$new();
	  var offDestroy = originalScope.$on('$destroy', function () {
	    scope.$destroy();
	  });
	  scope.$on('$destroy', offDestroy);

	  // WAI-ARIA
	  var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
	  element.attr({
	    'aria-autocomplete': 'list',
	    'aria-expanded': false,
	    'aria-owns': popupId
	  });

	  var inputsContainer, hintInputElem;
	  //add read-only input to show hint
	  if (showHint) {
	    inputsContainer = angular.element('<div></div>');
	    inputsContainer.css('position', 'relative');
	    element.after(inputsContainer);
	    hintInputElem = element.clone();
	    hintInputElem.attr('placeholder', '');
	    hintInputElem.attr('tabindex', '-1');
	    hintInputElem.val('');
	    hintInputElem.css({
	      'position': 'absolute',
	      'top': '0px',
	      'left': '0px',
	      'border-color': 'transparent',
	      'box-shadow': 'none',
	      'opacity': 1,
	      'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
	      'color': '#999'
	    });
	    element.css({
	      'position': 'relative',
	      'vertical-align': 'top',
	      'background-color': 'transparent'
	    });

	    if (hintInputElem.attr('id')) {
	      hintInputElem.removeAttr('id'); // remove duplicate id if present.
	    }
	    inputsContainer.append(hintInputElem);
	    hintInputElem.after(element);
	  }

	  //pop-up element used to display matches
	  var popUpEl = angular.element('<div uib-typeahead-popup></div>');
	  popUpEl.attr({
	    id: popupId,
	    matches: 'matches',
	    active: 'activeIdx',
	    select: 'select(activeIdx, evt)',
	    'move-in-progress': 'moveInProgress',
	    query: 'query',
	    position: 'position',
	    'assign-is-open': 'assignIsOpen(isOpen)',
	    debounce: 'debounceUpdate'
	  });
	  //custom item template
	  if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
	    popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
	  }

	  if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
	    popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
	  }

	  var resetHint = function resetHint() {
	    if (showHint) {
	      hintInputElem.val('');
	    }
	  };

	  var resetMatches = function resetMatches() {
	    scope.matches = [];
	    scope.activeIdx = -1;
	    element.attr('aria-expanded', false);
	    resetHint();
	  };

	  var getMatchId = function getMatchId(index) {
	    return popupId + '-option-' + index;
	  };

	  // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
	  // This attribute is added or removed automatically when the `activeIdx` changes.
	  scope.$watch('activeIdx', function (index) {
	    if (index < 0) {
	      element.removeAttr('aria-activedescendant');
	    } else {
	      element.attr('aria-activedescendant', getMatchId(index));
	    }
	  });

	  var inputIsExactMatch = function inputIsExactMatch(inputValue, index) {
	    if (scope.matches.length > index && inputValue) {
	      return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
	    }

	    return false;
	  };

	  var getMatchesAsync = function getMatchesAsync(inputValue, evt) {
	    var locals = { $viewValue: inputValue };
	    isLoadingSetter(originalScope, true);
	    isNoResultsSetter(originalScope, false);
	    $q.when(parserResult.source(originalScope, locals)).then(function (matches) {
	      //it might happen that several async queries were in progress if a user were typing fast
	      //but we are interested only in responses that correspond to the current view value
	      var onCurrentRequest = inputValue === modelCtrl.$viewValue;
	      if (onCurrentRequest && hasFocus) {
	        if (matches && matches.length > 0) {
	          scope.activeIdx = focusFirst ? 0 : -1;
	          isNoResultsSetter(originalScope, false);
	          scope.matches.length = 0;

	          //transform labels
	          for (var i = 0; i < matches.length; i++) {
	            locals[parserResult.itemName] = matches[i];
	            scope.matches.push({
	              id: getMatchId(i),
	              label: parserResult.viewMapper(scope, locals),
	              model: matches[i]
	            });
	          }

	          scope.query = inputValue;
	          //position pop-up with matches - we need to re-calculate its position each time we are opening a window
	          //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
	          //due to other elements being rendered
	          recalculatePosition();

	          element.attr('aria-expanded', true);

	          //Select the single remaining option if user input matches
	          if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
	            if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
	              $$debounce(function () {
	                scope.select(0, evt);
	              }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
	            } else {
	              scope.select(0, evt);
	            }
	          }

	          if (showHint) {
	            var firstLabel = scope.matches[0].label;
	            if (angular.isString(inputValue) && inputValue.length > 0 && firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
	              hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
	            } else {
	              hintInputElem.val('');
	            }
	          }
	        } else {
	          resetMatches();
	          isNoResultsSetter(originalScope, true);
	        }
	      }
	      if (onCurrentRequest) {
	        isLoadingSetter(originalScope, false);
	      }
	    }, function () {
	      resetMatches();
	      isLoadingSetter(originalScope, false);
	      isNoResultsSetter(originalScope, true);
	    });
	  };

	  // bind events only if appendToBody params exist - performance feature
	  if (appendToBody) {
	    angular.element($window).on('resize', fireRecalculating);
	    $document.find('body').on('scroll', fireRecalculating);
	  }

	  // Declare the debounced function outside recalculating for
	  // proper debouncing
	  var debouncedRecalculate = $$debounce(function () {
	    // if popup is visible
	    if (scope.matches.length) {
	      recalculatePosition();
	    }

	    scope.moveInProgress = false;
	  }, eventDebounceTime);

	  // Default progress type
	  scope.moveInProgress = false;

	  function fireRecalculating() {
	    if (!scope.moveInProgress) {
	      scope.moveInProgress = true;
	      scope.$digest();
	    }

	    debouncedRecalculate();
	  }

	  // recalculate actual position and set new values to scope
	  // after digest loop is popup in right position
	  function recalculatePosition() {
	    scope.position = appendToBody ? $position.offset(element) : $position.position(element);
	    scope.position.top += element.prop('offsetHeight');
	  }

	  //we need to propagate user's query so we can higlight matches
	  scope.query = undefined;

	  //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
	  var timeoutPromise;

	  var scheduleSearchWithTimeout = function scheduleSearchWithTimeout(inputValue) {
	    timeoutPromise = $timeout(function () {
	      getMatchesAsync(inputValue);
	    }, waitTime);
	  };

	  var cancelPreviousTimeout = function cancelPreviousTimeout() {
	    if (timeoutPromise) {
	      $timeout.cancel(timeoutPromise);
	    }
	  };

	  resetMatches();

	  scope.assignIsOpen = function (isOpen) {
	    isOpenSetter(originalScope, isOpen);
	  };

	  scope.select = function (activeIdx, evt) {
	    //called from within the $digest() cycle
	    var locals = {};
	    var model, item;

	    selected = true;
	    locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
	    model = parserResult.modelMapper(originalScope, locals);
	    $setModelValue(originalScope, model);
	    modelCtrl.$setValidity('editable', true);
	    modelCtrl.$setValidity('parse', true);

	    onSelectCallback(originalScope, {
	      $item: item,
	      $model: model,
	      $label: parserResult.viewMapper(originalScope, locals),
	      $event: evt
	    });

	    resetMatches();

	    //return focus to the input element if a match was selected via a mouse click event
	    // use timeout to avoid $rootScope:inprog error
	    if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
	      $timeout(function () {
	        element[0].focus();
	      }, 0, false);
	    }
	  };

	  //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
	  element.on('keydown', function (evt) {
	    //typeahead is open and an "interesting" key was pressed
	    if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
	      return;
	    }

	    var shouldSelect = isSelectEvent(originalScope, { $event: evt });

	    /**
	     * if there's nothing selected (i.e. focusFirst) and enter or tab is hit
	     * or
	     * shift + tab is pressed to bring focus to the previous element
	     * then clear the results
	     */
	    if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {
	      resetMatches();
	      scope.$digest();
	      return;
	    }

	    evt.preventDefault();
	    var target;
	    switch (evt.which) {
	      case 27:
	        // escape
	        evt.stopPropagation();

	        resetMatches();
	        originalScope.$digest();
	        break;
	      case 38:
	        // up arrow
	        scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
	        scope.$digest();
	        target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
	        target.parentNode.scrollTop = target.offsetTop;
	        break;
	      case 40:
	        // down arrow
	        scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
	        scope.$digest();
	        target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
	        target.parentNode.scrollTop = target.offsetTop;
	        break;
	      default:
	        if (shouldSelect) {
	          scope.$apply(function () {
	            if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
	              $$debounce(function () {
	                scope.select(scope.activeIdx, evt);
	              }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
	            } else {
	              scope.select(scope.activeIdx, evt);
	            }
	          });
	        }
	    }
	  });

	  element.on('focus', function (evt) {
	    hasFocus = true;
	    if (minLength === 0 && !modelCtrl.$viewValue) {
	      $timeout(function () {
	        getMatchesAsync(modelCtrl.$viewValue, evt);
	      }, 0);
	    }
	  });

	  element.on('blur', function (evt) {
	    if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
	      selected = true;
	      scope.$apply(function () {
	        if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
	          $$debounce(function () {
	            scope.select(scope.activeIdx, evt);
	          }, scope.debounceUpdate.blur);
	        } else {
	          scope.select(scope.activeIdx, evt);
	        }
	      });
	    }
	    if (!isEditable && modelCtrl.$error.editable) {
	      modelCtrl.$setViewValue();
	      scope.$apply(function () {
	        // Reset validity as we are clearing
	        modelCtrl.$setValidity('editable', true);
	        modelCtrl.$setValidity('parse', true);
	      });
	      element.val('');
	    }
	    hasFocus = false;
	    selected = false;
	  });

	  // Keep reference to click handler to unbind it.
	  var dismissClickHandler = function dismissClickHandler(evt) {
	    // Issue #3973
	    // Firefox treats right click as a click on document
	    if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
	      resetMatches();
	      if (!$rootScope.$$phase) {
	        originalScope.$digest();
	      }
	    }
	  };

	  $document.on('click', dismissClickHandler);

	  originalScope.$on('$destroy', function () {
	    $document.off('click', dismissClickHandler);
	    if (appendToBody || appendTo) {
	      $popup.remove();
	    }

	    if (appendToBody) {
	      angular.element($window).off('resize', fireRecalculating);
	      $document.find('body').off('scroll', fireRecalculating);
	    }
	    // Prevent jQuery cache memory leak
	    popUpEl.remove();

	    if (showHint) {
	      inputsContainer.remove();
	    }
	  });

	  var $popup = $compile(popUpEl)(scope);

	  if (appendToBody) {
	    $document.find('body').append($popup);
	  } else if (appendTo) {
	    angular.element(appendTo).eq(0).append($popup);
	  } else {
	    element.after($popup);
	  }

	  this.init = function (_modelCtrl) {
	    modelCtrl = _modelCtrl;
	    ngModelOptions = extractOptions(modelCtrl);

	    scope.debounceUpdate = $parse(ngModelOptions.getOption('debounce'))(originalScope);

	    //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
	    //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
	    modelCtrl.$parsers.unshift(function (inputValue) {
	      hasFocus = true;

	      if (minLength === 0 || inputValue && inputValue.length >= minLength) {
	        if (waitTime > 0) {
	          cancelPreviousTimeout();
	          scheduleSearchWithTimeout(inputValue);
	        } else {
	          getMatchesAsync(inputValue);
	        }
	      } else {
	        isLoadingSetter(originalScope, false);
	        cancelPreviousTimeout();
	        resetMatches();
	      }

	      if (isEditable) {
	        return inputValue;
	      }

	      if (!inputValue) {
	        // Reset in case user had typed something previously.
	        modelCtrl.$setValidity('editable', true);
	        return null;
	      }

	      modelCtrl.$setValidity('editable', false);
	      return undefined;
	    });

	    modelCtrl.$formatters.push(function (modelValue) {
	      var candidateViewValue, emptyViewValue;
	      var locals = {};

	      // The validity may be set to false via $parsers (see above) if
	      // the model is restricted to selected values. If the model
	      // is set manually it is considered to be valid.
	      if (!isEditable) {
	        modelCtrl.$setValidity('editable', true);
	      }

	      if (inputFormatter) {
	        locals.$model = modelValue;
	        return inputFormatter(originalScope, locals);
	      }

	      //it might happen that we don't have enough info to properly render input value
	      //we need to check for this situation and simply return model value if we can't apply custom formatting
	      locals[parserResult.itemName] = modelValue;
	      candidateViewValue = parserResult.viewMapper(originalScope, locals);
	      locals[parserResult.itemName] = undefined;
	      emptyViewValue = parserResult.viewMapper(originalScope, locals);

	      return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
	    });
	  };

	  function extractOptions(ngModelCtrl) {
	    var ngModelOptions;

	    if (angular.version.minor < 6) {
	      // in angular < 1.6 $options could be missing
	      // guarantee a value
	      ngModelOptions = ngModelCtrl.$options || {};

	      // mimic 1.6+ api
	      ngModelOptions.getOption = function (key) {
	        return ngModelOptions[key];
	      };
	    } else {
	      // in angular >=1.6 $options is always present
	      ngModelOptions = ngModelCtrl.$options;
	    }

	    return ngModelOptions;
	  }
	}]).directive('uibTypeahead', function () {
	  return {
	    controller: 'UibTypeaheadController',
	    require: ['ngModel', 'uibTypeahead'],
	    link: function link(originalScope, element, attrs, ctrls) {
	      ctrls[1].init(ctrls[0]);
	    }
	  };
	}).directive('uibTypeaheadPopup', ['$$debounce', function ($$debounce) {
	  return {
	    scope: {
	      matches: '=',
	      query: '=',
	      active: '=',
	      position: '&',
	      moveInProgress: '=',
	      select: '&',
	      assignIsOpen: '&',
	      debounce: '&'
	    },
	    replace: true,
	    templateUrl: function templateUrl(element, attrs) {
	      return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
	    },
	    link: function link(scope, element, attrs) {
	      scope.templateUrl = attrs.templateUrl;

	      scope.isOpen = function () {
	        var isDropdownOpen = scope.matches.length > 0;
	        scope.assignIsOpen({ isOpen: isDropdownOpen });
	        return isDropdownOpen;
	      };

	      scope.isActive = function (matchIdx) {
	        return scope.active === matchIdx;
	      };

	      scope.selectActive = function (matchIdx) {
	        scope.active = matchIdx;
	      };

	      scope.selectMatch = function (activeIdx, evt) {
	        var debounce = scope.debounce();
	        if (angular.isNumber(debounce) || angular.isObject(debounce)) {
	          $$debounce(function () {
	            scope.select({ activeIdx: activeIdx, evt: evt });
	          }, angular.isNumber(debounce) ? debounce : debounce['default']);
	        } else {
	          scope.select({ activeIdx: activeIdx, evt: evt });
	        }
	      };
	    }
	  };
	}]).directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function ($templateRequest, $compile, $parse) {
	  return {
	    scope: {
	      index: '=',
	      match: '=',
	      query: '='
	    },
	    link: function link(scope, element, attrs) {
	      var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
	      $templateRequest(tplUrl).then(function (tplContent) {
	        var tplEl = angular.element(tplContent.trim());
	        element.replaceWith(tplEl);
	        $compile(tplEl)(scope);
	      });
	    }
	  };
	}]).filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function ($sce, $injector, $log) {
	  var isSanitizePresent;
	  isSanitizePresent = $injector.has('$sanitize');

	  function escapeRegexp(queryToEscape) {
	    // Regex: capture the whole query string and replace it with the string that will be used to match
	    // the results, for example if the capture is "a" the result will be \a
	    return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
	  }

	  function containsHtml(matchItem) {
	    return (/<.*>/g.test(matchItem)
	    );
	  }

	  return function (matchItem, query) {
	    if (!isSanitizePresent && containsHtml(matchItem)) {
	      $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
	    }
	    matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
	    if (!isSanitizePresent) {
	      matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
	    }
	    return matchItem;
	  };
	}]);

	angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/accordion/accordion-group.html", "<div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" + "  <h4 class=\"panel-title\">\n" + "    <a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\" ng-disabled=\"isDisabled\" uib-tabindex-toggle><span uib-accordion-header ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" + "  </h4>\n" + "</div>\n" + "<div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" + "  <div class=\"panel-body\" ng-transclude></div>\n" + "</div>\n" + "");
	}]);

	angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/accordion/accordion.html", "<div role=\"tablist\" class=\"panel-group\" ng-transclude></div>");
	}]);

	angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/alert/alert.html", "<button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" + "  <span aria-hidden=\"true\">&times;</span>\n" + "  <span class=\"sr-only\">Close</span>\n" + "</button>\n" + "<div ng-transclude></div>\n" + "");
	}]);

	angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/carousel/carousel.html", "<div class=\"carousel-inner\" ng-transclude></div>\n" + "<a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-class=\"{ disabled: isPrevDisabled() }\" ng-show=\"slides.length > 1\">\n" + "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" + "  <span class=\"sr-only\">previous</span>\n" + "</a>\n" + "<a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-class=\"{ disabled: isNextDisabled() }\" ng-show=\"slides.length > 1\">\n" + "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" + "  <span class=\"sr-only\">next</span>\n" + "</a>\n" + "<ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" + "  <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" + "    <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" + "  </li>\n" + "</ol>\n" + "");
	}]);

	angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/carousel/slide.html", "<div class=\"text-center\" ng-transclude></div>\n" + "");
	}]);

	angular.module("uib/template/datepicker/datepicker.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/datepicker/datepicker.html", "<div ng-switch=\"datepickerMode\">\n" + "  <div uib-daypicker ng-switch-when=\"day\" tabindex=\"0\" class=\"uib-daypicker\"></div>\n" + "  <div uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\" class=\"uib-monthpicker\"></div>\n" + "  <div uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\" class=\"uib-yearpicker\"></div>\n" + "</div>\n" + "");
	}]);

	angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/datepicker/day.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" + "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></button></th>\n" + "    </tr>\n" + "    <tr>\n" + "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" + "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" + "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" + "      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" + "        id=\"{{::dt.uid}}\"\n" + "        ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" class=\"btn btn-default btn-sm\"\n" + "          uib-is-class=\"\n" + "            'btn-info' for selectedDt,\n" + "            'active' for activeDt\n" + "            on dt\"\n" + "          ng-click=\"select(dt.date)\"\n" + "          ng-disabled=\"::dt.disabled\"\n" + "          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
	}]);

	angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/datepicker/month.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" + "      <th colspan=\"{{::yearHeaderColspan}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></i></button></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" + "      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" + "        id=\"{{::dt.uid}}\"\n" + "        ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" class=\"btn btn-default\"\n" + "          uib-is-class=\"\n" + "            'btn-info' for selectedDt,\n" + "            'active' for activeDt\n" + "            on dt\"\n" + "          ng-click=\"select(dt.date)\"\n" + "          ng-disabled=\"::dt.disabled\"\n" + "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
	}]);

	angular.module("uib/template/datepicker/popup.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/datepicker/popup.html", "<div>\n" + "  <ul class=\"uib-datepicker-popup dropdown-menu uib-position-measure\" dropdown-nested ng-if=\"isOpen\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" + "    <li ng-transclude></li>\n" + "    <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\n" + "      <span class=\"btn-group pull-left\">\n" + "        <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today', $event)\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" + "        <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null, $event)\">{{ getText('clear') }}</button>\n" + "      </span>\n" + "      <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close($event)\">{{ getText('close') }}</button>\n" + "    </li>\n" + "  </ul>\n" + "</div>\n" + "");
	}]);

	angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/datepicker/year.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" + "      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></button></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" + "      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" + "        id=\"{{::dt.uid}}\"\n" + "        ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" class=\"btn btn-default\"\n" + "          uib-is-class=\"\n" + "            'btn-info' for selectedDt,\n" + "            'active' for activeDt\n" + "            on dt\"\n" + "          ng-click=\"select(dt.date)\"\n" + "          ng-disabled=\"::dt.disabled\"\n" + "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
	}]);

	angular.module("uib/template/datepickerPopup/popup.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/datepickerPopup/popup.html", "<ul role=\"presentation\" class=\"uib-datepicker-popup dropdown-menu uib-position-measure\" dropdown-nested ng-if=\"isOpen\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" + "  <li ng-transclude></li>\n" + "  <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\n" + "    <span class=\"btn-group pull-left\">\n" + "      <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today', $event)\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" + "      <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null, $event)\">{{ getText('clear') }}</button>\n" + "    </span>\n" + "    <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close($event)\">{{ getText('close') }}</button>\n" + "  </li>\n" + "</ul>\n" + "");
	}]);

	angular.module("uib/template/modal/backdrop.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/modal/backdrop.html", "<div class=\"modal-backdrop\"\n" + "     uib-modal-animation-class=\"fade\"\n" + "     modal-in-class=\"in\"\n" + "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" + "></div>\n" + "");
	}]);

	angular.module("uib/template/modal/window.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/modal/window.html", "<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" + "");
	}]);

	angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/pager/pager.html", "<li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" + "<li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" + "");
	}]);

	angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/pagination/pagination.html", "<li role=\"menuitem\" ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('first')}}</a></li>\n" + "<li role=\"menuitem\" ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" + "<li role=\"menuitem\" ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\" ng-disabled=\"ngDisabled&&!page.active\" uib-tabindex-toggle>{{page.text}}</a></li>\n" + "<li role=\"menuitem\" ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" + "<li role=\"menuitem\" ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('last')}}</a></li>\n" + "");
	}]);

	angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/tooltip/tooltip-html-popup.html", "<div class=\"tooltip-arrow\"></div>\n" + "<div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" + "");
	}]);

	angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/tooltip/tooltip-popup.html", "<div class=\"tooltip-arrow\"></div>\n" + "<div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" + "");
	}]);

	angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/tooltip/tooltip-template-popup.html", "<div class=\"tooltip-arrow\"></div>\n" + "<div class=\"tooltip-inner\"\n" + "  uib-tooltip-template-transclude=\"contentExp()\"\n" + "  tooltip-template-transclude-scope=\"originScope()\"></div>\n" + "");
	}]);

	angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/popover/popover-html.html", "<div class=\"arrow\"></div>\n" + "\n" + "<div class=\"popover-inner\">\n" + "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" + "    <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" + "</div>\n" + "");
	}]);

	angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/popover/popover-template.html", "<div class=\"arrow\"></div>\n" + "\n" + "<div class=\"popover-inner\">\n" + "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" + "    <div class=\"popover-content\"\n" + "      uib-tooltip-template-transclude=\"contentExp()\"\n" + "      tooltip-template-transclude-scope=\"originScope()\"></div>\n" + "</div>\n" + "");
	}]);

	angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/popover/popover.html", "<div class=\"arrow\"></div>\n" + "\n" + "<div class=\"popover-inner\">\n" + "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" + "    <div class=\"popover-content\" ng-bind=\"content\"></div>\n" + "</div>\n" + "");
	}]);

	angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/progressbar/bar.html", "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" + "");
	}]);

	angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/progressbar/progress.html", "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
	}]);

	angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/progressbar/progressbar.html", "<div class=\"progress\">\n" + "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" + "</div>\n" + "");
	}]);

	angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/rating/rating.html", "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\" aria-valuetext=\"{{title}}\">\n" + "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" + "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\"></i>\n" + "</span>\n" + "");
	}]);

	angular.module("uib/template/tabs/tab.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/tabs/tab.html", "<li ng-class=\"[{active: active, disabled: disabled}, classes]\" class=\"uib-tab nav-item\">\n" + "  <a href ng-click=\"select($event)\" class=\"nav-link\" uib-tab-heading-transclude>{{heading}}</a>\n" + "</li>\n" + "");
	}]);

	angular.module("uib/template/tabs/tabset.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/tabs/tabset.html", "<div>\n" + "  <ul class=\"nav nav-{{tabset.type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" + "  <div class=\"tab-content\">\n" + "    <div class=\"tab-pane\"\n" + "         ng-repeat=\"tab in tabset.tabs\"\n" + "         ng-class=\"{active: tabset.active === tab.index}\"\n" + "         uib-tab-content-transclude=\"tab\">\n" + "    </div>\n" + "  </div>\n" + "</div>\n" + "");
	}]);

	angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/timepicker/timepicker.html", "<table class=\"uib-timepicker\">\n" + "  <tbody>\n" + "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" + "      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td>&nbsp;</td>\n" + "      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" + "      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td ng-show=\"showMeridian\"></td>\n" + "    </tr>\n" + "    <tr>\n" + "      <td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\">\n" + "        <input type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\n" + "      </td>\n" + "      <td class=\"uib-separator\">:</td>\n" + "      <td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\">\n" + "        <input type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\n" + "      </td>\n" + "      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\n" + "      <td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\">\n" + "        <input type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\n" + "      </td>\n" + "      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" + "    </tr>\n" + "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" + "      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td>&nbsp;</td>\n" + "      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" + "      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td ng-show=\"showMeridian\"></td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
	}]);

	angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/typeahead/typeahead-match.html", "<a href\n" + "   tabindex=\"-1\"\n" + "   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\n" + "   ng-attr-title=\"{{match.label}}\"></a>\n" + "");
	}]);

	angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function ($templateCache) {
	  $templateCache.put("uib/template/typeahead/typeahead-popup.html", "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" + "    <li class=\"uib-typeahead-match\" ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\n" + "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" + "    </li>\n" + "</ul>\n" + "");
	}]);
	angular.module('ui.bootstrap.carousel').run(function () {
	  !angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');angular.$$uibCarouselCss = true;
	});
	angular.module('ui.bootstrap.datepicker').run(function () {
	  !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>');angular.$$uibDatepickerCss = true;
	});
	angular.module('ui.bootstrap.position').run(function () {
	  !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>');angular.$$uibPositionCss = true;
	});
	angular.module('ui.bootstrap.datepickerPopup').run(function () {
	  !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>');angular.$$uibDatepickerpopupCss = true;
	});
	angular.module('ui.bootstrap.tooltip').run(function () {
	  !angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>');angular.$$uibTooltipCss = true;
	});
	angular.module('ui.bootstrap.timepicker').run(function () {
	  !angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>');angular.$$uibTimepickerCss = true;
	});
	angular.module('ui.bootstrap.typeahead').run(function () {
	  !angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>');angular.$$uibTypeaheadCss = true;
	});

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(82);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(90)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(82, function() {
				var newContent = __webpack_require__(82);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(83)();
	// imports


	// module
	exports.push([module.id, "@charset \"UTF-8\";\n/* Include this file in your html if you are using the CSP mode. */\n/* 百度上传 */\n.modular-upload-tab {\n  padding: 0;\n  list-style-type: none;\n  margin: 0;\n  border-bottom: 3px solid #e8e8e8;\n  height: 54px;\n}\n.modular-upload-tab li {\n  padding: 0;\n  list-style-type: none;\n  margin: 0;\n  border-bottom: 3px solid #e8e8e8;\n  height: 54px;\n  line-height: 54px;\n  float: left;\n}\n.modular-upload-tab li a {\n  display: block;\n  text-align: center;\n  font-size: 14px;\n  color: #333;\n  padding: 0 20px;\n}\n.modular-upload-tab li.active {\n  border-bottom: 3px solid #3b9bf5;\n}\n.modular-upload-tab li.active a {\n  color: #3b9bf5;\n}\n#uploader .modular-upload-bottom .btns .webuploader-pick,\n#uploader .modular-upload-bottom .btns .uploadBtn,\n#uploader .modular-upload-bottom .btns .uploadBtn.state-uploading,\n#uploader .modular-upload-bottom .btns .uploadBtn.state-paused {\n  float: none;\n  display: inline-block;\n  padding: 10px 20px;\n}\n#uploader .modular-upload-bottom .btns {\n  text-align: center;\n  padding: 10px 0;\n}\n.modular-upload-list {\n  padding: 10px;\n  background: #f1f1f1;\n  position: relative;\n}\n.modular-upload-list label {\n  vertical-align: top;\n  color: #333;\n  font-size: 12px;\n}\n.modular-upload-list p.img {\n  display: inline-block;\n  width: 62px;\n  height: 46px;\n  border: 2px dotted #bcbcbc;\n  margin-left: 10px;\n  vertical-align: top;\n  box-sizing: border-box;\n  position: relative;\n  background: #dfdfdf;\n}\n#container {\n  color: #838383;\n  font-size: 12px;\n}\n#uploader .queueList {\n  margin: 20px;\n  border: 3px dashed #e6e6e6;\n}\n#uploader .queueList.filled {\n  padding: 17px;\n  margin: 0;\n  border: 3px dashed transparent;\n  min-height: 350px;\n  background: #e4e5e6;\n}\n#uploader .queueList.webuploader-dnd-over {\n  border: 3px dashed #999999;\n}\n#uploader p {\n  margin: 0;\n}\n.element-invisible {\n  position: absolute !important;\n  clip: rect(1px 1px 1px 1px);\n  /* IE6, IE7 */\n  clip: rect(1px, 1px, 1px, 1px);\n}\n#uploader .placeholder {\n  min-height: 350px;\n  padding-top: 178px;\n  text-align: center;\n  background: url(" + __webpack_require__(84) + ") center 93px no-repeat;\n  color: #cccccc;\n  font-size: 18px;\n  position: relative;\n}\n#uploader .placeholder .webuploader-pick {\n  font-size: 18px;\n  background: #00b7ee;\n  border-radius: 3px;\n  line-height: 44px;\n  padding: 0 30px;\n  *width: 120px;\n  color: #fff;\n  display: inline-block;\n  margin: 0 auto 20px auto;\n  cursor: pointer;\n  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);\n}\n#uploader .placeholder .webuploader-pick-hover {\n  background: #00a2d4;\n}\n#uploader .placeholder .flashTip {\n  color: #666666;\n  font-size: 12px;\n  position: absolute;\n  width: 100%;\n  text-align: center;\n  bottom: 20px;\n}\n#uploader .placeholder .flashTip a {\n  color: #0785d1;\n  text-decoration: none;\n}\n#uploader .placeholder .flashTip a:hover {\n  text-decoration: underline;\n}\n#uploader .filelist {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n#uploader .filelist:after {\n  content: '';\n  display: block;\n  width: 0;\n  height: 0;\n  overflow: hidden;\n  clear: both;\n}\n#uploader .filelist li {\n  width: 110px;\n  height: 110px;\n  background: url(" + __webpack_require__(85) + ") no-repeat;\n  text-align: center;\n  margin: 0 8px 20px 0;\n  position: relative;\n  display: inline;\n  float: left;\n  overflow: hidden;\n  font-size: 12px;\n}\n#uploader .filelist li p.log {\n  position: relative;\n  top: -45px;\n}\n#uploader .filelist li p.title {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  top: 5px;\n  text-indent: 5px;\n  text-align: left;\n}\n#uploader .filelist li p.progress {\n  position: absolute;\n  width: 100%;\n  bottom: 0;\n  left: 0;\n  height: 8px;\n  overflow: hidden;\n  z-index: 50;\n  margin: 0;\n  border-radius: 0;\n  background: none;\n  -webkit-box-shadow: 0 0 0;\n}\n#uploader .filelist li p.progress span {\n  display: none;\n  overflow: hidden;\n  width: 0;\n  height: 100%;\n  background: #1483d8 url(" + __webpack_require__(86) + ") repeat-x;\n  -webit-transition: width 200ms linear;\n  -moz-transition: width 200ms linear;\n  -o-transition: width 200ms linear;\n  -ms-transition: width 200ms linear;\n  transition: width 200ms linear;\n  -webkit-animation: progressmove 2s linear infinite;\n  -moz-animation: progressmove 2s linear infinite;\n  -o-animation: progressmove 2s linear infinite;\n  -ms-animation: progressmove 2s linear infinite;\n  animation: progressmove 2s linear infinite;\n  -webkit-transform: translateZ(0);\n}\n@-webkit-keyframes progressmove {\n  0% {\n    background-position: 0 0;\n  }\n  100% {\n    background-position: 17px 0;\n  }\n}\n@-moz-keyframes progressmove {\n  0% {\n    background-position: 0 0;\n  }\n  100% {\n    background-position: 17px 0;\n  }\n}\n@keyframes progressmove {\n  0% {\n    background-position: 0 0;\n  }\n  100% {\n    background-position: 17px 0;\n  }\n}\n#uploader .filelist li p.imgWrap {\n  position: relative;\n  z-index: 2;\n  line-height: 110px;\n  vertical-align: middle;\n  overflow: hidden;\n  width: 110px;\n  height: 110px;\n  -webkit-transform-origin: 50% 50%;\n  -moz-transform-origin: 50% 50%;\n  -o-transform-origin: 50% 50%;\n  -ms-transform-origin: 50% 50%;\n  transform-origin: 50% 50%;\n  -webit-transition: 200ms ease-out;\n  -moz-transition: 200ms ease-out;\n  -o-transition: 200ms ease-out;\n  -ms-transition: 200ms ease-out;\n  transition: 200ms ease-out;\n}\n#uploader .filelist li img {\n  width: 100%;\n}\n#uploader .filelist li p.error {\n  background: #f43838;\n  color: #fff;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  height: 28px;\n  line-height: 28px;\n  width: 100%;\n  z-index: 100;\n}\n#uploader .filelist li .success {\n  display: block;\n  position: absolute;\n  left: 0;\n  bottom: 0;\n  height: 40px;\n  width: 100%;\n  z-index: 200;\n  background: url(" + __webpack_require__(87) + ") no-repeat right bottom;\n}\n#uploader .filelist div.file-panel {\n  position: absolute;\n  height: 0;\n  background: rgba(0, 0, 0, 0.5);\n  width: 100%;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  z-index: 300;\n}\n#uploader .filelist div.file-panel span {\n  width: 24px;\n  height: 24px;\n  display: inline;\n  float: right;\n  text-indent: -9999px;\n  overflow: hidden;\n  background: url(" + __webpack_require__(88) + ") no-repeat;\n  margin: 5px 1px 1px;\n  cursor: pointer;\n}\n#uploader .filelist div.file-panel span.rotateLeft {\n  background-position: 0 -24px;\n}\n#uploader .filelist div.file-panel span.rotateLeft:hover {\n  background-position: 0 0;\n}\n#uploader .filelist div.file-panel span.rotateRight {\n  background-position: -24px -24px;\n}\n#uploader .filelist div.file-panel span.rotateRight:hover {\n  background-position: -24px 0;\n}\n#uploader .filelist div.file-panel span.cancel {\n  background-position: -48px -24px;\n}\n#uploader .filelist div.file-panel span.cancel:hover {\n  background-position: -48px 0;\n}\n#uploader .statusBar {\n  height: 53px;\n  border-bottom: 1px solid #dadada;\n  padding: 0 20px;\n  line-height: 53px;\n  vertical-align: middle;\n  position: relative;\n}\n#uploader .statusBar .progress {\n  border: 1px solid #1483d8;\n  width: 198px;\n  background: #fff;\n  height: 18px;\n  display: inline-block;\n  text-align: center;\n  line-height: 20px;\n  color: #6dbfff;\n  position: relative;\n  margin: 0 10px 0 0;\n}\n#uploader .statusBar .progress span.percentage {\n  width: 0;\n  height: 100%;\n  left: 0;\n  top: 0;\n  background: #1483d8;\n  position: absolute;\n}\n#uploader .statusBar .progress span.text {\n  position: relative;\n  z-index: 10;\n}\n#uploader .statusBar .info {\n  display: inline-block;\n  font-size: 14px;\n  color: #666666;\n}\n#uploader .statusBar .btns {\n  position: absolute;\n  top: 10px;\n  right: 20px;\n  line-height: 30px;\n}\n#filePicker2 {\n  display: inline-block;\n  float: left;\n}\n#uploader .btns .webuploader-pick,\n#uploader .btns .uploadBtn,\n#uploader .btns .uploadBtn.state-uploading,\n#uploader .btns .uploadBtn.state-paused {\n  background: #ffffff;\n  border: 1px solid #cfcfcf;\n  color: #565656;\n  padding: 0 18px;\n  display: inline-block;\n  border-radius: 3px;\n  margin-left: 10px;\n  cursor: pointer;\n  font-size: 14px;\n  float: left;\n}\n#uploader .btns .webuploader-pick-hover,\n#uploader .btns .uploadBtn:hover,\n#uploader .btns .uploadBtn.state-uploading:hover,\n#uploader .btns .uploadBtn.state-paused:hover {\n  background: #f0f0f0;\n}\n#uploader .btns .uploadBtn {\n  background: #00b7ee;\n  color: #fff;\n  border-color: transparent;\n}\n#uploader .btns .uploadBtn:hover {\n  background: #00a2d4;\n}\n#uploader .btns .uploadBtn.disabled {\n  pointer-events: none;\n  opacity: 0.6;\n}\n.modular-edit {\n  position: relative;\n  overflow: hidden;\n}\n.modular-edit > div > div {\n  transition: all 400ms ease-out 0s;\n  -o-transition: all 400ms ease-out 0s;\n  -moz-transition: all 400ms ease-out 0s;\n  -webkit-transition: all 400ms ease-out 0s;\n  transform-origin: center;\n}\n.modular-edit .mar-pad {\n  padding: 0;\n  list-style-type: none;\n}\n.modular-edit .modular-type-list {\n  padding: 0;\n  list-style-type: none;\n  display: block;\n  background: #fff;\n}\n.modular-edit .modular-type-list li {\n  background: #fff;\n  text-align: center;\n  border: 1px solid #f3f3f3;\n  padding-bottom: 15px;\n  cursor: move;\n}\n.modular-edit .modular-type-list li .modular-icon {\n  display: block;\n  line-height: 50px;\n  height: 50px;\n  text-align: center;\n  font-size: 18px;\n  color: #999;\n}\n.modular-edit .modular-center {\n  padding: 80px 0 80px 0;\n  position: relative;\n}\n.modular-edit .modular-center .modular-center-bg {\n  background: url(" + __webpack_require__(89) + ") #eee;\n  box-shadow: rgba(0, 0, 0, 0.4) 0 0 30px inset;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n}\n.modular-edit .modular-center .modular-phone {\n  width: 375px;\n  height: 667px;\n  background: #fff;\n  margin: auto;\n  position: relative;\n  z-index: 5;\n  overflow: hidden;\n  overflow-y: auto;\n}\n.modular-edit .modular-center .modular-conentlist {\n  border: solid 1px #fff;\n  background: #fff;\n  cursor: move;\n  z-index: 5;\n  position: relative;\n}\n.modular-edit .modular-center .modular-conentlist .modular-remove {\n  position: absolute;\n  top: 0;\n  right: 0;\n  width: 15px;\n  height: 15px;\n  line-height: 15px;\n  text-align: center;\n  cursor: pointer;\n  font-size: 12px;\n  font-style: normal;\n  background: #00adff;\n  color: #fff;\n}\n.modular-edit .modular-center .modular-conentlist[ng-drop].drag-enter {\n  content: \"\";\n  background: #f5f5f5;\n  display: block;\n  border: 1px dotted #0099DA;\n  z-index: 3;\n}\n.modular-edit .modular-center .modular-conentlist[ng-drop].drag-move {\n  z-index: 10;\n  background: #fff;\n  opacity: .8;\n}\n.modular-edit .modular-center .modular-conentlist.active {\n  border: solid 1px #00adff;\n  box-shadow: 0px 0px 2px #00adff;\n  z-index: 6;\n}\n.modular_radio {\n  width: 18px;\n  height: 18px;\n  overflow: hidden;\n  display: inline-block;\n  border: solid 1px #ddd;\n  background: #fff;\n  position: relative;\n  z-index: 0;\n  cursor: pointer;\n  border-radius: 50px;\n}\n.modular_radio:hover,\n.modular_radio.checked {\n  border: solid 1px #1abc9c;\n}\n.modular_radio.checked:before {\n  content: \"\";\n  border-radius: 50px;\n  overflow: hidden;\n  width: 6px;\n  height: 6px;\n  background: #1abc9c;\n  display: inline-block;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  z-index: 5;\n  margin: -3px 0 0 -3px;\n}\n.modular-form-tab {\n  padding: 0;\n  list-style-type: none;\n}\n.modular-form-tab li {\n  padding: 0;\n}\n.modular-form-tab li a {\n  padding: 0;\n  color: #666;\n  border-top: solid 2px #f5f5f5;\n  background: #f5f5f5;\n  list-style-type: none;\n  margin: 0;\n  line-height: 40px;\n  text-align: center;\n  height: 38px;\n  display: block;\n}\n.modular-form-tab li a:hover {\n  background: #f9f9f9;\n  color: #333;\n}\n.modular-form-tab li.active a,\n.modular-form-tab li.active a:hover {\n  background: #fff;\n  color: #333;\n  border-top: solid 2px #337ab7;\n}\n", ""]);

	// exports


/***/ }),
/* 83 */
/***/ (function(module, exports) {

	"use strict";

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function () {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for (var i = 0; i < this.length; i++) {
				var item = this[i];
				if (item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function (modules, mediaQuery) {
			if (typeof modules === "string") modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for (var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if (typeof id === "number") alreadyImportedModules[id] = true;
			}
			for (i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if (mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if (mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};

/***/ }),
/* 84 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAABLCAIAAAB7tddWAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1Q0VBNzA0MjEyMDUxMUUzODk2Q0JFM0Q1RjE4QkExQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1Q0VBNzA0MzEyMDUxMUUzODk2Q0JFM0Q1RjE4QkExQyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjAzNDA2MkY1MTIwMzExRTM4OTZDQkUzRDVGMThCQTFDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjAzNDA2MkY2MTIwMzExRTM4OTZDQkUzRDVGMThCQTFDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+K6izdgAAAvpJREFUeNrsnFmPqkAQhWmX667gEp9c/v+/MkSDG+4LrvdcSYgRbw/0ALZQ9WBUJOn+uqvqHGCG3e93hUJRUoSAQBAIAkEgCASBIBAE4neRicEcII51Xb/dbnjPGOt0OqlUKok7ApN3jIKwY6DUIBAEgkAQCALho/X47TeXy8U0TcuyrtdrZKPs9/v2m8FgINYgf9QX/gTV+Xw2DCNKBJKmxmKxsAVc0kEcDgfyGq8CNp/Pa5qWy+WiHG6v13v7/XPt6Ha7Al5D3HQ1Go1sNkvtU8lkMsmtESSoCASBSFqEW/DQ0tbr9W63O51OKK6FQkFV1XQ6nSwQ0OOTyQSvjknZbDaA0mq1QCQafSFFasxmM4eCE1Do0+lUQrcSFggsPhzq20NgsVqtkpIax+MxMs+C/aXruvMxaonND75J9W5hUWWxuYAVdRfTg8EplUphGJywQPAFuBd5Dlhw/aDwwgVtCDgCdzph1QisG+dosVjkn44WYxjGC4XnvBuNRtvt9gtA2Hv47SGsZKVS4ef8eDzG4vMVCrpSgEU3xPbZbDar1erLl1AQ7XabU8xAAXvB3XffBnIHwkR2QcUYq9fr5XIZOxkTg6BEkeNLKdQF7AWPFBy1AoUmu8RG/HmE91nxM+J/ORIr07VcLvf7feCt+stAQGIBRNJtOJolDAhdj/hXGj5+u+TzIKAF+MbkK00XFta2BhDRUE0/9gv8Elogbu4TBW8+nyPhHSeuaVqtVuNQC6TzyQUCXsg0TbfyAxfIKogr9ynP1GJyYQZ57qbg7AuIRfclKZwSlDqWBQSmxM9zFALYh+fFBwJJSkNgqeFxSrAPw+EQ9QJew7Is2Sj8FgSW2nu1gylYPkKRMsRTA+4IcjA2fxsnDkLOq/IfACFP54uP1yAQBIJAEIh4gWCPkHk+GJ7AjU/fICJ+qlIghEfoDwQMtRjvyLYDRih4rsDT+bBM9tP5kuhrzN++e6SqqvCdYUb/SIO6BoEgEASCQBAIAkEgCEQg8VeAAQAB1bbO2qoeewAAAABJRU5ErkJggg=="

/***/ }),
/* 85 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG4AAABuCAIAAABJObGsAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowMzQwNjJFRjEyMDMxMUUzODk2Q0JFM0Q1RjE4QkExQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowMzQwNjJGMDEyMDMxMUUzODk2Q0JFM0Q1RjE4QkExQyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjAzNDA2MkVEMTIwMzExRTM4OTZDQkUzRDVGMThCQTFDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjAzNDA2MkVFMTIwMzExRTM4OTZDQkUzRDVGMThCQTFDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Phg2/QAAB5VJREFUeNrsXdFu4zAMSw3/wPb/v7jtE3bF7dBljiWRlJzugNzDIUhTx6sVmqRk5/b+/r5t28vLy/3/j4+Px/H9/O12O56/H39+fr6+vh7PU8df9/XbQfrgXFNybLV/7H/bdv/u/dvIf/uvhF/fX3D7+y+8Zn/+8dH94PHRtBH5z8H7f7z17etjMBbkMUzG8vS7Qj/37bD9Ca9vx99++LGpsXVixPlIa1ZocP+Vx/EQ7+F3rWv6E2Mkc9+wD8Oxg8v78wh2W9c0HBr88ckEXSam9t2wLrBwmcVHv5EJVmZwZIjN8PzJmJvB+vC4TcdhOuZWkFrz6XA+HF5w/JeGv9X4Hk8t3tIt7DiOj4VNCAYhY7su1kB8d64J+3b/bsvwr2SAZHgfxWeRrg7PIvU3fn33GytZXJvOpwjWWPOpNf9WYR/b5tDPMK5b+POH5weMQ+IlHH8h3qf3crAvbGcUM1GXCKy04lTDxPM1uNbnS4NfGvzS4JcGvzT4pcEvDX5p8EuDXxr80uCXBr80+KXBqzT4cdxCPTDV4IJmB9uX53HHK5CfCYfbdicWqDh1xp+Nd4rbgtgX8pD98zQ8W6icm/JKeaxwjXGOrk9iLvXcNGrim46VxSurCOA0uEB+uohmTs93fJxlXGPjLtmHUFMvqjdqyDhX4ZEzz1rxvoK3OmFO3XrgKgFWsj6Qg63lfuUTtXmAlSEOgiBCzX1IUDgcILxGCC6ZbNzuvzcbd0tx8zd4PA4ncdpsCE9EcjLnWJaU781i6NSawjkJwStB7Cjheoj+rYrHqutbxjfW5LMwX1Pxzooo9mGy+t+dmDqZY8q5QIEDLOGVQnxZUx7LSdnpEvHzMznL6d+FY/G/WE3q5fI40nKHFPaxvlSokXrJ5CvYghT4Wh4iImYovoHEtdVgL4wjNq4ztRJgPLKYznqvJlY6eTVEDyDadhoviJ5x+hD6jKzPAHZmwNNJbqcKB/dxKvDT8vziCk8oyO0MsUnFmhWnIGAhWlvGbicvX1Kv0QV+x2oPq00EK4c4kvUPy1sRTj30rSU95JDiOfMpwmGtuKYkjVAzRFGFrwM9t7PaB1pRL1fimdZr8LDeMOn9UH7VCi2P5K8gDX7kidMYKdFIx7keaROvbUI4Q7J27n5NtzBL8IRKxBIytyIxYvnwIJeY1r0HdEXL7WT8zSTmytyQ7Rvoq054ZZX9x9JA2V5kNQkSj2we/wevrOX9bJ46X3tWWE+c9Jlact2LxR/ZuX6q/dm4sO5V5Zn7dc/nrdsprNHQ9P7q/GWrrZVAfGkWy6r0/uq6j+5zybAWvcrTLmnT8tvxmvNMnXxzPEcWH6m628ycDtaGIPq95JkY/cpyLglimfVMlHiLST6wCet2hBodRBdPvRkrRvbXVHmLGZ7I4mxnaxJ9T7MqlmvXxCLaP88TmhB6JTlrhK8VeouWHpd9z+OzMs/tPKsmbVHeEZ/rBb3/uKbhPjkotKm9ChCPkm0H8TTBdbmI//T4qIPryNj6ITY3jbSzMftuaH3L8N+O8DIQy0JeCfKEsB1hH4UqzuvUgHzXDGU8mBKcPWGfg42sG6W4aqPmL2tOZ+lb1XpE5BrkXpbmoZ6PLtQ2InXahbUeiI7OPx+slz7hlWA9Detjy/XqYNGlxTHC54P1t3A8JWqGBHwpWXuBrB8/YU/qMN57ONWyuTqW4smB7Gj5Kh0VduMHr6xaHyusyz5hjRi79obF+h97sg1+zAr/ORxP5Lsst937p1ae3dFpyiMY5sHLY5PFxCo+WLi+KMDKFaU/lJ4V/ETEA0e4sKzBfviVSez4X46F/BWr91s+p6FpDwenkGtYL8ry6hFegZZPyVi5Yv79DW3Kz18ricfMMmp5Ti+kGSVbfvRF4yxc7+voE/ZmsbTZBuyBtTnrwQWeKMeRU8RR4qsje3yAHNPKoc/3ZCtcmyjrqDO9SzYHGfuVJfucWDkTa1+BEpDF53Ew1aOR015Vsw3mtcO8+QrdAtY8yfmreR489MyTG2dUrS9k161PY1NYC+TcSF8PLnvphT6NfP0Kz7+xnN6PU7ZmDDQ0Ec6A+DoZzR5r8DPXryJ4yr4TwqrjWbRXAYGVlH29Yp4VHo7MPoVIjgj8Q07yK5PxsvT9AEINPLF/ZXJvk+ngs3sJhKEK7q2J5Pdl73Xffv8l+5azWAnide06OL/9VlXvsMKkyXjyG7+nglxXBO2dIaxZlHU6u196Zo5mc+tI+x3HI6s+HNnXp6rYKDlHUwlF1j8tw0prjSOy9pHFu6o6kdq5oQs+NqLZ2doNKhckF8bnc/oezaj1KxftVbElatXK90+Ka9GtOgj2HSIl/rmTI2R1CLsnG7j98KSfb29vz9qzZTtrve6KdZbzPDilE9jAZOsZ2fuuWL+I+GQpDV743rGNWQ9xsr6Wjxv+2zv1jFOMA/cUtPiAs7QCx7Khbm3pOyf6ivfZrqijTO4JQ+VtND3ehJoL2UdJ5nxC7Ev68KHn5K8B5vzKZN6xJAZX58Er3+MI+jEUZmXyjoL385R3APaMJ+TsN75Vv/s7+Rxs6/c26GzgIO8JFfaJZmlm6DOyz4rwLqsBu/8IMABtO5BOvs4uDQAAAABJRU5ErkJggg=="

/***/ }),
/* 86 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAQCAYAAADwMZRfAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowMjgwMTE3NDA3MjA2ODExODA4M0E4MzgzMTAzRTZGOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCRjFGMDIxRDFEMEIxMUUzQUExRkU5NjcxMEMxOEM3QyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCRjFGMDIxQzFEMEIxMUUzQUExRkU5NjcxMEMxOEM3QyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDQ4MDExNzQwNzIwNjgxMTgwODNBODM4MzEwM0U2RjkiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDI4MDExNzQwNzIwNjgxMTgwODNBODM4MzEwM0U2RjkiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz62XI8XAAABI0lEQVR42oSTf0vDMBCGkyajTBmOwXR+Bb//9/EvnT+GTkXGbJv4XImlS3MuEK5prs+99ya1IYQ7a+3cTEfouu6euM83yDfsGb7t11XbtltiLEAqkm+IzpQqJECfyGLP/CglVlV1SVjn72OM/RxXi0lNKHDYttfEetyKqJA4QFI80OOromZG2ORKTnL+3qPmhc2jAloSFucgMn40k5HukxqX+5FD5NjeSPhS1CyArXI/JhAxuWmarVEcliOniJ8UyHvk+RtFOwVUO+c2RUh+DfDmSTwqgYCsaO3i5J6Y8jgCelZu8gzQrQg7BzFAdlQ7KCZfAVoO6/y4Rv0HTH5Qaljv/aBGVZJ+sk9MfleKzMVkEfEvRO4DbT2S2Comr2mt/hVgANU+nayGWj9TAAAAAElFTkSuQmCC"

/***/ }),
/* 87 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowMzQwNjJGMzEyMDMxMUUzODk2Q0JFM0Q1RjE4QkExQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowMzQwNjJGNDEyMDMxMUUzODk2Q0JFM0Q1RjE4QkExQyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjAzNDA2MkYxMTIwMzExRTM4OTZDQkUzRDVGMThCQTFDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjAzNDA2MkYyMTIwMzExRTM4OTZDQkUzRDVGMThCQTFDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+tQEWygAAAsdJREFUeNrM2E1oE0EUB/D/zmwSt6lJ6EdaPAhaq6itVWNbhEIP9aCgJ8GjUAQPFTz04AceFEFPIoj24EURRMWLRU8iwepJ8RApSg+2ghRFiqUpLcZNOjO+Talf/dpupmYGBhIym/nxZt6bSazEjTwMbueZyTjqF5jJOO8FMxlnIvAvnGnAeTiTgAviTAEuijMBuCSu3MBlceUE+sKVC+gbVw7ginD/G7hinNfsUmd9nroFaXNEYzVgMgSbO7DDMUQicTDbgVQKWx7WB8JpAXLOUVu9AUJWUh9FmHEwlUMhJ+C6Cql0KjBOyxJXVSfhOFEoJVAoeL0AJVyKplsyTksE3YKD3MQkJJuGFYrBnRH4Uchh78vOknFaIljpNNK+q0Y+n4eAA8uOEm6/FpwWIKtgiNckEAqvA0cO7ekObTg9Zcbi1KO0D2vRlt4XCJeIAMeaGJprLP1AqWxKkBBanjQGjtyZNo4rnRyHGph+oEURbLgfD4zrWm+hezvDFP24fPZJ6gdufhActzY8G70w7ZK+twJvvirtwJISoqeFYU+dhcyYws1BqT1JSsLtSlro2cnhCuDiK4GsqzeLl8RVhoCNcWvRh9fQ8XCunSNGS3znvcTAqNJaZpbEcXKd3M0xcMTGWdpfET5/zNFtrJgcHycVrmWk1jq47LJKCsbQuEKIvvlUK0NfF0ey4vfnmxIWelO8OO7Sa4kv00ob0Nee86Z7NCzR/VTgM01+uJHh7gEbW6tml/w0oesI3E9jHo/I5cuYz3+3AiVEE50MV6kAt9ZbGM4qqnMKx3cwjOeAg/0z+DChtABLylZveS938GIk51rvC4Hb76Sv5+3VxHlt7DtwIi0wkqXztplRxkrcG5K+n7dXE/frzki17npGYPCbKiaQ9973UbrIEmu9Mum+bhmDWwhoFO5foHG4P4FG4uaAxuK89lOAAQB29OXDkHc5ugAAAABJRU5ErkJggg=="

/***/ }),
/* 88 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEEAAAAoCAYAAAChDJfXAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowMTgwMTE3NDA3MjA2ODExODIyQTg3ODcxNkNBOEMyQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowNjYxRTBFRjI5MDUxMUUzOERBNkExNjY3QTI5NkMyNyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNjYxRTBFRTI5MDUxMUUzOERBNkExNjY3QTI5NkMyNyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NjhDREVCQjAyNjIwNjgxMTgyMkE4Nzg3MTZDQThDMkEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDE4MDExNzQwNzIwNjgxMTgyMkE4Nzg3MTZDQThDMkEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7fB/tsAAAGpElEQVR42uxZa0wcVRS+u+yygCDtNhFI2qRgqm00GzdFaxotogRsbAwS6wNSI0qsrUETE/wBQUNo+4cfTco/QiWhNlbb9EkkFKhptRpMyRKiESWlTVpMGxV5Lm/W7xvvrMMw7A67sCW6JzmZnZnzuPvde8+cmc+S3zomIG6o52xNjdhdXi6sVquIiYkRqszOzoq5uTnR1tYmsrKyxMzMjGg6fFi552v5RKyEvNTmdZ/JSfCICIgtLi6Ox/aJiYlcHLugb0NfhuZo7K5AT0HroJPhJn3l8vR+AP0qgN6hAboNQJ86eejQ0fyysscwrou47AwWy5JXJV6rrFQmTp0wyCXEztbb4t7XODyrTjAn9vOnrMJSeNWnTCgu/IXj7wj20GIJYXMTYBVgJXhCWQm7mocyEhMTG7R/3iDHzzikYhxrj28XlqWCIMUXyEWTSwHB78mkBAA3fpuenn5/aGjoQToMDAxswPlbuH4d9zdihr7B9U2hLO+kpKRuAsBYjMnY/KPMxZzMjRxbOJalrGboqPzjviAACJ3dKEC0WQ2MEjHTP8TGxvaNj4/z/Da0wePxuLCczmKA90EaZXJTsrm2MwHgnaMvYzDWl1n2huZdTsYWTTuT+wDC98wdwu6a8fl8ZwDg9FKcaA+/U1jJMwtAwEDvdzgc3I/bdLe8XV1dRVyumM0nUUD3sYiaEZfL9Q7ibqAvY/SUbvVq7xe0j28DSO3MHWKZ2YPYsVCLXO4BlXa0x+83hWY2LSaTebFKDmKVfIYBF35x4ECtyApeE2irTBl89QBQTj8X34FDckhFtqJCYEb58yC0DGo34cZVUwO/CmV8ZhL19fUJFDRFb9y4cV5BzWLZamZLcM9JW7/vcgoLotQyqN2kj13a/3M+NTXlr5T9/f0LIZtesNVGYDvBQFklJUFnjzawtdLnWvHDIysIgh+AwcHBjcj3I+rPVc4Djzi/JbfCLQ0QwnAlEAg+a1kU4+PjjfImwTmOheVyff1QsEHSBrZz9Mls+CVJRFhk3+CfaEMgzQTKyMgQo6OjyrZIT09/QXnO+Hyd3ObBfFl9ZRPm911tQhCK5DPzDnRdEHuHzWarkKgeM/t0wGwcU6qwzfaxs7LZEcj2mZP9617/du5O0XfCh87yjUiBcByD/ArLNSU1NfV0ACAScnNzT8DuUe4xtLd1UGGysB7lXmQjxBjsGxYDgGPgWNhGo5dojAgIXObo2PZikH+wm0tLS+NLSyl0vbR5AFrsdrs9uJ8Pu+GxsbFiM1tBFRbEycnJ3SyOjMFYmOXinDN3GVvsbBpYj/NS5pYd5TDGVLwcf1D7Iqhrrf99gj1/4U8hl+omPALZ1W0J0GVdR8EswCx1h/Lu8GLLyOaEhIRGDOzxADl+9Xq9BedyE38yExNbR/05zuK7hI5xAof4ee8OkN4T1dUu9vT4ky3SSGkvuTRx/d2WlpZHcKk71Fk5n5fUc+LpmCcQ6z3EvKKrG2oOl1kA1Oov9SOuZpMA3KW9+uSwyG7rfy1WEZUoCFEQoiBEQYiCEAXBCAR0ZwLq5rGqqkr5fqB9/VQbEl5vbm6mrRgeHlZsqcGks7NTUfqhFfbHWiwHY2rHFBEQyDvw+x5+Z8ovRXuhrWL+V9nL8n3CsUx598uY2hytMjfHkMkxSU4koBA07XcC2T1e0sVWlNf13xfob5MvFWtJdlRWVhryDnypoebl5X1I3gGXQmWGMqANdrt9h0GOHCrG8IGQvEMYL0zZi9zLDlgTVpp3gBjyDsxxL3kH+keEd+C3CD3vwJiMzRzMda94B/rbDD5cKrwD3v/JTXZobim8g9vtvkbeoby8fB+u1QZL5nLx/4p5vANj6czIO1wMk3fYE+ibgQ4ARS0Wy7ztoCcoknUA+IEgdyCTFR4y8WWJNlrewQAAIXMlG4wjqFTM5x2mjAqigdLuIP3ov+K8A220vIMahzGX5fEWJu+gaDi8Q4kJ3qFEwzvQN0hsZQzqI8/ofgAQQuIdFDUahFneod4E71Cv4R3oq7/PHMzFnEaTEK6sCt5B2vh5B8ZgLMZcTe8OIfMO5SZ4B9poeQcTXec6ORaOaXXzDqj6dWaeDpx5Pe/AWIsBoOUdcP7f4R1YEPW8A2PK2ELmWsA7jIyEz9+a4R3UR9xtgLFd5R2gR5xO5xHeSElJ0RYWhXfAz94QxtMB8Nwq74Acn6qxkUubQ+EdZKdqqvGRMqHyDmvWrLmpbZM1QPhUIFRKQV8Ye6tXmHeA9ECD8g44jRjvQP1bgAEAaPHJK84nkDYAAAAASUVORK5CYII="

/***/ }),
/* 89 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkNCREUxQURERjFDQjExRTc4MzYwQ0YxRUI5MDJFODJCIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkNCREUxQURFRjFDQjExRTc4MzYwQ0YxRUI5MDJFODJCIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6Q0JERTFBREJGMUNCMTFFNzgzNjBDRjFFQjkwMkU4MkIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6Q0JERTFBRENGMUNCMTFFNzgzNjBDRjFFQjkwMkU4MkIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5YcSp4AAAAKklEQVR42mL8//8/AzZw9uxZrOJMDCSCUQ3EABZc4W1sbDwaSvTTABBgAPnECIaRwiyRAAAAAElFTkSuQmCC"

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}

	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}

	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}

	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}

	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;

		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		var blob = new Blob([css], { type: "text/css" });

		var oldSrc = linkElement.href;

		linkElement.href = URL.createObjectURL(blob);

		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _homeGrid = __webpack_require__(92);

	var _homeGrid2 = _interopRequireDefault(_homeGrid);

	var _Redux = __webpack_require__(93);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _toConsumableArray(arr) {
		if (Array.isArray(arr)) {
			for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
				arr2[i] = arr[i];
			}return arr2;
		} else {
			return Array.from(arr);
		}
	} /*
	   * 路由配置
	   */

	// 通用路由配置
	exports.default = {

		config: ['$stateProvider', '$urlRouterProvider', 'routerProvider', '$locationProvider', function ($stateProvider, $urlRouterProvider, routerProvider, $locationProvider) {
			var state = [['home', {
				url: '/',
				template: _homeGrid2.default,
				controller: 'module.home.controler'
			}]];
			state.forEach(function (value) {
				$stateProvider.state.apply($stateProvider, _toConsumableArray(value));
			});
			// $locationProvider.html5Mode(true);
			$urlRouterProvider.otherwise('/');
		}],

		run: function run(router) {
			router.setUpRoutes();
		},

		provider: ['router', function ($stateProvider) {
			this.$get = function ($http, $state) {
				return {
					setUpRoutes: function setUpRoutes() {
						(0, _Redux.readRedux)({
							type: "ROUTES"
						}).forEach(function (value) {
							console.log(value);
							$stateProvider.state.apply($stateProvider, _toConsumableArray(value));
						});
					}
				};
			};
			return this;
		}]
	};

/***/ }),
/* 92 */
/***/ (function(module, exports) {

	module.exports = "<modular-eidt-type \r\n\t\t\t\tdata-id=\"15\"\r\n\t\t\t\tdata-ng-if=\"modularData\" \r\n\t\t\t\tdata-item=\"modularData\" \r\n\t\t\t></modular-eidt-type>";

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.watchRedux = exports.removeRedux = exports.readRedux = exports.getRedux = undefined;

	var _lodash = __webpack_require__(94);

	var _ = _interopRequireWildcard(_lodash);

	function _interopRequireWildcard(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }newObj.default = obj;return newObj;
	  }
	}

	function _toConsumableArray(arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }return arr2;
	  } else {
	    return Array.from(arr);
	  }
	} /*
	   * @name:tql
	   * 共享数据存储处理
	   */

	var reduxScope = {};

	/*
	 * 存储数据
	 * @scope => 数据存储
	 * @action => 参数
	 */
	var getRedux = exports.getRedux = function getRedux(scope, action) {
	  reduxScope[action.type] = reduxScope[action.type] || [];
	  reduxScope[action.type] = reduxScope[action.type].length != 0 ? [].concat(_toConsumableArray(reduxScope[action.type]), _toConsumableArray(scope)) : scope;
	  return reduxScope;
	};

	/*
	 * 读取数据
	 * @action => 参数
	 */
	var readRedux = exports.readRedux = function readRedux(action) {
	  return reduxScope[action.type];
	};

	/*
	 * 消耗数据
	 * @action => 参数
	 */
	var removeRedux = exports.removeRedux = function removeRedux(action) {
	  _.remove(reduxScope, function (n) {
	    return n.type == action.type;
	  });
	  return reduxScope;
	};

	/*
	 * 消耗数据
	 * @action => 回调
	 * @success => 监听回调
	 */
	var watchRedux = exports.watchRedux = function watchRedux(action, success) {
	  setInterval(function () {}, 1000);
	  return reduxScope;
	};

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, module) {'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};/**
	 * @license
	 * Lodash <https://lodash.com/>
	 * Copyright JS Foundation and other contributors <https://js.foundation/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.17.4';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,reLeadingDot=/^\./,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
	   * Used to match `RegExp`
	   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g,reTrimStart=/^\s+/,reTrimEnd=/\s+$/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
	   * Used to match
	   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
	   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f',reComboHalfMarksRange='\\ufe20-\\ufe2f',rsComboSymbolsRange='\\u20d0-\\u20ff',rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos='[\'\u2019]',rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)',rsOrdUpper='\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
	   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
	'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
	'\u0100':'A','\u0102':'A','\u0104':'A','\u0101':'a','\u0103':'a','\u0105':'a','\u0106':'C','\u0108':'C','\u010A':'C','\u010C':'C','\u0107':'c','\u0109':'c','\u010B':'c','\u010D':'c','\u010E':'D','\u0110':'D','\u010F':'d','\u0111':'d','\u0112':'E','\u0114':'E','\u0116':'E','\u0118':'E','\u011A':'E','\u0113':'e','\u0115':'e','\u0117':'e','\u0119':'e','\u011B':'e','\u011C':'G','\u011E':'G','\u0120':'G','\u0122':'G','\u011D':'g','\u011F':'g','\u0121':'g','\u0123':'g','\u0124':'H','\u0126':'H','\u0125':'h','\u0127':'h','\u0128':'I','\u012A':'I','\u012C':'I','\u012E':'I','\u0130':'I','\u0129':'i','\u012B':'i','\u012D':'i','\u012F':'i','\u0131':'i','\u0134':'J','\u0135':'j','\u0136':'K','\u0137':'k','\u0138':'k','\u0139':'L','\u013B':'L','\u013D':'L','\u013F':'L','\u0141':'L','\u013A':'l','\u013C':'l','\u013E':'l','\u0140':'l','\u0142':'l','\u0143':'N','\u0145':'N','\u0147':'N','\u014A':'N','\u0144':'n','\u0146':'n','\u0148':'n','\u014B':'n','\u014C':'O','\u014E':'O','\u0150':'O','\u014D':'o','\u014F':'o','\u0151':'o','\u0154':'R','\u0156':'R','\u0158':'R','\u0155':'r','\u0157':'r','\u0159':'r','\u015A':'S','\u015C':'S','\u015E':'S','\u0160':'S','\u015B':'s','\u015D':'s','\u015F':'s','\u0161':'s','\u0162':'T','\u0164':'T','\u0166':'T','\u0163':'t','\u0165':'t','\u0167':'t','\u0168':'U','\u016A':'U','\u016C':'U','\u016E':'U','\u0170':'U','\u0172':'U','\u0169':'u','\u016B':'u','\u016D':'u','\u016F':'u','\u0171':'u','\u0173':'u','\u0174':'W','\u0175':'w','\u0176':'Y','\u0177':'y','\u0178':'Y','\u0179':'Z','\u017B':'Z','\u017D':'Z','\u017A':'z','\u017C':'z','\u017E':'z','\u0132':'IJ','\u0133':'ij','\u0152':'Oe','\u0153':'oe','\u0149':"'n",'\u017F':'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=(typeof global==='undefined'?'undefined':_typeof(global))=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=(typeof self==='undefined'?'undefined':_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=( false?'undefined':_typeof(exports))=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&( false?'undefined':_typeof(module))=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*//**
	   * Adds the key-value `pair` to `map`.
	   *
	   * @private
	   * @param {Object} map The map to modify.
	   * @param {Array} pair The key-value pair to add.
	   * @returns {Object} Returns `map`.
	   */function addMapEntry(map,pair){// Don't return `map.set` because it's not chainable in IE 11.
	map.set(pair[0],pair[1]);return map;}/**
	   * Adds `value` to `set`.
	   *
	   * @private
	   * @param {Object} set The set to modify.
	   * @param {*} value The value to add.
	   * @returns {Object} Returns `set`.
	   */function addSetEntry(set,value){// Don't return `set.add` because it's not chainable in IE 11.
	set.add(value);return set;}/**
	   * A faster alternative to `Function#apply`, this function invokes `func`
	   * with the `this` binding of `thisArg` and the arguments of `args`.
	   *
	   * @private
	   * @param {Function} func The function to invoke.
	   * @param {*} thisArg The `this` binding of `func`.
	   * @param {Array} args The arguments to invoke `func` with.
	   * @returns {*} Returns the result of `func`.
	   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
	   * A specialized version of `baseAggregator` for arrays.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} setter The function to set `accumulator` values.
	   * @param {Function} iteratee The iteratee to transform keys.
	   * @param {Object} accumulator The initial aggregated object.
	   * @returns {Function} Returns `accumulator`.
	   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
	   * A specialized version of `_.forEach` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
	   * A specialized version of `_.forEachRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
	   * A specialized version of `_.every` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if all elements pass the predicate check,
	   *  else `false`.
	   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
	   * A specialized version of `_.filter` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {Array} Returns the new filtered array.
	   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
	   * A specialized version of `_.includes` for arrays without support for
	   * specifying an index to search from.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}/**
	   * This function is like `arrayIncludes` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
	   * A specialized version of `_.map` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the new mapped array.
	   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
	   * Appends the elements of `values` to `array`.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {Array} values The values to append.
	   * @returns {Array} Returns `array`.
	   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
	   * A specialized version of `_.reduce` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the first element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
	   * A specialized version of `_.reduceRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the last element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
	   * A specialized version of `_.some` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if any element passes the predicate check,
	   *  else `false`.
	   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
	   * Gets the size of an ASCII `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */var asciiSize=baseProperty('length');/**
	   * Converts an ASCII `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */function asciiToArray(string){return string.split('');}/**
	   * Splits an ASCII `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
	   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
	   * without support for iteratee shorthands, which iterates over `collection`
	   * using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the found element or its key, else `undefined`.
	   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
	   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
	   * This function is like `baseIndexOf` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
	   * The base implementation of `_.isNaN` without support for number objects.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	   */function baseIsNaN(value){return value!==value;}/**
	   * The base implementation of `_.mean` and `_.meanBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the mean.
	   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
	   * The base implementation of `_.property` without support for deep paths.
	   *
	   * @private
	   * @param {string} key The key of the property to get.
	   * @returns {Function} Returns the new accessor function.
	   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
	   * The base implementation of `_.propertyOf` without support for deep paths.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Function} Returns the new accessor function.
	   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**
	   * The base implementation of `_.reduce` and `_.reduceRight`, without support
	   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} accumulator The initial value.
	   * @param {boolean} initAccum Specify using the first or last element of
	   *  `collection` as the initial value.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the accumulated value.
	   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
	   * The base implementation of `_.sortBy` which uses `comparer` to define the
	   * sort order of `array` and replaces criteria objects with their corresponding
	   * values.
	   *
	   * @private
	   * @param {Array} array The array to sort.
	   * @param {Function} comparer The function to define sort order.
	   * @returns {Array} Returns `array`.
	   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
	   * The base implementation of `_.sum` and `_.sumBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the sum.
	   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
	   * The base implementation of `_.times` without support for iteratee shorthands
	   * or max array length checks.
	   *
	   * @private
	   * @param {number} n The number of times to invoke `iteratee`.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the array of results.
	   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
	   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	   * of key-value pairs for `object` corresponding to the property names of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the key-value pairs.
	   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
	   * The base implementation of `_.unary` without support for storing metadata.
	   *
	   * @private
	   * @param {Function} func The function to cap arguments for.
	   * @returns {Function} Returns the new capped function.
	   */function baseUnary(func){return function(value){return func(value);};}/**
	   * The base implementation of `_.values` and `_.valuesIn` which creates an
	   * array of `object` property values corresponding to the property names
	   * of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the array of property values.
	   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
	   * Checks if a `cache` value for `key` exists.
	   *
	   * @private
	   * @param {Object} cache The cache to query.
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */function cacheHas(cache,key){return cache.has(key);}/**
	   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the first unmatched string symbol.
	   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the last unmatched string symbol.
	   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
	   * Gets the number of `placeholder` occurrences in `array`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} placeholder The placeholder to search for.
	   * @returns {number} Returns the placeholder count.
	   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
	   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	   * letters to basic Latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */var deburrLetter=basePropertyOf(deburredLetters);/**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
	   * Gets the value at `key` of `object`.
	   *
	   * @private
	   * @param {Object} [object] The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */function getValue(object,key){return object==null?undefined:object[key];}/**
	   * Checks if `string` contains Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	   */function hasUnicode(string){return reHasUnicode.test(string);}/**
	   * Checks if `string` contains a word composed of Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a word is found, else `false`.
	   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
	   * Converts `iterator` to an array.
	   *
	   * @private
	   * @param {Object} iterator The iterator to convert.
	   * @returns {Array} Returns the converted array.
	   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
	   * Converts `map` to its key-value pairs.
	   *
	   * @private
	   * @param {Object} map The map to convert.
	   * @returns {Array} Returns the key-value pairs.
	   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
	   * Creates a unary function that invokes `func` with its argument transformed.
	   *
	   * @private
	   * @param {Function} func The function to wrap.
	   * @param {Function} transform The argument transform.
	   * @returns {Function} Returns the new function.
	   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
	   * Converts `set` to an array of its values.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the values.
	   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
	   * Converts `set` to its value-value pairs.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the value-value pairs.
	   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
	   * A specialized version of `_.indexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
	   * A specialized version of `_.lastIndexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
	   * Gets the number of symbols in `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the string size.
	   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
	   * Converts `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
	   * Gets the size of a Unicode `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
	   * Converts a Unicode `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
	   * Splits a Unicode `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*//**
	   * Create a new pristine `lodash` function using the `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 1.1.0
	   * @category Util
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // Create a suped-up `defer` in Node.js.
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
	     * Used to resolve the
	     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	     * of values.
	     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,_Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=_Symbol?_Symbol.isConcatSpreadable:undefined,symIterator=_Symbol?_Symbol.iterator:undefined,symToStringTag=_Symbol?_Symbol.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*//**
	     * Creates a `lodash` object which wraps `value` to enable implicit method
	     * chain sequences. Methods that operate on and return arrays, collections,
	     * and functions can be chained together. Methods that retrieve a single value
	     * or may return a primitive value will automatically end the chain sequence
	     * and return the unwrapped value. Otherwise, the value must be unwrapped
	     * with `_#value`.
	     *
	     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	     * enabled using `_.chain`.
	     *
	     * The execution of chained methods is lazy, that is, it's deferred until
	     * `_#value` is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion.
	     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	     * the creation of intermediate arrays and can greatly reduce the number of
	     * iteratee executions. Sections of a chain sequence qualify for shortcut
	     * fusion if the section is applied to an array and iteratees accept only
	     * one argument. The heuristic for whether a section qualifies for shortcut
	     * fusion is subject to change.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	     * `zipObject`, `zipObjectDeep`, and `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
	     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
	     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
	     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
	     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
	     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
	     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
	     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
	     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	     * `upperFirst`, `value`, and `words`
	     *
	     * @name _
	     * @constructor
	     * @category Seq
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // Returns an unwrapped value.
	     * wrapped.reduce(_.add);
	     * // => 6
	     *
	     * // Returns a wrapped value.
	     * var squares = wrapped.map(square);
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} proto The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
	     * The function whose prototype chain sequence wrappers inherit from.
	     *
	     * @private
	     */function baseLodash(){}// No operation performed.
	/**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable explicit method chain sequences.
	     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
	     * following template settings to use alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type {Object}
	     */lodash.templateSettings={/**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */'escape':reEscape,/**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */'evaluate':reEvaluate,/**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */'interpolate':reInterpolate,/**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type {string}
	       */'variable':'',/**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type {Object}
	       */'imports':{/**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type {Function}
	         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
	lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*//**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @constructor
	     * @param {*} value The value to wrap.
	     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
	LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*//**
	     * Creates a hash object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
	     * Removes all key-value entries from the hash.
	     *
	     * @private
	     * @name clear
	     * @memberOf Hash
	     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
	     * Removes `key` and its value from the hash.
	     *
	     * @private
	     * @name delete
	     * @memberOf Hash
	     * @param {Object} hash The hash to modify.
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
	     * Gets the hash value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Hash
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
	     * Checks if a hash value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Hash
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
	     * Sets the hash `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Hash
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the hash instance.
	     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
	Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*//**
	     * Creates an list cache object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
	     * Removes all key-value entries from the list cache.
	     *
	     * @private
	     * @name clear
	     * @memberOf ListCache
	     */function listCacheClear(){this.__data__=[];this.size=0;}/**
	     * Removes `key` and its value from the list cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf ListCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
	     * Gets the list cache value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf ListCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
	     * Checks if a list cache value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf ListCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
	     * Sets the list cache `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf ListCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the list cache instance.
	     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
	ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*//**
	     * Creates a map cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
	     * Removes all key-value entries from the map.
	     *
	     * @private
	     * @name clear
	     * @memberOf MapCache
	     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
	     * Removes `key` and its value from the map.
	     *
	     * @private
	     * @name delete
	     * @memberOf MapCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
	     * Gets the map value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf MapCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
	     * Checks if a map value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf MapCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
	     * Sets the map `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf MapCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the map cache instance.
	     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
	MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*//**
	     *
	     * Creates an array cache object to store unique values.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [values] The values to cache.
	     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
	     * Adds `value` to the array cache.
	     *
	     * @private
	     * @name add
	     * @memberOf SetCache
	     * @alias push
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache instance.
	     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
	     * Checks if `value` is in the array cache.
	     *
	     * @private
	     * @name has
	     * @memberOf SetCache
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `true` if `value` is found, else `false`.
	     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
	SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*//**
	     * Creates a stack cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
	     * Removes all key-value entries from the stack.
	     *
	     * @private
	     * @name clear
	     * @memberOf Stack
	     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
	     * Removes `key` and its value from the stack.
	     *
	     * @private
	     * @name delete
	     * @memberOf Stack
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
	     * Gets the stack value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Stack
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */function stackGet(key){return this.__data__.get(key);}/**
	     * Checks if a stack value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Stack
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */function stackHas(key){return this.__data__.has(key);}/**
	     * Sets the stack `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Stack
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the stack cache instance.
	     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
	Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*//**
	     * Creates an array of the enumerable property names of the array-like `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @param {boolean} inherited Specify returning inherited property names.
	     * @returns {Array} Returns the array of property names.
	     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
	key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
	isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
	isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
	isIndex(key,length)))){result.push(key);}}return result;}/**
	     * A specialized version of `_.sample` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @returns {*} Returns the random element.
	     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined;}/**
	     * A specialized version of `_.sampleSize` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
	     * A specialized version of `_.shuffle` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
	     * This function is like `assignValue` except that it doesn't assign
	     * `undefined` values.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
	     * Assigns `value` to `key` of `object` if the existing value is not equivalent
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
	     * Gets the index at which the `key` is found in `array` of key-value pairs.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {*} key The key to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
	     * Aggregates elements of `collection` on `accumulator` with keys transformed
	     * by `iteratee` and values set by `setter`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform keys.
	     * @param {Object} accumulator The initial aggregated object.
	     * @returns {Function} Returns `accumulator`.
	     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
	     * The base implementation of `_.assign` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
	     * The base implementation of `_.assignIn` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
	     * The base implementation of `assignValue` and `assignMergeValue` without
	     * value checks.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
	     * The base implementation of `_.at` without support for individual paths.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Array} Returns the picked elements.
	     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined:get(object,paths[index]);}return result;}/**
	     * The base implementation of `_.clamp` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
	     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	     * traversed objects.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Deep clone
	     *  2 - Flatten inherited properties
	     *  4 - Clone symbols
	     * @param {Function} [customizer] The function to customize cloning.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The parent object of `value`.
	     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	     * @returns {*} Returns the cloned value.
	     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,baseClone,isDeep);}}// Check for circular references and return its corresponding clone.
	stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
	assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
	     * The base implementation of `_.conforms` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
	     * The base implementation of `_.conformsTo` which accepts `props` to check.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**
	     * The base implementation of `_.delay` and `_.defer` which accepts `args`
	     * to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Array} args The arguments to provide to `func`.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
	     * The base implementation of methods like `_.difference` without support
	     * for excluding multiple arrays or iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
	     * The base implementation of `_.forEach` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */var baseEach=createBaseEach(baseForOwn);/**
	     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
	     * The base implementation of `_.every` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
	     * The base implementation of methods like `_.max` and `_.min` which accepts a
	     * `comparator` to determine the extremum value.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The iteratee invoked per iteration.
	     * @param {Function} comparator The comparator used to compare values.
	     * @returns {*} Returns the extremum value.
	     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
	     * The base implementation of `_.filter` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
	     * The base implementation of `_.flatten` with support for restricting flattening.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {number} depth The maximum recursion depth.
	     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
	baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
	     * The base implementation of `baseForOwn` which iterates over `object`
	     * properties returned by `keysFunc` and invokes `iteratee` for each property.
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */var baseFor=createBaseFor();/**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */var baseForRight=createBaseFor(true);/**
	     * The base implementation of `_.forOwn` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
	     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from `props`.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the function names.
	     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
	     * The base implementation of `_.get` without support for default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @returns {*} Returns the resolved value.
	     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
	     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @param {Function} symbolsFunc The function to get the symbols of `object`.
	     * @returns {Array} Returns the array of property names and symbols.
	     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
	     * The base implementation of `getTag` without fallbacks for buggy environments.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
	     * The base implementation of `_.gt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     */function baseGt(value,other){return value>other;}/**
	     * The base implementation of `_.has` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
	     * The base implementation of `_.hasIn` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
	     * The base implementation of `_.inRange` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to check.
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
	     * The base implementation of methods like `_.intersection`, without support
	     * for iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of shared values.
	     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
	     * The base implementation of `_.invert` and `_.invertBy` which inverts
	     * `object` with values transformed by `iteratee` and set by `setter`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform values.
	     * @param {Object} accumulator The initial inverted object.
	     * @returns {Function} Returns `accumulator`.
	     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
	     * The base implementation of `_.invoke` without support for individual
	     * method arguments.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined:apply(func,object,args);}/**
	     * The base implementation of `_.isArguments`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
	     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
	     * The base implementation of `_.isDate` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
	     * The base implementation of `_.isEqual` which supports partial comparisons
	     * and tracks traversed objects.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Unordered comparison
	     *  2 - Partial comparison
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
	     * The base implementation of `_.isMap` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
	     * The base implementation of `_.isMatch` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Array} matchData The property names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
	     * The base implementation of `_.isNative` without bad shim checks.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
	     * The base implementation of `_.isRegExp` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
	     * The base implementation of `_.isSet` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
	     * The base implementation of `_.isTypedArray` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
	     * The base implementation of `_.iteratee`.
	     *
	     * @private
	     * @param {*} [value=_.identity] The value to convert to an iteratee.
	     * @returns {Function} Returns the iteratee.
	     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	if(typeof value=='function'){return value;}if(value==null){return identity;}if((typeof value==='undefined'?'undefined':_typeof(value))=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
	     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
	     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
	     * The base implementation of `_.lt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     */function baseLt(value,other){return value<other;}/**
	     * The base implementation of `_.map` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
	     * The base implementation of `_.matches` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
	     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
	     * The base implementation of `_.merge` without support for multiple sources.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){if(isObject(srcValue)){stack||(stack=new Stack());baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(object[key],srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=object[key],srcValue=source[key],stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||srcIndex&&isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
	stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
	     * The base implementation of `_.nth` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {number} n The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
	     * The base implementation of `_.orderBy` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {string[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */function baseOrderBy(collection,iteratees,orders){var index=-1;iteratees=arrayMap(iteratees.length?iteratees:[identity],baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
	     * The base implementation of `_.pick` without support for individual
	     * property identifiers.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Object} Returns the new object.
	     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
	     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @param {Function} predicate The function invoked per property.
	     * @returns {Object} Returns the new object.
	     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
	     * The base implementation of `_.pullAllBy` without support for iteratee
	     * shorthands.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
	     * The base implementation of `_.pullAt` without support for individual
	     * indexes or capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}/**
	     * The base implementation of `_.random` without support for returning
	     * floating-point numbers.
	     *
	     * @private
	     * @param {number} lower The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the random number.
	     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
	     * The base implementation of `_.range` and `_.rangeRight` which doesn't
	     * coerce arguments.
	     *
	     * @private
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} step The value to increment or decrement by.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the range of numbers.
	     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
	     * The base implementation of `_.repeat` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {string} string The string to repeat.
	     * @param {number} n The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
	// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
	     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
	     * The base implementation of `_.sample`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     */function baseSample(collection){return arraySample(values(collection));}/**
	     * The base implementation of `_.sampleSize` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
	     * The base implementation of `_.set`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
	     * The base implementation of `setData` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
	     * The base implementation of `setToString` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
	     * The base implementation of `_.shuffle`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
	     * The base implementation of `_.some` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
	     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
	     * performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
	     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
	     * which invokes `iteratee` for `value` and each element of `array` to compute
	     * their sort ranking. The iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The iteratee invoked per element.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */function baseSortedIndexBy(array,value,iteratee,retHighest){value=iteratee(value);var low=0,high=array==null?0:array.length,valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
	     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
	     * support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
	     * The base implementation of `_.toNumber` which doesn't ensure correct
	     * conversions of binary, hexadecimal, or octal string values.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
	     * The base implementation of `_.toString` which doesn't convert nullish
	     * values to empty strings.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {string} Returns the string.
	     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
	if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
	return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
	     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
	     * The base implementation of `_.unset`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The property path to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
	     * The base implementation of `_.update`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to update.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
	     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
	     * without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to perform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
	     * The base implementation of methods like `_.xor`, without support for
	     * iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of values.
	     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
	     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
	     *
	     * @private
	     * @param {Array} props The property identifiers.
	     * @param {Array} values The property values.
	     * @param {Function} assignFunc The function to assign values.
	     * @returns {Object} Returns the new object.
	     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
	     * Casts `value` to an empty array if it's not an array like object.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array|Object} Returns the cast array-like object.
	     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
	     * Casts `value` to `identity` if it's not a function.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Function} Returns cast function.
	     */function castFunction(value){return typeof value=='function'?value:identity;}/**
	     * Casts `value` to a path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {Array} Returns the cast property path array.
	     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
	     * A `baseRest` alias which can be replaced with `identity` by module
	     * replacement plugins.
	     *
	     * @private
	     * @type {Function}
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */var castRest=baseRest;/**
	     * Casts `array` to a slice if it's needed.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {number} start The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the cast slice.
	     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
	     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
	     *
	     * @private
	     * @param {number|Object} id The timer id or timeout object of the timer to clear.
	     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
	     * Creates a clone of  `buffer`.
	     *
	     * @private
	     * @param {Buffer} buffer The buffer to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Buffer} Returns the cloned buffer.
	     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
	     * Creates a clone of `arrayBuffer`.
	     *
	     * @private
	     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
	     * Creates a clone of `dataView`.
	     *
	     * @private
	     * @param {Object} dataView The data view to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned data view.
	     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
	     * Creates a clone of `map`.
	     *
	     * @private
	     * @param {Object} map The map to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned map.
	     */function cloneMap(map,isDeep,cloneFunc){var array=isDeep?cloneFunc(mapToArray(map),CLONE_DEEP_FLAG):mapToArray(map);return arrayReduce(array,addMapEntry,new map.constructor());}/**
	     * Creates a clone of `regexp`.
	     *
	     * @private
	     * @param {Object} regexp The regexp to clone.
	     * @returns {Object} Returns the cloned regexp.
	     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
	     * Creates a clone of `set`.
	     *
	     * @private
	     * @param {Object} set The set to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned set.
	     */function cloneSet(set,isDeep,cloneFunc){var array=isDeep?cloneFunc(setToArray(set),CLONE_DEEP_FLAG):setToArray(set);return arrayReduce(array,addSetEntry,new set.constructor());}/**
	     * Creates a clone of the `symbol` object.
	     *
	     * @private
	     * @param {Object} symbol The symbol object to clone.
	     * @returns {Object} Returns the cloned symbol object.
	     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
	     * Creates a clone of `typedArray`.
	     *
	     * @private
	     * @param {Object} typedArray The typed array to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned typed array.
	     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
	     * Compares values to sort them in ascending order.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {number} Returns the sort order indicator for `value`.
	     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
	     * Used by `_.orderBy` to compare multiple properties of a value to another
	     * and stable sort them.
	     *
	     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	     * specify an order of "desc" for descending or "asc" for ascending sort order
	     * of corresponding values.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {boolean[]|string[]} orders The order to sort by for each property.
	     * @returns {number} Returns the sort order indicator for `object`.
	     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	// that causes it, under certain circumstances, to provide the same value for
	// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	// for more details.
	//
	// This also ensures a stable sort in V8 and other engines.
	// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	return object.index-other.index;}/**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property identifiers to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @param {Function} [customizer] The function to customize copied values.
	     * @returns {Object} Returns `object`.
	     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
	     * Copies own symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
	     * Copies own and inherited symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
	     * Creates a function like `_.groupBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} [initializer] The accumulator object initializer.
	     * @returns {Function} Returns the new aggregator function.
	     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
	     * Creates a function like `_.assign`.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
	     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
	     * Creates a function that wraps `func` to invoke it with the optional `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
	     * Creates a function like `_.lowerFirst`.
	     *
	     * @private
	     * @param {string} methodName The name of the `String` case method to use.
	     * @returns {Function} Returns the new case function.
	     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
	     * Creates a function like `_.camelCase`.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
	// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	// for more details.
	var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
	// See https://es5.github.io/#x13.2.2 for more details.
	return isObject(result)?result:thisBinding;};}/**
	     * Creates a function that wraps `func` to enable currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {number} arity The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} findIndexFunc The function to find the collection index.
	     * @returns {Function} Returns the new find function.
	     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function predicate(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
	     * Creates a function that wraps `func` to invoke it with optional `this`
	     * binding of `thisArg`, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided
	     *  to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
	     * Creates a function like `_.invertBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} toIteratee The function to resolve iteratees.
	     * @returns {Function} Returns the new inverter function.
	     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
	     * Creates a function that performs a mathematical operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @param {number} [defaultValue] The value used for `undefined` arguments.
	     * @returns {Function} Returns the new mathematical operation function.
	     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
	     * Creates a function like `_.over`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over iteratees.
	     * @returns {Function} Returns the new over function.
	     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
	     * Creates the padding for `string` based on `length`. The `chars` string
	     * is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {number} length The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padding for `string`.
	     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
	     * Creates a function that wraps `func` to invoke it with the `this` binding
	     * of `thisArg` and `partials` prepended to the arguments it receives.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to
	     *  the new function.
	     * @returns {Function} Returns the new wrapped function.
	     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
	     * Creates a `_.range` or `_.rangeRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new range function.
	     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
	start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
	     * Creates a function that performs a relational operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @returns {Function} Returns the new relational operation function.
	     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
	     * Creates a function that wraps `func` to continue currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {Function} wrapFunc The function to create the `func` wrapper.
	     * @param {*} placeholder The placeholder value.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
	     * Creates a function like `_.round`.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision){// Shift with exponential notation to avoid floating-point issues.
	// See [MDN](https://mdn.io/round#Examples) for more details.
	var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
	     * Creates a set object of `values`.
	     *
	     * @private
	     * @param {Array} values The values to add to the set.
	     * @returns {Object} Returns the new set.
	     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
	     * Creates a `_.toPairs` or `_.toPairsIn` function.
	     *
	     * @private
	     * @param {Function} keysFunc The function to get the keys of a given object.
	     * @returns {Function} Returns the new pairs function.
	     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags.
	     *    1 - `_.bind`
	     *    2 - `_.bindKey`
	     *    4 - `_.curry` or `_.curryRight` of a bound function
	     *    8 - `_.curry`
	     *   16 - `_.curryRight`
	     *   32 - `_.partial`
	     *   64 - `_.partialRight`
	     *  128 - `_.rearg`
	     *  256 - `_.ary`
	     *  512 - `_.flip`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
	     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
	     * of source objects to the destination object for all destination properties
	     * that resolve to `undefined`.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to assign.
	     * @param {Object} object The parent object of `objValue`.
	     * @returns {*} Returns the value to assign.
	     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
	     * objects into destination objects that are passed thru.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to merge.
	     * @param {Object} object The parent object of `objValue`.
	     * @param {Object} source The parent object of `srcValue`.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     * @returns {*} Returns the value to assign.
	     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
	stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
	     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
	     * objects.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {string} key The key of the property to inspect.
	     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
	     */function customOmitClone(value){return isPlainObject(value)?undefined:value;}/**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `array` and `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Assume cyclic values are equal.
	var stacked=stack.get(array);if(stacked&&stack.get(other)){return stacked==other;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
	while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
	if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
	// Invalid dates are coerced to `NaN`.
	return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
	// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	// for more details.
	return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
	var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
	stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Assume cyclic values are equal.
	var stacked=stack.get(object);if(stacked&&stack.get(other)){return stacked==other;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
	if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
	if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
	     * A specialized version of `baseRest` which flattens the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}/**
	     * Creates an array of own enumerable property names and symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
	     * Creates an array of own and inherited enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
	     * Gets the argument placeholder value for `func`.
	     *
	     * @private
	     * @param {Function} func The function to inspect.
	     * @returns {*} Returns the placeholder value.
	     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
	     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
	     * this function returns the custom method, otherwise it returns `baseIteratee`.
	     * If arguments are provided, the chosen function is invoked with them and
	     * its result is returned.
	     *
	     * @private
	     * @param {*} [value] The value to convert to an iteratee.
	     * @param {number} [arity] The arity of the created iteratee.
	     * @returns {Function} Returns the chosen function or its result.
	     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
	     * Gets the data for `map`.
	     *
	     * @private
	     * @param {Object} map The map to query.
	     * @param {string} key The reference key.
	     * @returns {*} Returns the map data.
	     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
	     * Gets the property names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
	     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the raw `toStringTag`.
	     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
	     * Creates an array of the own enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
	     * Creates an array of the own and inherited enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
	     * Gets the `toStringTag` of `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
	     * Extracts wrapper details from the `source` body comment.
	     *
	     * @private
	     * @param {string} source The source to inspect.
	     * @returns {Array} Returns the wrapper details.
	     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
	     * Checks if `path` exists on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @param {Function} hasFunc The function to check properties.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */function initCloneArray(array){var length=array.length,result=array.constructor(length);// Add properties assigned by `RegExp#exec`.
	if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */function initCloneByTag(object,tag,cloneFunc,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return cloneMap(object,isDeep,cloneFunc);case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return cloneSet(object,isDeep,cloneFunc);case symbolTag:return cloneSymbol(object);}}/**
	     * Inserts wrapper `details` in a comment at the top of the `source` body.
	     *
	     * @private
	     * @param {string} source The source to modify.
	     * @returns {Array} details The details to insert.
	     * @returns {string} Returns the modified source.
	     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
	     * Checks if `value` is a flattenable `arguments` object or array.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */function isIndex(value,length){length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(typeof value=='number'||reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
	     * Checks if the given arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	     *  else `false`.
	     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index==='undefined'?'undefined':_typeof(index);if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value==='undefined'?'undefined':_typeof(value);if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
	     * Checks if `value` is suitable for use as unique object key.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	     */function isKeyable(value){var type=typeof value==='undefined'?'undefined':_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	     *  else `false`.
	     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
	     * Checks if `func` has its source masked.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
	     * Checks if `func` is capable of being masked.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
	     */var isMaskable=coreJsData?isFunction:stubFalse;/**
	     * Checks if `value` is likely a prototype object.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
	     * A specialized version of `matchesProperty` for source values suitable
	     * for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
	     * A specialized version of `_.memoize` which clears the memoized function's
	     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	     *
	     * @private
	     * @param {Function} func The function to have its output memoized.
	     * @returns {Function} Returns the new memoized function.
	     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers used to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and
	     * `_.rearg` modify function arguments, making the order in which they are
	     * executed important, preventing the merging of metadata. However, we make
	     * an exception for a safe combined case where curried functions have `_.ary`
	     * and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
	if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
	if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
	newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
	var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
	value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
	value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
	if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
	if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
	data[0]=source[0];data[1]=newBitmask;return data;}/**
	     * This function is like
	     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * except that it includes inherited enumerable properties.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
	     * Converts `value` to a string using `Object.prototype.toString`.
	     *
	     * @private
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     */function objectToString(value){return nativeObjectToString.call(value);}/**
	     * A specialized version of `baseRest` which transforms the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @param {Function} transform The rest array transform.
	     * @returns {Function} Returns the new function.
	     */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
	     * Gets the parent value at `path` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path to get the parent value of.
	     * @returns {*} Returns the parent value.
	     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity
	     * function to avoid garbage collection pauses in V8. See
	     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */var setData=shortOut(baseSetData);/**
	     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
	     * Sets the `toString` method of `func` to return `string`.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */var setToString=shortOut(baseSetToString);/**
	     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
	     * with wrapper details in a comment at the top of the source body.
	     *
	     * @private
	     * @param {Function} wrapper The function to modify.
	     * @param {Function} reference The reference function.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Function} Returns `wrapper`.
	     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
	     * Creates a function that'll short out and invoke `identity` instead
	     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	     * milliseconds.
	     *
	     * @private
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new shortable function.
	     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
	     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @param {number} [size=array.length] The size of `array`.
	     * @returns {Array} Returns `array`.
	     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
	     * Converts `string` to a property path array.
	     *
	     * @private
	     * @param {string} string The string to convert.
	     * @returns {Array} Returns the property path array.
	     */var stringToPath=memoizeCapped(function(string){var result=[];if(reLeadingDot.test(string)){result.push('');}string.replace(rePropName,function(match,number,quote,string){result.push(quote?string.replace(reEscapeChar,'$1'):number||match);});return result;});/**
	     * Converts `value` to a string key if it's not a string or symbol.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {string|symbol} Returns the key.
	     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
	     * Converts `func` to its source code.
	     *
	     * @private
	     * @param {Function} func The function to convert.
	     * @returns {string} Returns the source code.
	     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
	     * Updates wrapper `details` based on `bitmask` flags.
	     *
	     * @private
	     * @returns {Array} details The details to modify.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Array} Returns `details`.
	     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*//**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `array` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the new array of chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
	     * Creates a new array concatenating `array` with any additional arrays
	     * and/or values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to concatenate.
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var other = _.concat(array, 2, [3], [[4]]);
	     *
	     * console.log(other);
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */function concat(){var length=arguments.length;if(!length){return[];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
	     * Creates an array of `array` values not included in the other given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * **Note:** Unlike `_.pullAll`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.without, _.xor
	     * @example
	     *
	     * _.difference([2, 1], [2, 3]);
	     * // => [1]
	     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
	     * This method is like `_.difference` except that it accepts `iteratee` which
	     * is invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
	     * This method is like `_.difference` except that it accepts `comparator`
	     * which is invoked to compare elements of `array` to `values`. The order and
	     * references of result values are determined by the first array. The comparator
	     * is invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     *
	     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }]
	     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.dropRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropRightWhile(users, ['active', false]);
	     * // => objects for ['barney']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropRightWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.dropWhile(users, function(o) { return !o.active; });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropWhile(users, ['active', false]);
	     * // => objects for ['pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8, 10], '*', 1, 3);
	     * // => [4, '*', '*', 10]
	     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(o) { return o.user == 'barney'; });
	     * // => 0
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findIndex(users, ['active', false]);
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findIndex(users, 'active');
	     * // => 2
	     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
	     * // => 2
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastIndex(users, ['active', false]);
	     * // => 2
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
	     * Flattens `array` a single level deep.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, [3, [4]], 5]
	     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
	     * Recursively flattens `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, 3, 4, 5]
	     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
	     * Recursively flatten `array` up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * var array = [1, [2, [3, [4]], 5]];
	     *
	     * _.flattenDepth(array, 1);
	     * // => [1, 2, [3, [4]], 5]
	     *
	     * _.flattenDepth(array, 2);
	     * // => [1, 2, 3, [4], 5]
	     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
	     * The inverse of `_.toPairs`; this method returns an object composed
	     * from key-value `pairs`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} pairs The key-value pairs.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.fromPairs([['a', 1], ['b', 2]]);
	     * // => { 'a': 1, 'b': 2 }
	     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias first
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.head([1, 2, 3]);
	     * // => 1
	     *
	     * _.head([]);
	     * // => undefined
	     */function head(array){return array&&array.length?array[0]:undefined;}/**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it's used as the
	     * offset from the end of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // Search from the `fromIndex`.
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
	     * Creates an array of unique values that are included in all given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersection([2, 1], [2, 3]);
	     * // => [2]
	     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
	     * This method is like `_.intersection` except that it accepts `iteratee`
	     * which is invoked for each element of each `arrays` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [2.1]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }]
	     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
	     * This method is like `_.intersection` except that it accepts `comparator`
	     * which is invoked to compare elements of `arrays`. The order and references
	     * of result values are determined by the first array. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.intersectionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }]
	     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
	     * Converts all elements in `array` into a string separated by `separator`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to convert.
	     * @param {string} [separator=','] The element separator.
	     * @returns {string} Returns the joined string.
	     * @example
	     *
	     * _.join(['a', 'b', 'c'], '~');
	     * // => 'a~b~c'
	     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // Search from the `fromIndex`.
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
	     * Gets the element at index `n` of `array`. If `n` is negative, the nth
	     * element from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.11.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=0] The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     *
	     * _.nth(array, 1);
	     * // => 'b'
	     *
	     * _.nth(array, -2);
	     * // => 'c';
	     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
	     * Removes all given values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
	     * to remove elements from an array by predicate.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pull(array, 'a', 'c');
	     * console.log(array);
	     * // => ['b', 'b']
	     */var pull=baseRest(pullAll);/**
	     * This method is like `_.pull` except that it accepts an array of values to remove.
	     *
	     * **Note:** Unlike `_.difference`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pullAll(array, ['a', 'c']);
	     * console.log(array);
	     * // => ['b', 'b']
	     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
	     * This method is like `_.pullAll` except that it accepts `iteratee` which is
	     * invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The iteratee is invoked with one argument: (value).
	     *
	     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
	     *
	     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
	     * console.log(array);
	     * // => [{ 'x': 2 }]
	     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
	     * This method is like `_.pullAll` except that it accepts `comparator` which
	     * is invoked to compare elements of `array` to `values`. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
	     *
	     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
	     * console.log(array);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
	     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
	     * Removes elements from `array` corresponding to `indexes` and returns an
	     * array of removed elements.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     * var pulled = _.pullAt(array, [1, 3]);
	     *
	     * console.log(array);
	     * // => ['a', 'c']
	     *
	     * console.log(pulled);
	     * // => ['b', 'd']
	     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is invoked
	     * with three arguments: (value, index, array).
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
	     * to pull elements from an array by value.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
	     * Reverses `array` so that the first element becomes the last, the second
	     * element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates `array` and is based on
	     * [`Array#reverse`](https://mdn.io/Array/reverse).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.reverse(array);
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of
	     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
	     * returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
	     * Uses a binary search to determine the lowest index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
	     * This method is like `_.sortedIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 0
	     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
	     * This method is like `_.indexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 1
	     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
	     * // => 4
	     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
	     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 1
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 1
	     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
	     * This method is like `_.lastIndexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 3
	     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
	     * This method is like `_.uniq` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniq([1, 1, 2]);
	     * // => [1, 2]
	     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
	     * This method is like `_.uniqBy` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
	     * // => [1.1, 2.3]
	     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.tail([1, 2, 3]);
	     * // => [2, 3]
	     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.takeRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeRightWhile(users, ['active', false]);
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeRightWhile(users, 'active');
	     * // => []
	     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.takeWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeWhile(users, ['active', false]);
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeWhile(users, 'active');
	     * // => []
	     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
	     * Creates an array of unique values, in order, from all given arrays using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([2], [1, 2]);
	     * // => [2, 1]
	     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
	     * This method is like `_.union` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which uniqueness is computed. Result values are chosen from the first
	     * array in which the value occurs. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
	     * This method is like `_.union` except that it accepts `comparator` which
	     * is invoked to compare elements of `arrays`. Result values are chosen from
	     * the first array in which the value occurs. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.unionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurrence of each element
	     * is kept. The order of result values is determined by the order they occur
	     * in the array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
	     * This method is like `_.uniq` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * uniqueness is computed. The order of result values is determined by the
	     * order they occur in the array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
	     * This method is like `_.uniq` except that it accepts `comparator` which
	     * is invoked to compare elements of `array`. The order of result values is
	     * determined by the order they occur in the array.The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.uniqWith(objects, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
	     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined;return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.2.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['a', 'b'], [1, 2], [true, false]]
	     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
	     * This method is like `_.unzip` except that it accepts `iteratee` to specify
	     * how regrouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  regrouped values.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
	     * Creates an array excluding all given values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.pull`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.xor
	     * @example
	     *
	     * _.without([2, 1, 2, 3], 1, 2);
	     * // => [3]
	     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
	     * Creates an array of unique values that is the
	     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the given arrays. The order of result values is determined by the order
	     * they occur in the arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.without
	     * @example
	     *
	     * _.xor([2, 1], [2, 3]);
	     * // => [1, 3]
	     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
	     * This method is like `_.xor` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which by which they're compared. The order of result values is determined
	     * by the order they occur in the arrays. The iteratee is invoked with one
	     * argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2, 3.4]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
	     * This method is like `_.xor` except that it accepts `comparator` which is
	     * invoked to compare elements of `arrays`. The order of result values is
	     * determined by the order they occur in the arrays. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.xorWith(objects, others, _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
	     * Creates an array of grouped elements, the first of which contains the
	     * first elements of the given arrays, the second of which contains the
	     * second elements of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     */var zip=baseRest(unzip);/**
	     * This method is like `_.fromPairs` except that it accepts two arrays,
	     * one of property identifiers and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.4.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject(['a', 'b'], [1, 2]);
	     * // => { 'a': 1, 'b': 2 }
	     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
	     * This method is like `_.zipObject` except that it supports property paths.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
	     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
	     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
	     * This method is like `_.zip` except that it accepts `iteratee` to specify
	     * how grouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  grouped values.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
	     *   return a + b + c;
	     * });
	     * // => [111, 222]
	     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*//**
	     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
	     * chain sequences enabled. The result of such sequences must be unwrapped
	     * with `_#value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Seq
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _
	     *   .chain(users)
	     *   .sortBy('age')
	     *   .map(function(o) {
	     *     return o.user + ' is ' + o.age;
	     *   })
	     *   .head()
	     *   .value();
	     * // => 'pebbles is 1'
	     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
	     * This method invokes `interceptor` and returns `value`. The interceptor
	     * is invoked with one argument; (value). The purpose of this method is to
	     * "tap into" a method chain sequence in order to modify intermediate results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    // Mutate input array.
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */function tap(value,interceptor){interceptor(value);return value;}/**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     * The purpose of this method is to "pass thru" values replacing intermediate
	     * results in a method chain sequence.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */function thru(value,interceptor){return interceptor(value);}/**
	     * This method is the wrapper version of `_.at`.
	     *
	     * @name at
	     * @memberOf _
	     * @since 1.0.0
	     * @category Seq
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _(object).at(['a[0].b.c', 'a[1]']).value();
	     * // => [3, 4]
	     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function interceptor(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
	     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
	     *
	     * @name chain
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // A sequence without explicit chaining.
	     * _(users).head();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // A sequence with explicit chaining.
	     * _(users)
	     *   .chain()
	     *   .head()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */function wrapperChain(){return chain(this);}/**
	     * Executes the chain sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
	     * Gets the next value on a wrapped object following the
	     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
	     *
	     * @name next
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the next iterator value.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 1 }
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 2 }
	     *
	     * wrapped.next();
	     * // => { 'done': true, 'value': undefined }
	     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
	     * Enables the wrapper to be iterable.
	     *
	     * @name Symbol.iterator
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped[Symbol.iterator]() === wrapped;
	     * // => true
	     *
	     * Array.from(wrapped);
	     * // => [1, 2]
	     */function wrapperToIterator(){return this;}/**
	     * Creates a clone of the chain sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @param {*} value The value to plant.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2]).map(square);
	     * var other = wrapped.plant([3, 4]);
	     *
	     * other.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
	     * This method is the wrapper version of `_.reverse`.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
	     * Executes the chain sequence to resolve the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @since 0.1.0
	     * @alias toJSON, valueOf
	     * @category Seq
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*//**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the number of times the key was returned by `iteratee`. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': 1, '6': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else{baseAssignValue(result,key,1);}});/**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * Iteration is stopped once `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * **Note:** This method returns `true` for
	     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
	     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
	     * elements of empty collections.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.every(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.every(users, 'active');
	     * // => false
	     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * **Note:** Unlike `_.remove`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.reject
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, { 'age': 36, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.filter(users, 'active');
	     * // => objects for ['barney']
	     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.find(users, function(o) { return o.age < 40; });
	     * // => object for 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.find(users, { 'age': 1, 'active': true });
	     * // => object for 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.find(users, ['active', false]);
	     * // => object for 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.find(users, 'active');
	     * // => object for 'barney'
	     */var find=createFind(findIndex);/**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=collection.length-1] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */var findLast=createFind(findLastIndex);/**
	     * Creates a flattened array of values by running each element in `collection`
	     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [n, n];
	     * }
	     *
	     * _.flatMap([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDeep([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDepth([1, 2], duplicate, 2);
	     * // => [[1, 1], [2, 2]]
	     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
	     * Iterates over elements of `collection` and invokes `iteratee` for each element.
	     * The iteratee is invoked with three arguments: (value, index|key, collection).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length"
	     * property are iterated like arrays. To avoid this behavior use `_.forIn`
	     * or `_.forOwn` for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias each
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEachRight
	     * @example
	     *
	     * _.forEach([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `1` then `2`.
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEach
	     * @example
	     *
	     * _.forEachRight([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `2` then `1`.
	     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The order of grouped values
	     * is determined by the order they occur in `collection`. The corresponding
	     * value of each key is an array of elements responsible for generating the
	     * key. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': [4.2], '6': [6.1, 6.3] }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});/**
	     * Checks if `value` is in `collection`. If `collection` is a string, it's
	     * checked for a substring of `value`, otherwise
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * is used for equality comparisons. If `fromIndex` is negative, it's used as
	     * the offset from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {boolean} Returns `true` if `value` is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'a': 1, 'b': 2 }, 1);
	     * // => true
	     *
	     * _.includes('abcd', 'bc');
	     * // => true
	     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `path` is a function, it's invoked
	     * for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke each method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invokeMap([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the last element responsible for generating the key. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var array = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.keyBy(array, function(o) {
	     *   return String.fromCharCode(o.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.keyBy(array, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
	     * Creates an array of values by running each element in `collection` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * _.map([4, 8], square);
	     * // => [16, 64]
	     *
	     * _.map({ 'a': 4, 'b': 8 }, square);
	     * // => [16, 64] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
	     * This method is like `_.sortBy` except that it allows specifying the sort
	     * orders of the iteratees to sort by. If `orders` is unspecified, all values
	     * are sorted in ascending order. Otherwise, specify an order of "desc" for
	     * descending or "asc" for ascending sort order of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @param {string[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // Sort by `user` in ascending order and by `age` in descending order.
	     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, the second of which
	     * contains elements `predicate` returns falsey for. The predicate is
	     * invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.partition(users, function(o) { return o.active; });
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.partition(users, { 'age': 1, 'active': false });
	     * // => objects for [['pebbles'], ['barney', 'fred']]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.partition(users, ['active', false]);
	     * // => objects for [['barney', 'pebbles'], ['fred']]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.partition(users, 'active');
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` thru `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not given, the first element of `collection` is used as the initial
	     * value. The iteratee is invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	     * and `sortBy`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduceRight
	     * @example
	     *
	     * _.reduce([1, 2], function(sum, n) {
	     *   return sum + n;
	     * }, 0);
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     *   return result;
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduce
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.filter
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * _.reject(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.reject(users, { 'age': 40, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.reject(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.reject(users, 'active');
	     * // => objects for ['barney']
	     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
	     * Gets a random element from `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
	     * Gets `n` random elements at unique keys from `collection` up to the
	     * size of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} [n=1] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the random elements.
	     * @example
	     *
	     * _.sampleSize([1, 2, 3], 2);
	     * // => [3, 1]
	     *
	     * _.sampleSize([1, 2, 3], 4);
	     * // => [2, 3, 1]
	     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable string keyed properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the collection size.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * Iteration is stopped once `predicate` returns truthy. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.some(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.some(users, 'active');
	     * // => true
	     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection thru each iteratee. This method
	     * performs a stable sort, that is, it preserves the original sort order of
	     * equal elements. The iteratees are invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.sortBy(users, [function(o) { return o.user; }]);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     *
	     * _.sortBy(users, ['user', 'age']);
	     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
	     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*//**
	     * Gets the timestamp of the number of milliseconds that have elapsed since
	     * the Unix epoch (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Date
	     * @returns {number} Returns the timestamp.
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => Logs the number of milliseconds it took for the deferred invocation.
	     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*//**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it's called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => Logs 'done saving!' after the two async saves have completed.
	     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
	     * Creates a function that invokes `func`, with up to `n` arguments,
	     * ignoring any additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it's called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery(element).on('click', _.before(5, addContactToList));
	     * // => Allows adding up to 4 contacts to the list.
	     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and `partials` prepended to the arguments it receives.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * function greet(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * }
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
	     * Creates a function that invokes the method at `object[key]` with `partials`
	     * prepended to the arguments it receives.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist. See
	     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Function
	     * @param {Object} object The object to invoke the method on.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
	     * Creates a function that accepts arguments of `func` and either invokes
	     * `func` returning its result, if at least `arity` number of arguments have
	     * been provided, or returns a function that accepts the remaining `func`
	     * arguments, and so on. The arity of `func` may be specified if `func.length`
	     * is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed `func` invocations and a `flush` method to immediately invoke them.
	     * Provide `options` to indicate whether `func` should be invoked on the
	     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	     * with the last arguments provided to the debounced function. Subsequent
	     * calls to the debounced function return the result of the last `func`
	     * invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the debounced function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=false]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {number} [options.maxWait]
	     *  The maximum time `func` is allowed to be delayed before it's invoked.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // Avoid costly calculations while the window size is in flux.
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	     * jQuery(element).on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', debounced);
	     *
	     * // Cancel the trailing debounced invocation.
	     * jQuery(window).on('popstate', debounced.cancel);
	     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
	lastInvokeTime=time;// Start the timer for the trailing edge.
	timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
	return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,result=wait-timeSinceLastCall;return maxing?nativeMin(result,maxWait-timeSinceLastInvoke):result;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
	// trailing edge, the system time has gone backwards and we're treating
	// it as the trailing edge, or we've hit the `maxWait` limit.
	return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
	timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
	// debounced at least once.
	if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
	timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // => Logs 'deferred' after one millisecond.
	     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => Logs 'later' after one second.
	     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
	     * Creates a function that invokes `func` with arguments reversed.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to flip arguments for.
	     * @returns {Function} Returns the new flipped function.
	     * @example
	     *
	     * var flipped = _.flip(function() {
	     *   return _.toArray(arguments);
	     * });
	     *
	     * flipped('a', 'b', 'c', 'd');
	     * // => ['d', 'c', 'b', 'a']
	     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided, it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is used as the map cache key. The `func`
	     * is invoked with the `this` binding of the memoized function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the
	     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoized function.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     * var other = { 'c': 3, 'd': 4 };
	     *
	     * var values = _.memoize(_.values);
	     * values(object);
	     * // => [1, 2]
	     *
	     * values(other);
	     * // => [3, 4]
	     *
	     * object.a = 2;
	     * values(object);
	     * // => [1, 2]
	     *
	     * // Modify the result cache.
	     * values.cache.set(object, ['a', 'b']);
	     * values(object);
	     * // => ['a', 'b']
	     *
	     * // Replace `_.memoize.Cache`.
	     * _.memoize.Cache = WeakMap;
	     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function memoized(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
	memoize.Cache=MapCache;/**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new negated function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first invocation. The `func` is
	     * invoked with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // => `createApplication` is invoked once
	     */function once(func){return before(2,func);}/**
	     * Creates a function that invokes `func` with its arguments transformed.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms=[_.identity]]
	     *  The argument transforms.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var func = _.overArgs(function(x, y) {
	     *   return [x, y];
	     * }, [square, doubled]);
	     *
	     * func(9, 3);
	     * // => [81, 6]
	     *
	     * func(10, 5);
	     * // => [100, 10]
	     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
	     * Creates a function that invokes `func` with `partials` prepended to the
	     * arguments it receives. This method is like `_.bind` except it does **not**
	     * alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.2.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // Partially applied with placeholders.
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined,partials,holders);});/**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to the arguments it receives.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // Partially applied with placeholders.
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified `indexes` where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, [2, 0, 1]);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});/**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as
	     * an array.
	     *
	     * **Note:** This method is based on the
	     * [rest parameter](https://mdn.io/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.rest(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * create function and an array of arguments much like
	     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
	     *
	     * **Note:** This method is based on the
	     * [spread operator](https://mdn.io/spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @param {number} [start=0] The start position of the spread.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed `func` invocations and a `flush` method to
	     * immediately invoke them. Provide `options` to indicate whether `func`
	     * should be invoked on the leading and/or trailing edge of the `wait`
	     * timeout. The `func` is invoked with the last arguments provided to the
	     * throttled function. Subsequent calls to the throttled function return the
	     * result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the throttled function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=true]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // Avoid excessively updating the position while scrolling.
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	     * jQuery(element).on('click', throttled);
	     *
	     * // Cancel the trailing throttled invocation.
	     * jQuery(window).on('popstate', throttled.cancel);
	     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
	     * Creates a function that accepts up to one argument, ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.unary(parseInt));
	     * // => [6, 8, 10]
	     */function unary(func){return ary(func,1);}/**
	     * Creates a function that provides `value` to `wrapper` as its first
	     * argument. Any additional arguments provided to the function are appended
	     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
	     * binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} [wrapper=identity] The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*//**
	     * Casts `value` as an array if it's not one.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Lang
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast array.
	     * @example
	     *
	     * _.castArray(1);
	     * // => [1]
	     *
	     * _.castArray({ 'a': 1 });
	     * // => [{ 'a': 1 }]
	     *
	     * _.castArray('abc');
	     * // => ['abc']
	     *
	     * _.castArray(null);
	     * // => [null]
	     *
	     * _.castArray(undefined);
	     * // => [undefined]
	     *
	     * _.castArray();
	     * // => []
	     *
	     * var array = [1, 2, 3];
	     * console.log(_.castArray(array) === array);
	     * // => true
	     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
	     * Creates a shallow clone of `value`.
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	     * and supports cloning arrays, array buffers, booleans, date objects, maps,
	     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	     * arrays. The own enumerable properties of `arguments` objects are cloned
	     * as plain objects. An empty object is returned for uncloneable values such
	     * as error objects, functions, DOM nodes, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeep
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var shallow = _.clone(objects);
	     * console.log(shallow[0] === objects[0]);
	     * // => true
	     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
	     * This method is like `_.clone` except that it accepts `customizer` which
	     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
	     * cloning is handled by the method instead. The `customizer` is invoked with
	     * up to four arguments; (value [, index|key, object, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeepWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * }
	     *
	     * var el = _.cloneWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 0
	     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
	     * This method is like `_.clone` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.clone
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var deep = _.cloneDeep(objects);
	     * console.log(deep[0] === objects[0]);
	     * // => false
	     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
	     * This method is like `_.cloneWith` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.cloneWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * }
	     *
	     * var el = _.cloneDeepWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 20
	     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
	     * Checks if `object` conforms to `source` by invoking the predicate
	     * properties of `source` with the corresponding property values of `object`.
	     *
	     * **Note:** This method is equivalent to `_.conforms` when `source` is
	     * partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
	     * // => true
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
	     * // => false
	     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
	     * Performs a
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * comparison between two values to determine if they are equivalent.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.eq(object, object);
	     * // => true
	     *
	     * _.eq(object, other);
	     * // => false
	     *
	     * _.eq('a', 'a');
	     * // => true
	     *
	     * _.eq('a', Object('a'));
	     * // => false
	     *
	     * _.eq(NaN, NaN);
	     * // => true
	     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     * @see _.lt
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */var gt=createRelationalOperation(baseGt);/**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to
	     *  `other`, else `false`.
	     * @see _.lte
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
	     * Checks if `value` is likely an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(document.body.children);
	     * // => false
	     *
	     * _.isArray('abc');
	     * // => false
	     *
	     * _.isArray(_.noop);
	     * // => false
	     */var isArray=Array.isArray;/**
	     * Checks if `value` is classified as an `ArrayBuffer` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     * @example
	     *
	     * _.isArrayBuffer(new ArrayBuffer(2));
	     * // => true
	     *
	     * _.isArrayBuffer(new Array(2));
	     * // => false
	     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
	     * Checks if `value` is array-like. A value is considered array-like if it's
	     * not a function and has a `value.length` that's an integer greater than or
	     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     * @example
	     *
	     * _.isArrayLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLike(document.body.children);
	     * // => true
	     *
	     * _.isArrayLike('abc');
	     * // => true
	     *
	     * _.isArrayLike(_.noop);
	     * // => false
	     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
	     * This method is like `_.isArrayLike` except that it also checks if `value`
	     * is an object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array-like object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArrayLikeObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLikeObject(document.body.children);
	     * // => true
	     *
	     * _.isArrayLikeObject('abc');
	     * // => false
	     *
	     * _.isArrayLikeObject(_.noop);
	     * // => false
	     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
	     * Checks if `value` is a buffer.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	     * @example
	     *
	     * _.isBuffer(new Buffer(2));
	     * // => true
	     *
	     * _.isBuffer(new Uint8Array(2));
	     * // => false
	     */var isBuffer=nativeIsBuffer||stubFalse;/**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
	     * Checks if `value` is likely a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
	     * Checks if `value` is an empty object, collection, map, or set.
	     *
	     * Objects are considered empty if they have no own enumerable string keyed
	     * properties.
	     *
	     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	     * jQuery-like collections are considered empty if they have a `length` of `0`.
	     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent.
	     *
	     * **Note:** This method supports comparing arrays, array buffers, booleans,
	     * date objects, error objects, maps, numbers, `Object` objects, regexes,
	     * sets, strings, symbols, and typed arrays. `Object` objects are compared
	     * by their own, not inherited, enumerable properties. Functions and DOM
	     * nodes are compared by strict equality, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * object === other;
	     * // => false
	     */function isEqual(value,other){return baseIsEqual(value,other);}/**
	     * This method is like `_.isEqual` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with up to
	     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, othValue) {
	     *   if (isGreeting(objValue) && isGreeting(othValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqualWith(array, other, customizer);
	     * // => true
	     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,undefined,customizer):!!result;}/**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on
	     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(3);
	     * // => true
	     *
	     * _.isFinite(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     *
	     * _.isFinite('3');
	     * // => false
	     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
	// in Safari 9 which returns 'object' for typed arrays and other constructors.
	var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
	     * Checks if `value` is an integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
	     * @example
	     *
	     * _.isInteger(3);
	     * // => true
	     *
	     * _.isInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isInteger(Infinity);
	     * // => false
	     *
	     * _.isInteger('3');
	     * // => false
	     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     * @example
	     *
	     * _.isLength(3);
	     * // => true
	     *
	     * _.isLength(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isLength(Infinity);
	     * // => false
	     *
	     * _.isLength('3');
	     * // => false
	     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
	     * Checks if `value` is the
	     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(_.noop);
	     * // => true
	     *
	     * _.isObject(null);
	     * // => false
	     */function isObject(value){var type=typeof value==='undefined'?'undefined':_typeof(value);return value!=null&&(type=='object'||type=='function');}/**
	     * Checks if `value` is object-like. A value is object-like if it's not `null`
	     * and has a `typeof` result of "object".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	     * @example
	     *
	     * _.isObjectLike({});
	     * // => true
	     *
	     * _.isObjectLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isObjectLike(_.noop);
	     * // => false
	     *
	     * _.isObjectLike(null);
	     * // => false
	     */function isObjectLike(value){return value!=null&&(typeof value==='undefined'?'undefined':_typeof(value))=='object';}/**
	     * Checks if `value` is classified as a `Map` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     * @example
	     *
	     * _.isMap(new Map);
	     * // => true
	     *
	     * _.isMap(new WeakMap);
	     * // => false
	     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
	     * Performs a partial deep comparison between `object` and `source` to
	     * determine if `object` contains equivalent property values.
	     *
	     * **Note:** This method is equivalent to `_.matches` when `source` is
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.isMatch(object, { 'b': 2 });
	     * // => true
	     *
	     * _.isMatch(object, { 'b': 1 });
	     * // => false
	     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
	     * This method is like `_.isMatch` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with five
	     * arguments: (objValue, srcValue, index|key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatchWith(object, source, customizer);
	     * // => true
	     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is based on
	     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
	     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
	     * `undefined` and other non-number values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
	// Perform the `toStringTag` check first to avoid errors with some
	// ActiveX objects in IE.
	return isNumber(value)&&value!=+value;}/**
	     * Checks if `value` is a pristine native function.
	     *
	     * **Note:** This method can't reliably detect native functions in the presence
	     * of the core-js package because core-js circumvents this kind of detection.
	     * Despite multiple requests, the core-js maintainer has made it clear: any
	     * attempt to fix the detection will be obstructed. As a result, we're left
	     * with little choice but to throw an error. Unfortunately, this also affects
	     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
	     * which rely on core-js.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */function isNull(value){return value===null;}/**
	     * Checks if `value` is `null` or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	     * @example
	     *
	     * _.isNil(null);
	     * // => true
	     *
	     * _.isNil(void 0);
	     * // => true
	     *
	     * _.isNil(NaN);
	     * // => false
	     */function isNil(value){return value==null;}/**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
	     * classified as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
	     * @example
	     *
	     * _.isNumber(3);
	     * // => true
	     *
	     * _.isNumber(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isNumber(Infinity);
	     * // => true
	     *
	     * _.isNumber('3');
	     * // => false
	     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.8.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
	     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
	     * double precision number which isn't the result of a rounded unsafe integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
	     * @example
	     *
	     * _.isSafeInteger(3);
	     * // => true
	     *
	     * _.isSafeInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isSafeInteger(Infinity);
	     * // => false
	     *
	     * _.isSafeInteger('3');
	     * // => false
	     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
	     * Checks if `value` is classified as a `Set` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     * @example
	     *
	     * _.isSet(new Set);
	     * // => true
	     *
	     * _.isSet(new WeakSet);
	     * // => false
	     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
	     * Checks if `value` is classified as a `Symbol` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	     * @example
	     *
	     * _.isSymbol(Symbol.iterator);
	     * // => true
	     *
	     * _.isSymbol('abc');
	     * // => false
	     */function isSymbol(value){return(typeof value==='undefined'?'undefined':_typeof(value))=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */function isUndefined(value){return value===undefined;}/**
	     * Checks if `value` is classified as a `WeakMap` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
	     * @example
	     *
	     * _.isWeakMap(new WeakMap);
	     * // => true
	     *
	     * _.isWeakMap(new Map);
	     * // => false
	     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
	     * Checks if `value` is classified as a `WeakSet` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
	     * @example
	     *
	     * _.isWeakSet(new WeakSet);
	     * // => true
	     *
	     * _.isWeakSet(new Set);
	     * // => false
	     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     * @see _.gt
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */var lt=createRelationalOperation(baseLt);/**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to
	     *  `other`, else `false`.
	     * @see _.gte
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * _.toArray({ 'a': 1, 'b': 2 });
	     * // => [1, 2]
	     *
	     * _.toArray('abc');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toArray(1);
	     * // => []
	     *
	     * _.toArray(null);
	     * // => []
	     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
	     * Converts `value` to a finite number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.12.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted number.
	     * @example
	     *
	     * _.toFinite(3.2);
	     * // => 3.2
	     *
	     * _.toFinite(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toFinite(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toFinite('3.2');
	     * // => 3.2
	     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
	     * Converts `value` to an integer.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toInteger(3.2);
	     * // => 3
	     *
	     * _.toInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toInteger(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toInteger('3.2');
	     * // => 3
	     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
	     * Converts `value` to an integer suitable for use as the length of an
	     * array-like object.
	     *
	     * **Note:** This method is based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toLength(3.2);
	     * // => 3
	     *
	     * _.toLength(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toLength(Infinity);
	     * // => 4294967295
	     *
	     * _.toLength('3.2');
	     * // => 3
	     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
	     * Converts `value` to a number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     * @example
	     *
	     * _.toNumber(3.2);
	     * // => 3.2
	     *
	     * _.toNumber(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toNumber(Infinity);
	     * // => Infinity
	     *
	     * _.toNumber('3.2');
	     * // => 3.2
	     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
	     * Converts `value` to a plain object flattening inherited enumerable string
	     * keyed properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
	     * Converts `value` to a safe integer. A safe integer can be compared and
	     * represented correctly.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toSafeInteger(3.2);
	     * // => 3
	     *
	     * _.toSafeInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toSafeInteger(Infinity);
	     * // => 9007199254740991
	     *
	     * _.toSafeInteger('3.2');
	     * // => 3
	     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
	     * Converts `value` to a string. An empty string is returned for `null`
	     * and `undefined` values. The sign of `-0` is preserved.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.toString(null);
	     * // => ''
	     *
	     * _.toString(-0);
	     * // => '-0'
	     *
	     * _.toString([1, 2, 3]);
	     * // => '1,2,3'
	     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*//**
	     * Assigns own enumerable string keyed properties of source objects to the
	     * destination object. Source objects are applied from left to right.
	     * Subsequent sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object` and is loosely based on
	     * [`Object.assign`](https://mdn.io/Object/assign).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assignIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assign({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'c': 3 }
	     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
	     * This method is like `_.assign` except that it iterates over own and
	     * inherited source properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assign
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
	     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
	     * This method is like `_.assignIn` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extendWith
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignInWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
	     * This method is like `_.assign` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignInWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
	     * Creates an array of values corresponding to `paths` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Array} Returns the picked values.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _.at(object, ['a[0].b.c', 'a[1]']);
	     * // => [3, 4]
	     */var at=flatRest(baseAt);/**
	     * Creates an object that inherits from the `prototype` object. If a
	     * `properties` object is given, its own enumerable string keyed properties
	     * are assigned to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
	     * Assigns own and inherited enumerable string keyed properties of source
	     * objects to the destination object for all destination properties that
	     * resolve to `undefined`. Source objects are applied from left to right.
	     * Once a property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaultsDeep
	     * @example
	     *
	     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */var defaults=baseRest(function(args){args.push(undefined,customDefaultsAssignIn);return apply(assignInWith,undefined,args);});/**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaults
	     * @example
	     *
	     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
	     * // => { 'a': { 'b': 2, 'c': 3 } }
	     */var defaultsDeep=baseRest(function(args){args.push(undefined,customDefaultsMerge);return apply(mergeWith,undefined,args);});/**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(o) { return o.age < 40; });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(o) { return o.age < 40; });
	     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
	     * Iterates over own and inherited enumerable string keyed properties of an
	     * object and invokes `iteratee` for each property. The iteratee is invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forInRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
	     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
	     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
	     * Iterates over own enumerable string keyed properties of an object and
	     * invokes `iteratee` for each property. The iteratee is invoked with three
	     * arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwnRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
	     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
	     * Creates an array of function property names from own enumerable properties
	     * of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functionsIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functions(new Foo);
	     * // => ['a', 'b']
	     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
	     * Creates an array of function property names from own and inherited
	     * enumerable properties of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functions
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functionsIn(new Foo);
	     * // => ['a', 'b', 'c']
	     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
	     * Gets the value at `path` of `object`. If the resolved value is
	     * `undefined`, the `defaultValue` is returned in its place.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
	     * Checks if `path` is a direct property of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': 2 } };
	     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b');
	     * // => true
	     *
	     * _.has(object, ['a', 'b']);
	     * // => true
	     *
	     * _.has(other, 'a');
	     * // => false
	     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
	     * Checks if `path` is a direct or inherited property of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.hasIn(object, 'a');
	     * // => true
	     *
	     * _.hasIn(object, 'a.b');
	     * // => true
	     *
	     * _.hasIn(object, ['a', 'b']);
	     * // => true
	     *
	     * _.hasIn(object, 'b');
	     * // => false
	     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite
	     * property assignments of previous values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     */var invert=createInverter(function(result,value,key){result[value]=key;},constant(identity));/**
	     * This method is like `_.invert` except that the inverted object is generated
	     * from the results of running each element of `object` thru `iteratee`. The
	     * corresponding inverted value of each inverted key is an array of keys
	     * responsible for generating the inverted value. The iteratee is invoked
	     * with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invertBy(object);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     *
	     * _.invertBy(object, function(value) {
	     *   return 'group' + value;
	     * });
	     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
	     */var invertBy=createInverter(function(result,value,key){if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
	     * Invokes the method at `path` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
	     *
	     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
	     * // => [2, 3]
	     */var invoke=baseRest(baseInvoke);/**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
	     * with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapValues
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
	     * Creates an object with the same keys as `object` and values generated
	     * by running each own enumerable string keyed property of `object` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapKeys
	     * @example
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * _.mapValues(users, function(o) { return o.age; });
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
	     * This method is like `_.assign` except that it recursively merges own and
	     * inherited enumerable string keyed properties of source objects into the
	     * destination object. Source properties that resolve to `undefined` are
	     * skipped if a destination value exists. Array and plain object properties
	     * are merged recursively. Other objects and value types are overridden by
	     * assignment. Source objects are applied from left to right. Subsequent
	     * sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {
	     *   'a': [{ 'b': 2 }, { 'd': 4 }]
	     * };
	     *
	     * var other = {
	     *   'a': [{ 'c': 3 }, { 'e': 5 }]
	     * };
	     *
	     * _.merge(object, other);
	     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
	     * This method is like `_.merge` except that it accepts `customizer` which
	     * is invoked to produce the merged values of the destination and source
	     * properties. If `customizer` returns `undefined`, merging is handled by the
	     * method instead. The `customizer` is invoked with six arguments:
	     * (objValue, srcValue, key, object, source, stack).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (_.isArray(objValue)) {
	     *     return objValue.concat(srcValue);
	     *   }
	     * }
	     *
	     * var object = { 'a': [1], 'b': [2] };
	     * var other = { 'a': [3], 'b': [4] };
	     *
	     * _.mergeWith(object, other, customizer);
	     * // => { 'a': [1, 3], 'b': [2, 4] }
	     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable property paths of `object` that are not omitted.
	     *
	     * **Note:** This method is considerably slower than `_.pick`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to omit.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omit(object, ['a', 'c']);
	     * // => { 'b': '2' }
	     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
	     * The opposite of `_.pickBy`; this method creates an object composed of
	     * the own and inherited enumerable string keyed properties of `object` that
	     * `predicate` doesn't return truthy for. The predicate is invoked with two
	     * arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omitBy(object, _.isNumber);
	     * // => { 'b': '2' }
	     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
	     * Creates an object composed of the picked `object` properties.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pick(object, ['a', 'c']);
	     * // => { 'a': 1, 'c': 3 }
	     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
	     * Creates an object composed of the `object` properties `predicate` returns
	     * truthy for. The predicate is invoked with two arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pickBy(object, _.isNumber);
	     * // => { 'a': 1, 'c': 3 }
	     */function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
	     * This method is like `_.get` except that if the resolved value is a
	     * function it's invoked with the `this` binding of its parent object and
	     * its result is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a[0].b.c3', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a[0].b.c3', _.constant('default'));
	     * // => 'default'
	     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
	if(!length){length=1;object=undefined;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
	     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	     * it's created. Arrays are created for missing index properties while objects
	     * are created for all other missing properties. Use `_.setWith` to customize
	     * `path` creation.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, ['x', '0', 'y', 'z'], 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
	     * This method is like `_.set` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.setWith(object, '[0][1]', 'a', Object);
	     * // => { '0': { '1': 'a' } }
	     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
	     * Creates an array of own enumerable string keyed-value pairs for `object`
	     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	     * entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entries
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairs(new Foo);
	     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	     */var toPairs=createToPairs(keys);/**
	     * Creates an array of own and inherited enumerable string keyed-value pairs
	     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
	     * or set, its entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entriesIn
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairsIn(new Foo);
	     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
	     */var toPairsIn=createToPairs(keysIn);/**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own
	     * enumerable string keyed properties thru `iteratee`, with each invocation
	     * potentially mutating the `accumulator` object. If `accumulator` is not
	     * provided, a new object with the same `[[Prototype]]` will be used. The
	     * iteratee is invoked with four arguments: (accumulator, value, key, object).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * }, []);
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
	     * Removes the property at `path` of `object`.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
	     * _.unset(object, 'a[0].b.c');
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     *
	     * _.unset(object, ['a', '0', 'b', 'c']);
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
	     * This method is like `_.set` except that accepts `updater` to produce the
	     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
	     * is invoked with one argument: (value).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
	     * console.log(object.a[0].b.c);
	     * // => 9
	     *
	     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
	     * console.log(object.x[0].y.z);
	     * // => 0
	     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
	     * This method is like `_.update` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
	     * // => { '0': { '1': 'a' } }
	     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
	     * Creates an array of the own enumerable string keyed property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
	     * Creates an array of the own and inherited enumerable string keyed property
	     * values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*//**
	     * Clamps `number` within the inclusive `lower` and `upper` bounds.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Number
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     * @example
	     *
	     * _.clamp(-10, -5, 5);
	     * // => -5
	     *
	     * _.clamp(10, -5, 5);
	     * // => 5
	     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
	     * Checks if `n` is between `start` and up to, but not including, `end`. If
	     * `end` is not specified, it's set to `start` with `start` then set to `0`.
	     * If `start` is greater than `end` the params are swapped to support
	     * negative ranges.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.3.0
	     * @category Number
	     * @param {number} number The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     * @see _.range, _.rangeRight
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     *
	     * _.inRange(-3, -2, -6);
	     * // => true
	     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
	     * Produces a random number between the inclusive `lower` and `upper` bounds.
	     * If only one argument is provided a number between `0` and the given number
	     * is returned. If `floating` is `true`, or either `lower` or `upper` are
	     * floats, a floating-point number is returned instead of an integer.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Number
	     * @param {number} [lower=0] The lower bound.
	     * @param {number} [upper=1] The upper bound.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*//**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar--');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__FOO_BAR__');
	     * // => 'fooBar'
	     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
	     * Converts the first character of `string` to upper case and the remaining
	     * to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('FRED');
	     * // => 'Fred'
	     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
	     * Deburrs `string` by converting
	     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	     * letters to basic Latin letters and removing
	     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('déjà vu');
	     * // => 'deja vu'
	     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search up to.
	     * @returns {boolean} Returns `true` if `string` ends with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
	     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
	     * corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional
	     * characters use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value. See
	     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * When working with HTML you should always
	     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	     * XSS vectors.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
	     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https://lodash\.com/\)'
	     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
	     * Converts `string` to
	     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__FOO_BAR__');
	     * // => 'foo-bar'
	     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
	     * Converts `string`, as space separated words, to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.lowerCase('--Foo-Bar--');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('fooBar');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('__FOO_BAR__');
	     * // => 'foo bar'
	     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
	     * Converts the first character of `string` to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.lowerFirst('Fred');
	     * // => 'fred'
	     *
	     * _.lowerFirst('FRED');
	     * // => 'fRED'
	     */var lowerFirst=createCaseFirst('toLowerCase');/**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padEnd('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padEnd('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padEnd('abc', 3);
	     * // => 'abc'
	     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padStart('abc', 6);
	     * // => '   abc'
	     *
	     * _.padStart('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padStart('abc', 3);
	     * // => 'abc'
	     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
	     * hexadecimal, in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the
	     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix=10] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=1] The number of times to repeat the string.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
	     * Replaces matches for `pattern` in `string` with `replacement`.
	     *
	     * **Note:** This method is based on
	     * [`String#replace`](https://mdn.io/String/replace).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to modify.
	     * @param {RegExp|string} pattern The pattern to replace.
	     * @param {Function|string} replacement The match replacement.
	     * @returns {string} Returns the modified string.
	     * @example
	     *
	     * _.replace('Hi Fred', 'Fred', 'Barney');
	     * // => 'Hi Barney'
	     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
	     * Converts `string` to
	     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--FOO-BAR--');
	     * // => 'foo_bar'
	     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
	     * Splits `string` by `separator`.
	     *
	     * **Note:** This method is based on
	     * [`String#split`](https://mdn.io/String/split).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to split.
	     * @param {RegExp|string} separator The separator pattern to split by.
	     * @param {number} [limit] The length to truncate results to.
	     * @returns {Array} Returns the string segments.
	     * @example
	     *
	     * _.split('a-b-c', '-', 2);
	     * // => ['a', 'b']
	     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
	     * Converts `string` to
	     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.1.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar--');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__FOO_BAR__');
	     * // => 'FOO BAR'
	     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is given, it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options={}] The options object.
	     * @param {RegExp} [options.escape=_.templateSettings.escape]
	     *  The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
	     *  The "evaluate" delimiter.
	     * @param {Object} [options.imports=_.templateSettings.imports]
	     *  An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
	     *  The "interpolate" delimiter.
	     * @param {string} [options.sourceURL='lodash.templateSources[n]']
	     *  The sourceURL of the compiled template.
	     * @param {string} [options.variable='obj']
	     *  The data object variable name.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // Use the "interpolate" delimiter to create a compiled template.
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // Use the HTML "escape" delimiter to escape data property values.
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the internal `print` function in "evaluate" delimiters.
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // Use the ES template literal delimiter as an "interpolate" delimiter.
	     * // Disable support by replacing the "interpolate" delimiter.
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // Use backslashes to treat delimiters as plain text.
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // Use the `imports` option to import `jQuery` as `jq`.
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
	     *
	     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // Use custom template delimiters.
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // Use the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and stack traces.
	     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
	// (http://ejohn.org/blog/javascript-micro-templating/)
	// and Laura Doktorova's doT.js (https://github.com/olado/doT).
	var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
	var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
	var sourceURL='//# sourceURL='+('sourceURL'in options?options.sourceURL:'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
	source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
	if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
	// order to produce the correct `offset` value.
	return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
	// code to add the data object to the top of the scope chain.
	var variable=options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Cleanup code by stripping empty strings.
	source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
	source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
	// the `source` property as a convenience for inlining compiled templates.
	result.source=source;if(isError(result)){throw result;}return result;}/**
	     * Converts `string`, as a whole, to lower case just like
	     * [String#toLowerCase](https://mdn.io/toLowerCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.toLower('--Foo-Bar--');
	     * // => '--foo-bar--'
	     *
	     * _.toLower('fooBar');
	     * // => 'foobar'
	     *
	     * _.toLower('__FOO_BAR__');
	     * // => '__foo_bar__'
	     */function toLower(value){return toString(value).toLowerCase();}/**
	     * Converts `string`, as a whole, to upper case just like
	     * [String#toUpperCase](https://mdn.io/toUpperCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.toUpper('--foo-bar--');
	     * // => '--FOO-BAR--'
	     *
	     * _.toUpper('fooBar');
	     * // => 'FOOBAR'
	     *
	     * _.toUpper('__foo_bar__');
	     * // => '__FOO_BAR__'
	     */function toUpper(value){return toString(value).toUpperCase();}/**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrim,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimEnd('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimEnd('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimEnd,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimStart('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimStart('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object} [options={}] The options object.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.truncate('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
	     * their corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional
	     * HTML entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.6.0
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
	     * Converts `string`, as space separated words, to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.upperCase('--foo-bar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('fooBar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('__foo_bar__');
	     * // => 'FOO BAR'
	     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
	     * Converts the first character of `string` to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.upperFirst('fred');
	     * // => 'Fred'
	     *
	     * _.upperFirst('FRED');
	     * // => 'FRED'
	     */var upperFirst=createCaseFirst('toUpperCase');/**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*//**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Function} func The function to attempt.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // Avoid throwing errors for invalid selectors.
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method.
	     *
	     * **Note:** This method doesn't set the "length" property of bound functions.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} methodNames The object method names to bind.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'click': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view, ['click']);
	     * jQuery(element).on('click', view.click);
	     * // => Logs 'clicked docs' when clicked.
	     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
	     * Creates a function that iterates over `pairs` and invokes the corresponding
	     * function of the first predicate to return truthy. The predicate-function
	     * pairs are invoked with the `this` binding and arguments of the created
	     * function.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Array} pairs The predicate-function pairs.
	     * @returns {Function} Returns the new composite function.
	     * @example
	     *
	     * var func = _.cond([
	     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
	     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
	     *   [_.stubTrue,                      _.constant('no match')]
	     * ]);
	     *
	     * func({ 'a': 1, 'b': 2 });
	     * // => 'matches A'
	     *
	     * func({ 'a': 0, 'b': 1 });
	     * // => 'matches B'
	     *
	     * func({ 'a': '1', 'b': '2' });
	     * // => 'no match'
	     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
	     * Creates a function that invokes the predicate properties of `source` with
	     * the corresponding property values of a given object, returning `true` if
	     * all predicates return truthy, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.conformsTo` with
	     * `source` partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 2, 'b': 1 },
	     *   { 'a': 1, 'b': 2 }
	     * ];
	     *
	     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
	     * // => [{ 'a': 1, 'b': 2 }]
	     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new constant function.
	     * @example
	     *
	     * var objects = _.times(2, _.constant({ 'a': 1 }));
	     *
	     * console.log(objects);
	     * // => [{ 'a': 1 }, { 'a': 1 }]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => true
	     */function constant(value){return function(){return value;};}/**
	     * Checks `value` to determine whether a default value should be returned in
	     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
	     * or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Util
	     * @param {*} value The value to check.
	     * @param {*} defaultValue The default value.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * _.defaultTo(1, 10);
	     * // => 1
	     *
	     * _.defaultTo(undefined, 10);
	     * // => 10
	     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
	     * Creates a function that returns the result of invoking the given functions
	     * with the `this` binding of the created function, where each successive
	     * invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flowRight
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow([_.add, square]);
	     * addSquare(1, 2);
	     * // => 9
	     */var flow=createFlow();/**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the given functions from right to left.
	     *
	     * @static
	     * @since 3.0.0
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flow
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight([square, _.add]);
	     * addSquare(1, 2);
	     * // => 9
	     */var flowRight=createFlow(true);/**
	     * This method returns the first argument it receives.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     *
	     * console.log(_.identity(object) === object);
	     * // => true
	     */function identity(value){return value;}/**
	     * Creates a function that invokes `func` with the arguments of the created
	     * function. If `func` is a property name, the created function returns the
	     * property value for a given element. If `func` is an array or object, the
	     * created function returns `true` for elements that contain the equivalent
	     * source properties, otherwise it returns `false`.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Util
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
	     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, _.iteratee(['user', 'fred']));
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, _.iteratee('user'));
	     * // => ['barney', 'fred']
	     *
	     * // Create custom iteratee shorthands.
	     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
	     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
	     *     return func.test(string);
	     *   };
	     * });
	     *
	     * _.filter(['abc', 'def'], /ef/);
	     * // => ['def']
	     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
	     * Creates a function that performs a partial deep comparison between a given
	     * object and `source`, returning `true` if the given object has equivalent
	     * property values, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.isMatch` with `source`
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
	     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
	     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
	     * Creates a function that performs a partial deep comparison between the
	     * value at `path` of a given object to `srcValue`, returning `true` if the
	     * object value is equivalent, else `false`.
	     *
	     * **Note:** Partial comparisons will match empty array and empty object
	     * `srcValue` values against any array or object value, respectively. See
	     * `_.isEqual` for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.find(objects, _.matchesProperty('a', 4));
	     * // => { 'a': 4, 'b': 5, 'c': 6 }
	     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
	     * Creates a function that invokes the method at `path` of a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': _.constant(2) } },
	     *   { 'a': { 'b': _.constant(1) } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(objects, _.method(['a', 'b']));
	     * // => [2, 1]
	     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path of `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
	     * Adds all own enumerable string keyed function properties of a source
	     * object to the destination object. If `object` is a function, then methods
	     * are added to its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
	     * This method returns `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Util
	     * @example
	     *
	     * _.times(2, _.noop);
	     * // => [undefined, undefined]
	     */function noop(){}// No operation performed.
	/**
	     * Creates a function that gets the argument at index `n`. If `n` is negative,
	     * the nth argument from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [n=0] The index of the argument to return.
	     * @returns {Function} Returns the new pass-thru function.
	     * @example
	     *
	     * var func = _.nthArg(1);
	     * func('a', 'b', 'c', 'd');
	     * // => 'b'
	     *
	     * var func = _.nthArg(-2);
	     * func('a', 'b', 'c', 'd');
	     * // => 'c'
	     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
	     * Creates a function that invokes `iteratees` with the arguments it receives
	     * and returns their results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.over([Math.max, Math.min]);
	     *
	     * func(1, 2, 3, 4);
	     * // => [4, 1]
	     */var over=createOver(arrayMap);/**
	     * Creates a function that checks if **all** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overEvery([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => false
	     *
	     * func(NaN);
	     * // => false
	     */var overEvery=createOver(arrayEvery);/**
	     * Creates a function that checks if **any** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overSome([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => true
	     *
	     * func(NaN);
	     * // => false
	     */var overSome=createOver(arraySome);/**
	     * Creates a function that returns the value at `path` of a given object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': 2 } },
	     *   { 'a': { 'b': 1 } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	     * // => [1, 2]
	     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the value at a given path of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	     * `start` is specified without an `end` or `step`. If `end` is not specified,
	     * it's set to `start` with `start` then set to `0`.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.rangeRight
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(-4);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */var range=createRange();/**
	     * This method is like `_.range` except that it populates values in
	     * descending order.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.range
	     * @example
	     *
	     * _.rangeRight(4);
	     * // => [3, 2, 1, 0]
	     *
	     * _.rangeRight(-4);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 5);
	     * // => [4, 3, 2, 1]
	     *
	     * _.rangeRight(0, 20, 5);
	     * // => [15, 10, 5, 0]
	     *
	     * _.rangeRight(0, -4, -1);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.rangeRight(0);
	     * // => []
	     */var rangeRight=createRange(true);/**
	     * This method returns a new empty array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Array} Returns the new empty array.
	     * @example
	     *
	     * var arrays = _.times(2, _.stubArray);
	     *
	     * console.log(arrays);
	     * // => [[], []]
	     *
	     * console.log(arrays[0] === arrays[1]);
	     * // => false
	     */function stubArray(){return[];}/**
	     * This method returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `false`.
	     * @example
	     *
	     * _.times(2, _.stubFalse);
	     * // => [false, false]
	     */function stubFalse(){return false;}/**
	     * This method returns a new empty object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Object} Returns the new empty object.
	     * @example
	     *
	     * var objects = _.times(2, _.stubObject);
	     *
	     * console.log(objects);
	     * // => [{}, {}]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => false
	     */function stubObject(){return{};}/**
	     * This method returns an empty string.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {string} Returns the empty string.
	     * @example
	     *
	     * _.times(2, _.stubString);
	     * // => ['', '']
	     */function stubString(){return'';}/**
	     * This method returns `true`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `true`.
	     * @example
	     *
	     * _.times(2, _.stubTrue);
	     * // => [true, true]
	     */function stubTrue(){return true;}/**
	     * Invokes the iteratee `n` times, returning an array of the results of
	     * each invocation. The iteratee is invoked with one argument; (index).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.times(3, String);
	     * // => ['0', '1', '2']
	     *
	     *  _.times(4, _.constant(0));
	     * // => [0, 0, 0, 0]
	     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
	     * Converts `value` to a property path array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the new property path array.
	     * @example
	     *
	     * _.toPath('a.b.c');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toPath('a[0].b.c');
	     * // => ['a', '0', 'b', 'c']
	     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
	     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {string} [prefix=''] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*//**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {number} augend The first number in an addition.
	     * @param {number} addend The second number in an addition.
	     * @returns {number} Returns the total.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
	     * Computes `number` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */var ceil=createRound('ceil');/**
	     * Divide two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} dividend The first number in a division.
	     * @param {number} divisor The second number in a division.
	     * @returns {number} Returns the quotient.
	     * @example
	     *
	     * _.divide(6, 4);
	     * // => 1.5
	     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
	     * Computes `number` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */var floor=createRound('floor');/**
	     * Computes the maximum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => undefined
	     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
	     * This method is like `_.max` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.maxBy(objects, function(o) { return o.n; });
	     * // => { 'n': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.maxBy(objects, 'n');
	     * // => { 'n': 2 }
	     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**
	     * Computes the mean of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * _.mean([4, 2, 8, 6]);
	     * // => 5
	     */function mean(array){return baseMean(array,identity);}/**
	     * This method is like `_.mean` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be averaged.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.meanBy(objects, function(o) { return o.n; });
	     * // => 5
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.meanBy(objects, 'n');
	     * // => 5
	     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
	     * Computes the minimum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => undefined
	     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
	     * This method is like `_.min` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.minBy(objects, function(o) { return o.n; });
	     * // => { 'n': 1 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.minBy(objects, 'n');
	     * // => { 'n': 1 }
	     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**
	     * Multiply two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} multiplier The first number in a multiplication.
	     * @param {number} multiplicand The second number in a multiplication.
	     * @returns {number} Returns the product.
	     * @example
	     *
	     * _.multiply(6, 4);
	     * // => 24
	     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
	     * Computes `number` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */var round=createRound('round');/**
	     * Subtract two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {number} minuend The first number in a subtraction.
	     * @param {number} subtrahend The second number in a subtraction.
	     * @returns {number} Returns the difference.
	     * @example
	     *
	     * _.subtract(6, 4);
	     * // => 2
	     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
	     * Computes the sum of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 2, 8, 6]);
	     * // => 20
	     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
	     * This method is like `_.sum` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be summed.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.sumBy(objects, function(o) { return o.n; });
	     * // => 20
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sumBy(objects, 'n');
	     * // => 20
	     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/// Add methods that return wrapped values in chain sequences.
	lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
	lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
	mixin(lodash,lodash);/*------------------------------------------------------------------------*/// Add methods that return unwrapped values in chain sequences.
	lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
	lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*//**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type {string}
	     */lodash.VERSION=VERSION;// Assign default placeholders.
	arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
	arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
	arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
	arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
	baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function interceptor(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
	isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
	arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
	baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'',names=realNames[key]||(realNames[key]=[]);names.push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
	LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
	lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
	lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/// Export lodash.
	var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
	if("function"=='function'&&_typeof(__webpack_require__(6))=='object'&&__webpack_require__(6)){// Expose Lodash on the global object to prevent errors when Lodash is
	// loaded by a script tag in the presence of an AMD loader.
	// See http://requirejs.org/docs/errors.html#mismatch for more details.
	// Use `_.noConflict` to remove Lodash from the global object.
	root._=_;// Define as an anonymous module so, through path mapping, it can be
	// referenced as the "underscore" module.
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return _;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds it.
	else if(freeModule){// Export for Node.js.
	(freeModule.exports=_)._=_;// Export for CommonJS support.
	freeExports._=_;}else{// Export to the global object.
	root._=_;}}).call(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(5)(module)))

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _modular = __webpack_require__(96);

	var _modular2 = _interopRequireDefault(_modular);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}

	// import Dir2 from './Dir2/index';
	module.exports = function (lwj) {
	    (0, _modular2.default)();
	    return lwj //.directive(...modularEidtType).directive(...modularEidtForm)
	    // @https://github.com/w3cui/ngDraggable
	    .service('ngDraggable', [function () {

	        var scope = this;
	        scope.inputEvent = function (event) {
	            if (angular.isDefined(event.touches)) {
	                return event.touches[0];
	            }
	            //Checking both is not redundent. If only check if touches isDefined, angularjs isDefnied will return error and stop the remaining scripty if event.originalEvent is not defined.
	            else if (angular.isDefined(event.originalEvent) && angular.isDefined(event.originalEvent.touches)) {
	                    return event.originalEvent.touches[0];
	                }
	            return event;
	        };

	        scope.touchTimeout = 100;
	    }]).directive('myBlur', [function () {
	        return {
	            restrict: 'A',
	            link: function link(scope, element, attr) {
	                element.bind('blur', function () {
	                    //apply scope (attributes)
	                    scope.$apply(attr.myBlur) || false;
	                    //return scope value for focusing to false
	                    //scope.$eval(attr.myFocus + '=false');
	                });
	            }
	        };
	    }]).directive('ngDrag', ['$rootScope', '$parse', '$document', '$window', 'ngDraggable', function ($rootScope, $parse, $document, $window, ngDraggable) {
	        return {
	            restrict: 'A',
	            link: function link(scope, element, attrs) {
	                scope.value = attrs.ngDrag;
	                var offset,
	                    _centerAnchor = false,
	                    _mx,
	                    _my,
	                    _tx,
	                    _ty,
	                    _mrx,
	                    _mry;
	                var _hasTouch = 'ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch;
	                var _pressEvents = 'touchstart mousedown';
	                var _moveEvents = 'touchmove mousemove';
	                var _releaseEvents = 'touchend mouseup';
	                var _dragHandle;

	                // to identify the element in order to prevent getting superflous events when a single element has both drag and drop directives on it.
	                var _myid = scope.$id;
	                var _data = null;

	                var _dragOffset = null;

	                var _dragEnabled = false;

	                var _pressTimer = null;

	                var onDragStartCallback = $parse(attrs.ngDragStart) || null;
	                var onDragStopCallback = $parse(attrs.ngDragStop) || null;
	                var onDragSuccessCallback = $parse(attrs.ngDragSuccess) || null;
	                var allowTransform = angular.isDefined(attrs.allowTransform) ? scope.$eval(attrs.allowTransform) : true;

	                var getDragData = $parse(attrs.ngDragData);

	                // deregistration function for mouse move events in $rootScope triggered by jqLite trigger handler
	                var _deregisterRootMoveListener = angular.noop;

	                var initialize = function initialize() {
	                    element.attr('draggable', 'false'); // prevent native drag
	                    // check to see if drag handle(s) was specified
	                    // if querySelectorAll is available, we use this instead of find
	                    // as JQLite find is limited to tagnames
	                    if (element[0].querySelectorAll) {
	                        var dragHandles = angular.element(element[0].querySelectorAll('[ng-drag-handle]'));
	                    } else {
	                        var dragHandles = element.find('[ng-drag-handle]');
	                    }
	                    if (dragHandles.length) {
	                        _dragHandle = dragHandles;
	                    }
	                    toggleListeners(true);
	                };

	                var toggleListeners = function toggleListeners(enable) {
	                    if (!enable) return;
	                    // add listeners.

	                    scope.$on('$destroy', onDestroy);
	                    scope.$watch(attrs.ngDrag, onEnableChange);
	                    scope.$watch(attrs.ngCenterAnchor, onCenterAnchor);
	                    // wire up touch events
	                    if (_dragHandle) {
	                        // handle(s) specified, use those to initiate drag
	                        _dragHandle.on(_pressEvents, onpress);
	                    } else {
	                        // no handle(s) specified, use the element as the handle
	                        element.on(_pressEvents, onpress);
	                    }
	                    // if(! _hasTouch && element[0].nodeName.toLowerCase() == "img"){
	                    if (element[0].nodeName.toLowerCase() == "img") {
	                        element.on('mousedown', function () {
	                            return false;
	                        }); // prevent native drag for images
	                    }
	                };
	                var onDestroy = function onDestroy(enable) {
	                    toggleListeners(false);
	                };
	                var onEnableChange = function onEnableChange(newVal, oldVal) {
	                    _dragEnabled = newVal;
	                };
	                var onCenterAnchor = function onCenterAnchor(newVal, oldVal) {
	                    if (angular.isDefined(newVal)) _centerAnchor = newVal || 'true';
	                };

	                var isClickableElement = function isClickableElement(evt) {
	                    return angular.isDefined(angular.element(evt.target).attr("ng-cancel-drag"));
	                };
	                /*
	                 * When the element is clicked start the drag behaviour
	                 * On touch devices as a small delay so as not to prevent native window scrolling
	                 */
	                var onpress = function onpress(evt) {
	                    // console.log("110"+" onpress: "+Math.random()+" "+ evt.type);
	                    if (!_dragEnabled) return;

	                    if (isClickableElement(evt)) {
	                        return;
	                    }

	                    if (evt.type == "mousedown" && evt.button != 0) {
	                        // Do not start dragging on right-click
	                        return;
	                    }

	                    var useTouch = evt.type === 'touchstart' ? true : false;

	                    if (useTouch) {
	                        cancelPress();
	                        _pressTimer = setTimeout(function () {
	                            cancelPress();
	                            onlongpress(evt);
	                            onmove(evt);
	                        }, ngDraggable.touchTimeout);
	                        $document.on(_moveEvents, cancelPress);
	                        $document.on(_releaseEvents, cancelPress);
	                    } else {
	                        onlongpress(evt);
	                    }
	                };

	                var cancelPress = function cancelPress() {
	                    clearTimeout(_pressTimer);
	                    $document.off(_moveEvents, cancelPress);
	                    $document.off(_releaseEvents, cancelPress);
	                };

	                var onlongpress = function onlongpress(evt) {
	                    if (!_dragEnabled) return;
	                    evt.preventDefault();

	                    offset = element[0].getBoundingClientRect();
	                    if (allowTransform) _dragOffset = offset;else {
	                        _dragOffset = { left: document.body.scrollLeft, top: document.body.scrollTop };
	                    }

	                    element.centerX = element[0].offsetWidth / 2;
	                    element.centerY = element[0].offsetHeight / 2;

	                    _mx = ngDraggable.inputEvent(evt).pageX; //ngDraggable.getEventProp(evt, 'pageX');
	                    _my = ngDraggable.inputEvent(evt).pageY; //ngDraggable.getEventProp(evt, 'pageY');
	                    _mrx = _mx - offset.left;
	                    _mry = _my - offset.top;
	                    if (_centerAnchor) {
	                        _tx = _mx - element.centerX - $window.pageXOffset;
	                        _ty = _my - element.centerY - $window.pageYOffset;
	                    } else {
	                        _tx = _mx - _mrx - $window.pageXOffset;
	                        _ty = _my - _mry - $window.pageYOffset;
	                    }

	                    $document.on(_moveEvents, onmove);
	                    $document.on(_releaseEvents, onrelease);
	                    // This event is used to receive manually triggered mouse move events
	                    // jqLite unfortunately only supports triggerHandler(...)
	                    // See http://api.jquery.com/triggerHandler/
	                    // _deregisterRootMoveListener = $rootScope.$on('draggable:_triggerHandlerMove', onmove);
	                    _deregisterRootMoveListener = $rootScope.$on('draggable:_triggerHandlerMove', function (event, origEvent) {
	                        onmove(origEvent);
	                    });
	                };

	                var onmove = function onmove(evt) {
	                    if (!_dragEnabled) return;
	                    evt.preventDefault();

	                    if (!element.hasClass('dragging')) {
	                        _data = getDragData(scope);
	                        element.addClass('dragging');
	                        $rootScope.$broadcast('draggable:start', { x: _mx, y: _my, tx: _tx, ty: _ty, event: evt, element: element, data: _data });

	                        if (onDragStartCallback) {
	                            scope.$apply(function () {
	                                onDragStartCallback(scope, { $data: _data, $event: evt });
	                            });
	                        }
	                    }

	                    _mx = ngDraggable.inputEvent(evt).pageX; //ngDraggable.getEventProp(evt, 'pageX');
	                    _my = ngDraggable.inputEvent(evt).pageY; //ngDraggable.getEventProp(evt, 'pageY');

	                    if (_centerAnchor) {
	                        _tx = _mx - element.centerX - _dragOffset.left;
	                        _ty = _my - element.centerY - _dragOffset.top;
	                    } else {
	                        _tx = _mx - _mrx - _dragOffset.left;
	                        _ty = _my - _mry - _dragOffset.top;
	                    }

	                    moveElement(_tx, _ty);

	                    $rootScope.$broadcast('draggable:move', { x: _mx, y: _my, tx: _tx, ty: _ty, event: evt, element: element, data: _data, uid: _myid, dragOffset: _dragOffset });
	                };

	                var onrelease = function onrelease(evt) {
	                    if (!_dragEnabled) return;
	                    evt.preventDefault();
	                    $rootScope.$broadcast('draggable:end', { x: _mx, y: _my, tx: _tx, ty: _ty, event: evt, element: element, data: _data, callback: onDragComplete, uid: _myid });
	                    element.removeClass('dragging');
	                    element.parent().find('.drag-enter').removeClass('drag-enter');
	                    reset();
	                    $document.off(_moveEvents, onmove);
	                    $document.off(_releaseEvents, onrelease);

	                    if (onDragStopCallback) {
	                        scope.$apply(function () {
	                            onDragStopCallback(scope, { $data: _data, $event: evt });
	                        });
	                    }

	                    _deregisterRootMoveListener();
	                };

	                var onDragComplete = function onDragComplete(evt) {

	                    if (!onDragSuccessCallback) return;

	                    scope.$apply(function () {
	                        onDragSuccessCallback(scope, { $data: _data, $event: evt });
	                    });
	                };

	                var reset = function reset() {
	                    if (allowTransform) element.css({ transform: '', 'z-index': '', '-webkit-transform': '', '-ms-transform': '' });else element.css({ 'position': '', top: '', left: '' });
	                };

	                var moveElement = function moveElement(x, y) {
	                    if (allowTransform) {
	                        element.css({
	                            transform: 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ' + x + ', ' + y + ', 0, 1)',
	                            'z-index': 99999,
	                            '-webkit-transform': 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ' + x + ', ' + y + ', 0, 1)',
	                            '-ms-transform': 'matrix(1, 0, 0, 1, ' + x + ', ' + y + ')'
	                        });
	                    } else {
	                        element.css({ 'left': x + 'px', 'top': y + 'px', 'position': 'fixed' });
	                    }
	                };
	                initialize();
	            }
	        };
	    }]).directive('ngDrop', ['$parse', '$timeout', '$window', '$document', 'ngDraggable', function ($parse, $timeout, $window, $document, ngDraggable) {
	        return {
	            restrict: 'A',
	            link: function link(scope, element, attrs) {
	                scope.value = attrs.ngDrop;
	                scope.isTouching = false;

	                var _lastDropTouch = null;

	                var _myid = scope.$id;

	                var _dropEnabled = false;

	                var onDropCallback = $parse(attrs.ngDropSuccess); // || function(){};

	                var onDragStartCallback = $parse(attrs.ngDragStart);
	                var onDragStopCallback = $parse(attrs.ngDragStop);
	                var onDragMoveCallback = $parse(attrs.ngDragMove);

	                var initialize = function initialize() {
	                    toggleListeners(true);
	                };

	                var toggleListeners = function toggleListeners(enable) {
	                    // remove listeners

	                    if (!enable) return;
	                    // add listeners.
	                    scope.$watch(attrs.ngDrop, onEnableChange);
	                    scope.$on('$destroy', onDestroy);
	                    scope.$on('draggable:start', onDragStart);
	                    scope.$on('draggable:move', onDragMove);
	                    scope.$on('draggable:end', onDragEnd);
	                };

	                var onDestroy = function onDestroy(enable) {
	                    toggleListeners(false);
	                };
	                var onEnableChange = function onEnableChange(newVal, oldVal) {
	                    _dropEnabled = newVal;
	                };
	                var onDragStart = function onDragStart(evt, obj) {
	                    if (!_dropEnabled) return;
	                    isTouching(obj.x, obj.y, obj.element);

	                    if (attrs.ngDragStart) {
	                        $timeout(function () {
	                            onDragStartCallback(scope, { $data: obj.data, $event: obj });
	                        });
	                    }
	                };
	                var onDragMove = function onDragMove(evt, obj) {
	                    if (!_dropEnabled) return;
	                    isTouching(obj.x, obj.y, obj.element);

	                    if (attrs.ngDragMove) {
	                        $timeout(function () {
	                            onDragMoveCallback(scope, { $data: obj.data, $event: obj });
	                        });
	                    }
	                };

	                var onDragEnd = function onDragEnd(evt, obj) {

	                    // don't listen to drop events if this is the element being dragged
	                    // only update the styles and return
	                    if (!_dropEnabled || _myid === obj.uid) {
	                        updateDragStyles(false, obj.element);
	                        return;
	                    }
	                    if (isTouching(obj.x, obj.y, obj.element)) {
	                        // call the ngDraggable ngDragSuccess element callback
	                        if (obj.callback) {
	                            obj.callback(obj);
	                        }

	                        if (attrs.ngDropSuccess) {
	                            $timeout(function () {
	                                onDropCallback(scope, { $data: obj.data, $event: obj, $target: scope.$eval(scope.value) });
	                            });
	                        }
	                    }

	                    if (attrs.ngDragStop) {
	                        $timeout(function () {
	                            onDragStopCallback(scope, { $data: obj.data, $event: obj });
	                        });
	                    }

	                    updateDragStyles(false, obj.element);
	                };

	                var isTouching = function isTouching(mouseX, mouseY, dragElement) {
	                    var touching = hitTest(mouseX, mouseY);
	                    scope.isTouching = touching;
	                    if (touching) {
	                        _lastDropTouch = element;
	                    }
	                    updateDragStyles(touching, dragElement);
	                    return touching;
	                };

	                var updateDragStyles = function updateDragStyles(touching, dragElement) {
	                    if (touching) {
	                        element.addClass('drag-enter');
	                        dragElement.addClass('drag-over');
	                    } else if (_lastDropTouch == element) {
	                        _lastDropTouch = null;
	                        element.removeClass('drag-enter');
	                        dragElement.removeClass('drag-over');
	                    }
	                };

	                var hitTest = function hitTest(x, y) {
	                    var bounds = element[0].getBoundingClientRect(); // ngDraggable.getPrivOffset(element);
	                    x -= $document[0].body.scrollLeft + $document[0].documentElement.scrollLeft;
	                    y -= $document[0].body.scrollTop + $document[0].documentElement.scrollTop;
	                    return x >= bounds.left && x <= bounds.right && y <= bounds.bottom && y >= bounds.top;
	                };

	                initialize();
	            }
	        };
	    }]).directive('ngDragClone', ['$parse', '$timeout', 'ngDraggable', function ($parse, $timeout, ngDraggable) {
	        return {
	            restrict: 'A',
	            link: function link(scope, element, attrs) {
	                var img,
	                    _allowClone = true;
	                var _dragOffset = null;
	                scope.clonedData = {};
	                var initialize = function initialize() {

	                    img = element.find('img');
	                    element.attr('draggable', 'false');
	                    img.attr('draggable', 'false');
	                    reset();
	                    toggleListeners(true);
	                };

	                var toggleListeners = function toggleListeners(enable) {
	                    // remove listeners

	                    if (!enable) return;
	                    // add listeners.
	                    scope.$on('draggable:start', onDragStart);
	                    scope.$on('draggable:move', onDragMove);
	                    scope.$on('draggable:end', onDragEnd);
	                    preventContextMenu();
	                };
	                var preventContextMenu = function preventContextMenu() {
	                    //  element.off('mousedown touchstart touchmove touchend touchcancel', absorbEvent_);
	                    img.off('mousedown touchstart touchmove touchend touchcancel', absorbEvent_);
	                    //  element.on('mousedown touchstart touchmove touchend touchcancel', absorbEvent_);
	                    img.on('mousedown touchstart touchmove touchend touchcancel', absorbEvent_);
	                };
	                var onDragStart = function onDragStart(evt, obj, elm) {
	                    _allowClone = true;
	                    if (angular.isDefined(obj.data.allowClone)) {
	                        _allowClone = obj.data.allowClone;
	                    }
	                    if (_allowClone) {
	                        scope.$apply(function () {
	                            scope.clonedData = obj.data;
	                        });
	                        element.css('width', obj.element[0].offsetWidth);
	                        element.css('height', obj.element[0].offsetHeight);

	                        moveElement(obj.tx, obj.ty);
	                    }
	                };
	                var onDragMove = function onDragMove(evt, obj) {
	                    if (_allowClone) {

	                        _tx = obj.tx + obj.dragOffset.left;
	                        _ty = obj.ty + obj.dragOffset.top;

	                        moveElement(_tx, _ty);
	                    }
	                };
	                var onDragEnd = function onDragEnd(evt, obj) {
	                    //moveElement(obj.tx,obj.ty);
	                    if (_allowClone) {
	                        reset();
	                    }
	                };

	                var reset = function reset() {
	                    element.css({ left: 0, top: 0, position: 'fixed', 'z-index': -1, visibility: 'hidden' });
	                };
	                var moveElement = function moveElement(x, y) {
	                    element.css({
	                        transform: 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ' + x + ', ' + y + ', 0, 1)', 'z-index': 99999, 'visibility': 'visible',
	                        '-webkit-transform': 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ' + x + ', ' + y + ', 0, 1)',
	                        '-ms-transform': 'matrix(1, 0, 0, 1, ' + x + ', ' + y + ')'
	                        //,margin: '0'  don't monkey with the margin,
	                    });
	                };

	                var absorbEvent_ = function absorbEvent_(event) {
	                    var e = event; //.originalEvent;
	                    e.preventDefault && e.preventDefault();
	                    e.stopPropagation && e.stopPropagation();
	                    e.cancelBubble = true;
	                    e.returnValue = false;
	                    return false;
	                };

	                initialize();
	            }
	        };
	    }]).directive('ngPreventDrag', ['$parse', '$timeout', function ($parse, $timeout) {
	        return {
	            restrict: 'A',
	            link: function link(scope, element, attrs) {
	                var initialize = function initialize() {

	                    element.attr('draggable', 'false');
	                    toggleListeners(true);
	                };

	                var toggleListeners = function toggleListeners(enable) {
	                    // remove listeners

	                    if (!enable) return;
	                    // add listeners.
	                    element.on('mousedown touchstart touchmove touchend touchcancel', absorbEvent_);
	                };

	                var absorbEvent_ = function absorbEvent_(event) {
	                    var e = event.originalEvent;
	                    e.preventDefault && e.preventDefault();
	                    e.stopPropagation && e.stopPropagation();
	                    e.cancelBubble = true;
	                    e.returnValue = false;
	                    return false;
	                };

	                initialize();
	            }
	        };
	    }]).directive('ngCancelDrag', [function () {
	        return {
	            restrict: 'A',
	            link: function link(scope, element, attrs) {
	                element.find('*').attr('ng-cancel-drag', 'ng-cancel-drag');
	            }
	        };
	    }]).directive('ngDragScroll', ['$window', '$interval', '$timeout', '$document', '$rootScope', function ($window, $interval, $timeout, $document, $rootScope) {
	        return {
	            restrict: 'A',
	            link: function link(scope, element, attrs) {
	                var intervalPromise = null;
	                var lastMouseEvent = null;

	                var config = {
	                    verticalScroll: attrs.verticalScroll || true,
	                    horizontalScroll: attrs.horizontalScroll || true,
	                    activationDistance: attrs.activationDistance || 75,
	                    scrollDistance: attrs.scrollDistance || 15
	                };

	                var reqAnimFrame = function () {
	                    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function ( /* function FrameRequestCallback */callback, /* DOMElement Element */element) {
	                        window.setTimeout(callback, 1000 / 60);
	                    };
	                }();

	                var animationIsOn = false;
	                var createInterval = function createInterval() {
	                    animationIsOn = true;

	                    function nextFrame(callback) {
	                        var args = Array.prototype.slice.call(arguments);
	                        if (animationIsOn) {
	                            reqAnimFrame(function () {
	                                $rootScope.$apply(function () {
	                                    callback.apply(null, args);
	                                    nextFrame(callback);
	                                });
	                            });
	                        }
	                    }

	                    nextFrame(function () {
	                        if (!lastMouseEvent) return;

	                        var viewportWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	                        var viewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

	                        var scrollX = 0;
	                        var scrollY = 0;

	                        if (config.horizontalScroll) {
	                            // If horizontal scrolling is active.
	                            if (lastMouseEvent.clientX < config.activationDistance) {
	                                // If the mouse is on the left of the viewport within the activation distance.
	                                scrollX = -config.scrollDistance;
	                            } else if (lastMouseEvent.clientX > viewportWidth - config.activationDistance) {
	                                // If the mouse is on the right of the viewport within the activation distance.
	                                scrollX = config.scrollDistance;
	                            }
	                        }

	                        if (config.verticalScroll) {
	                            // If vertical scrolling is active.
	                            if (lastMouseEvent.clientY < config.activationDistance) {
	                                // If the mouse is on the top of the viewport within the activation distance.
	                                scrollY = -config.scrollDistance;
	                            } else if (lastMouseEvent.clientY > viewportHeight - config.activationDistance) {
	                                // If the mouse is on the bottom of the viewport within the activation distance.
	                                scrollY = config.scrollDistance;
	                            }
	                        }

	                        if (scrollX !== 0 || scrollY !== 0) {
	                            // Record the current scroll position.
	                            var currentScrollLeft = $window.pageXOffset || $document[0].documentElement.scrollLeft;
	                            var currentScrollTop = $window.pageYOffset || $document[0].documentElement.scrollTop;

	                            // Remove the transformation from the element, scroll the window by the scroll distance
	                            // record how far we scrolled, then reapply the element transformation.
	                            var elementTransform = element.css('transform');
	                            element.css('transform', 'initial');

	                            $window.scrollBy(scrollX, scrollY);

	                            var horizontalScrollAmount = ($window.pageXOffset || $document[0].documentElement.scrollLeft) - currentScrollLeft;
	                            var verticalScrollAmount = ($window.pageYOffset || $document[0].documentElement.scrollTop) - currentScrollTop;

	                            element.css('transform', elementTransform);

	                            lastMouseEvent.pageX += horizontalScrollAmount;
	                            lastMouseEvent.pageY += verticalScrollAmount;

	                            $rootScope.$emit('draggable:_triggerHandlerMove', lastMouseEvent);
	                        }
	                    });
	                };

	                var clearInterval = function clearInterval() {
	                    animationIsOn = false;
	                };

	                scope.$on('draggable:start', function (event, obj) {
	                    // Ignore this event if it's not for this element.
	                    if (obj.element[0] !== element[0]) return;

	                    if (!animationIsOn) createInterval();
	                });

	                scope.$on('draggable:end', function (event, obj) {
	                    // Ignore this event if it's not for this element.
	                    if (obj.element[0] !== element[0]) return;

	                    if (animationIsOn) clearInterval();
	                });

	                scope.$on('draggable:move', function (event, obj) {
	                    // Ignore this event if it's not for this element.
	                    if (obj.element[0] !== element[0]) return;

	                    lastMouseEvent = obj.event;
	                });
	            }
	        };
	    }]);
	};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _modularEidtType = __webpack_require__(97);

	var _modularEidtType2 = _interopRequireDefault(_modularEidtType);

	var _modularEidtForm = __webpack_require__(99);

	var _modularEidtForm2 = _interopRequireDefault(_modularEidtForm);

	var _locatOpenTpl = __webpack_require__(101);

	var _locatOpenTpl2 = _interopRequireDefault(_locatOpenTpl);

	var _formWebUpload = __webpack_require__(103);

	var _formWebUpload2 = _interopRequireDefault(_formWebUpload);

	var _formSimditor = __webpack_require__(105);

	var _formSimditor2 = _interopRequireDefault(_formSimditor);

	var _service = __webpack_require__(106);

	var _service2 = _interopRequireDefault(_service);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	exports.default = function () {
		(0, _modularEidtType2.default)();
		(0, _modularEidtForm2.default)();
		(0, _locatOpenTpl2.default)();
		(0, _formWebUpload2.default)();
		(0, _formSimditor2.default)();
		(0, _service2.default)();
	};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _lodash = __webpack_require__(94);

	var _ = _interopRequireWildcard(_lodash);

	var _Redux = __webpack_require__(93);

	var _modularEidtType = __webpack_require__(98);

	var _modularEidtType2 = _interopRequireDefault(_modularEidtType);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _interopRequireWildcard(obj) {
		if (obj && obj.__esModule) {
			return obj;
		} else {
			var newObj = {};if (obj != null) {
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
				}
			}newObj.default = obj;return newObj;
		}
	}

	exports.default = function () {
		var app = (0, _Redux.readRedux)({ type: "APP" });
		app.directive('modularEidtType', ["$timeout", "$uibModal", "$log", "$document", "directive.modular.services", function ($timeout, $uibModal, $log, $document, $modularServices) {
			return {
				restrict: 'AE',
				scope: {
					item: "=item"
				},
				template: _modularEidtType2.default,
				link: function link($scope, iElement, iAttrs) {
					var _this = {};
					// 继承服务
					$modularServices.call(_this, $scope, {});
					// 续集服务
					_this.$setOnDrop();
					_this.$setOnDrag();
					_this.$setLocationbar();
					_this.$setDetailContent();
				}
			};
		}]);
	};

/***/ }),
/* 98 */
/***/ (function(module, exports) {

	module.exports = "<div class=\"container-fluid  modular-edit container-fluid\">\r\n  <div class=\"row\" style=\"padding: 20px 0; border-bottom: solid 1px #eee; background:#fafafa; \">\r\n    <div class=\"col-xs-2 col-sm-2\">&nbsp;</div>\r\n    <div class=\"col-xs-10 col-sm-10\">\r\n      <div class=\"row\">\r\n      <button type=\"button\" class=\"btn btn-primary\" data-ng-click=\"onLocatSelected();\">历史记录 <span class=\"badge\">{{ locationbar.length }}</span></button>      \r\n      <button type=\"button\" class=\"btn btn-primary\" data-ng-click=\"onLocatFallback();\"  data-ng-class=\"{'disabled':isfallback}\" >后退</button>\r\n      <button type=\"button\" class=\"btn btn-primary\" data-ng-click=\"onLocatForward();\"  data-ng-class=\"{'disabled':isforward}\" >前进 </button>\r\n      <button type=\"button\" class=\"btn btn-primary\">发布</button>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <div class=\"row\" >\r\n    <div class=\"col-xs-2 col-sm-2\">\r\n      <ul class=\"row mar-pad modular-type-list\">\r\n        <li \r\n          data-ng-repeat=\"data in item\" \r\n          ng-drag=\"true\" \r\n          ng-drag-data=\"data\" \r\n          data-allow-transform=\"true\"\r\n          class=\"mar-pad col-xs-4 col-sm-4\" >    \r\n          <i class=\"modular-icon\">{{data.icon || data.img }}</i>\r\n          {{data.name}}\r\n        </li>  \r\n      </ul>\r\n    </div>\r\n    <div\r\n      data-ng-class=\"{\r\n      'col-xs-6':eidtForm,\r\n      'col-sm-6':eidtForm,\r\n      'col-sm-10':!eidtForm,\r\n      'col-sm-10':!eidtForm\r\n      }\"\r\n     >\r\n      <div class=\"modular-center row\">\r\n        <div class=\"modular-phone phone-6s\" ng-drop=\"true\" ng-drop-success=\"onDropComplete($data,$event)\" data-ng-init=\"isRemove = [];\" >\r\n\r\n          <div class=\"modular-conentlist\"  \r\n           data-ng-class=\"{'active':data.active}\"\r\n           data-ng-repeat=\"data in eidtItem\" \r\n           data-ng-init=\"isRemove[$index] = false;\" \r\n           ng-drop=\"true\" \r\n           ng-drop-success=\"onDragSuccess($index, $data,$event)\" \r\n           data-ng-mouseover=\"isRemove[$index] = true\" \r\n           data-ng-mouseleave=\"isRemove[$index] = false\" \r\n           data-ng-click=\"onDropEditForm(data)\"\r\n           >\r\n              <i class=\"modular-remove\" \r\n              data-ng-click=\"onDropRemove(data);\"             \r\n              data-ng-show=\"isRemove[$index]\"\r\n              >x</i>\r\n              <div ng-drag=\"true\" ng-drag-data=\"data\" ng-class=\"data.name\">\r\n                <div ng-bind-html =\"detailContent(data.template)\"></div>\r\n                  {{data}}\r\n              </div>\r\n          </div>\r\n          <br>\r\n          --------------编辑后的数据--------------\r\n           <br>\r\n          <textarea>{{eidtItem}}</textarea>\r\n          \r\n        </div>\r\n        <p class=\"modular-center-bg\" data-ng-click=\"onDropEidtFormHide();\"></p>\r\n      </div>\r\n\r\n    </div>\r\n    <div class=\"col-xs-4 col-sm-4 modular-form\" data-ng-show=\"eidtForm\" >\r\n      <modular-eidt-form data-item=\"eidtForm\"  data-locationbar = \"getLocationbar\" >\r\n      </modular-eidt-form> \r\n    </div>\r\n  </div>\r\n</div>";

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _lodash = __webpack_require__(94);

	var _ = _interopRequireWildcard(_lodash);

	var _Redux = __webpack_require__(93);

	var _modularEidtForm = __webpack_require__(100);

	var _modularEidtForm2 = _interopRequireDefault(_modularEidtForm);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _interopRequireWildcard(obj) {
		if (obj && obj.__esModule) {
			return obj;
		} else {
			var newObj = {};if (obj != null) {
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
				}
			}newObj.default = obj;return newObj;
		}
	}

	exports.default = function () {
		var app = (0, _Redux.readRedux)({ type: "APP" });
		app.directive('modularEidtForm', ["$timeout", function ($timeout) {
			return {
				restrict: 'AE',
				scope: {
					item: "=item",
					getLocationbar: "=locationbar"
				},
				template: _modularEidtForm2.default,
				link: function link($scope, iElement, iAttrs) {}
			};
		}]);
	};

/***/ }),
/* 100 */
/***/ (function(module, exports) {

	module.exports = "\r\n<ul class=\"modular-form-tab row\" data-ng-init=\"modularFormTab = 'eidt'\">\r\n\t<li class=\"col-xs-6 col-sm-6 \" \r\n\tdata-ng-class=\"{'active':modularFormTab=='eidt'}\" \r\n\tdata-ng-click=\"modularFormTab = 'eidt'\"\r\n\t>\r\n\t\t<a href=\"\">内容</a>\r\n\t</li>\r\n\t<li class=\"col-xs-6 col-sm-6\" \r\n\tdata-ng-class=\"{'active':modularFormTab=='style'}\" \r\n\tdata-ng-click=\"modularFormTab = 'style'\"\r\n\t>\r\n\t\t<a href=\"javascript:;\">样式</a>\r\n\t</li>\r\n</ul>\r\n\r\n<div class=\"modular-form-center\">\r\n\t<div class=\"modular-form-eidt\" data-ng-if=\"modularFormTab == 'eidt'\">\r\n\t\t{{item}}\r\n\t\t<form action=\"\">\r\n\t\t\t<input type=\"text\" data-ng-model=\"item.icon\" placeholder=\"\" data-my-blur=\"getLocationbar('内容编辑【'+item.name+'】');\" >\r\n\t\t\t<input type=\"text\" data-ng-model=\"item.name\" placeholder=\"\" data-my-blur=\"getLocationbar('内容编辑【'+item.name+'】');\" >\r\n\t\t\t<modular-form-web-upload class=\"btn btn-primary\" data-item=\"{}\"  >上传图片</modular-form-web-upload>\r\n\t\t\t<modular-simditor data-ng-model=\"item.template\" data-ng-if=\"item.template\" data-blur=\"getLocationbar\" data-model=\"item.template\">\r\n\t\t\t\t\r\n\t\t\t</modular-simditor>\r\n\t\t</form>\r\n\t</div>\r\n\t<div class=\"modular-form-style\" data-ng-if=\"modularFormTab == 'style'\">\r\n\t\t{{item}}\r\n\t</div>\r\n</div>\r\n\r\n";

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _lodash = __webpack_require__(94);

	var _ = _interopRequireWildcard(_lodash);

	var _Redux = __webpack_require__(93);

	var _locatOpenTpl = __webpack_require__(102);

	var _locatOpenTpl2 = _interopRequireDefault(_locatOpenTpl);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _interopRequireWildcard(obj) {
		if (obj && obj.__esModule) {
			return obj;
		} else {
			var newObj = {};if (obj != null) {
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
				}
			}newObj.default = obj;return newObj;
		}
	}

	exports.default = function () {
		var app = (0, _Redux.readRedux)({ type: "APP" });
		app.factory('directive.modular.ui', ["$uibModal", "$rootScope", function ($uibModal, $rootScope) {
			return {
				locatOpen: function locatOpen(item, eidtItem) {
					return $uibModal.open({
						animation: true,
						ariaLabelledBy: 'modal-title-top',
						ariaDescribedBy: 'modal-body-top',
						scope: $rootScope.$new(true),
						template: _locatOpenTpl2.default,
						controller: "directive.modular.ui.locat.open",
						resolve: {
							$params: function $params() {
								return {
									item: item,
									eidtItem: eidtItem
								};
							}
						}
					});
				}
			};
		}]).controller('directive.modular.ui.locat.open', ["$http", '$params', "$scope", "directive.modular.services", function ($http, $params, $scope, $modularServices) {
			var _this = {};
			// 继承服务
			//$modularServices.call(_this, $scope, {});

			$scope.openitem = $params.item;

			// 选中历史记录
			$scope.onLocatSelected = function (data, $index) {

				init();
				data.radio = true;
				$scope.$close(angular.copy($scope.openitem));
				(0, _Redux.getRedux)(true, { type: "MODULAR_UI_OPEN" });
			};

			var init = function init() {
				_.forEach($scope.openitem, function (val, key) {
					delete val.radio;
				});
			};
		}]);
	};

/***/ }),
/* 102 */
/***/ (function(module, exports) {

	module.exports = "\r\n<div class=\"box-body \">\r\n  <table class=\"table table-hover modular-table-hover\">\r\n      <tbody>\r\n        <tr>\r\n          <th>#</th>\r\n          <th>操作类型</th>\r\n          <th>操作时间</th>\r\n          <th>组件数量</th>\r\n        </tr>\r\n        <tr  data-ng-repeat=\"item in openitem\" data-ng-click=\"onLocatSelected(item,$index);\" data-ng-if=\"openitem.length>0\" >\r\n          <td>\r\n          \t<i class=\"modular_radio\" data-ng-class=\"{'checked':!!item.radio}\"></i>\r\n          </td>\r\n          <td>{{item.typeName}}</td>\r\n          <td>\r\n            {{ item.time | date:' HH:mm:ss '}}\r\n          </td>\r\n          <td>\r\n          \t<span class=\"label label-info\">{{item.data.length}}</span>\r\n          </td>\r\n        </tr>\r\n\r\n       \t<tr data-ng-if=\" openitem.length == 0\">\r\n       \t\t <td  colspan =\"5\" class=\"text-center\">\r\n    \t   \t\t暂无操作记录！\r\n    \t   \t</td>\r\n       \t</tr>\r\n    </tbody>\r\n  </table>\r\n</div>\r\n\r\n<style type=\"text/css\">\r\n  .modular-table-hover>tbody>tr>td, .modular-table-hover>tbody>tr>th, .modular-table-hover>tfoot>tr>td, .modular-table-hover>tfoot>tr>th, .modular-table-hover>thead>tr>td, .modular-table-hover>thead>tr>th{\r\n    border-top: 0;\r\n    border-bottom: solid 1px #ddd;\r\n  }\r\n</style>";

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
			value: true
	});

	var _lodash = __webpack_require__(94);

	var _ = _interopRequireWildcard(_lodash);

	var _Redux = __webpack_require__(93);

	var _formWebUpload = __webpack_require__(104);

	var _formWebUpload2 = _interopRequireDefault(_formWebUpload);

	function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : { default: obj };
	}

	function _interopRequireWildcard(obj) {
			if (obj && obj.__esModule) {
					return obj;
			} else {
					var newObj = {};if (obj != null) {
							for (var key in obj) {
									if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
					}newObj.default = obj;return newObj;
			}
	}

	exports.default = function () {
			var app = (0, _Redux.readRedux)({
					type: "APP"
			});

			app.directive('modularFormWebUpload', ["$timeout", "$uibModal", "$log", "$document", "$rootScope", function ($timeout, $uibModal, $log, $document, $rootScope) {
					return {
							restrict: 'AE',
							scope: {
									item: "=item"
							},
							template: "",
							link: function link($scope, iElement, iAttrs) {
									console.log(iElement);
									iElement.click(function () {
											$uibModal.open({
													animation: true,
													ariaLabelledBy: 'modal-title-top',
													ariaDescribedBy: 'modal-body-top',
													scope: $rootScope.$new(true),
													template: _formWebUpload2.default,
													size: "lg",
													controller: "form.web.upload.controller.open",
													resolve: {
															$params: function $params() {
																	return {
																			item: $scope.item
																	};
															}
													}
											});
									});
							}
					};
			}]);

			app.controller('form.web.upload.controller.open', ['$scope', "$http", "$uibModal", "$location", "$timeout", 'form.web.upload.service', function ($scope, $http, $uibModal, $location, $timeout, $uploadService) {
					var _this = {};
					$timeout(function () {
							// 继承服务
							$uploadService.call(_this, $scope, {});
					});
					console.log(_this);
			}]);

			app.factory('form.web.upload.service', ["$uibModal", "$rootScope", function ($uibModal, $rootScope) {
					function Service($scope, options) {
							var _$scope = $scope;
							var _options = options;
							var _this = this;

							var $ = jQuery,

							// just in case. Make sure it's not an other libaray.

							$wrap = $('#uploader'),


							// 图片容器
							$queue = $('<ul class="filelist"></ul>').appendTo($wrap.find('.queueList')),


							// 状态栏，包括进度和控制按钮
							$statusBar = $wrap.find('.statusBar'),


							// 文件总体选择信息。
							$info = $statusBar.find('.info'),


							// 上传按钮
							$upload = $wrap.find('div.uploadBtn'),


							// 没选择文件之前的内容。
							$placeHolder = $wrap.find('.placeholder'),


							// 总体进度条
							$progress = $statusBar.find('.progress').hide(),


							// 添加的文件数量
							fileCount = 0,


							// 添加的文件总大小
							fileSize = 0,


							// 优化retina, 在retina下这个值是2
							ratio = window.devicePixelRatio || 1,


							// 缩略图大小
							thumbnailWidth = 110 * ratio,
							    thumbnailHeight = 110 * ratio,


							// 可能有pedding, ready, uploading, confirm, done.
							state = 'pedding',


							// 所有文件的进度信息，key为file id
							percentages = {},
							    supportTransition = function () {
									var s = document.createElement('p').style,
									    r = 'transition' in s || 'WebkitTransition' in s || 'MozTransition' in s || 'msTransition' in s || 'OTransition' in s;
									s = null;
									return r;
							}(),


							// WebUploader实例
							uploader;

							if (!WebUploader.Uploader.support()) {
									alert('Web Uploader 不支持您的浏览器！如果你使用的是IE浏览器，请尝试升级 flash 播放器');
									throw new Error('WebUploader does not support the browser you are using.');
							}

							// 实例化
							uploader = WebUploader.create({
									pick: {
											id: '#filePicker',
											label: '点击选择图片'
									},
									dnd: '#uploader .queueList',
									paste: document.body,

									accept: {
											title: 'Images',
											extensions: 'gif,jpg,jpeg,bmp,png',
											mimeTypes: 'image/*'
									},

									// swf文件路径
									swf: 'http://cdn.staticfile.org/webuploader/0.1.0/Uploader.swf',

									disableGlobalDnd: true,

									chunked: true,
									// server: 'http://webuploader.duapp.com/server/fileupload.php',
									server: 'http://result.eolinker.com/B7hctqTb702bbc604f0da172f3daace6519bd929e93fae2?uri=api/modular/webupload',
									fileNumLimit: 300,
									fileSizeLimit: 5 * 1024 * 1024, // 200 M
									fileSingleSizeLimit: 1 * 1024 * 1024 // 50 M
							});

							// 添加“添加文件”的按钮，
							uploader.addButton({
									id: '#filePicker2',
									label: '继续添加'
							});

							// 当有文件添加进来时执行，负责view的创建
							function addFile(file) {
									var $li = $('<li id="' + file.id + '">' + '<p class="title">' + file.name + '</p>' + '<p class="imgWrap"></p>' + '<p class="progress"><span></span></p>' + '</li>'),
									    $btns = $('<div class="file-panel">' + '<span class="cancel">删除</span>' + '<span class="rotateRight">向右旋转</span>' + '<span class="rotateLeft">向左旋转</span></div>').appendTo($li),
									    $prgress = $li.find('p.progress span'),
									    $wrap = $li.find('p.imgWrap'),
									    $info = $('<p class="error"></p>'),
									    text = "",
									    showError = function showError(code) {
											switch (code) {
													case 'exceed_size':
															text = '文件大小超出';
															break;

													case 'interrupt':
															text = '上传暂停';
															break;

													default:
															text = '上传失败，请重试';
															break;
											}

											$info.text(text).appendTo($li);
									};

									if (file.getStatus() === 'invalid') {
											showError(file.statusText);
									} else {
											// @todo lazyload
											$wrap.text('预览中');
											uploader.makeThumb(file, function (error, src) {
													if (error) {
															$wrap.text('不能预览');
															return;
													}

													var img = $('<img src="' + src + '">');
													$wrap.empty().append(img);
											}, thumbnailWidth, thumbnailHeight);

											percentages[file.id] = [file.size, 0];
											file.rotation = 0;
									}

									file.on('statuschange', function (cur, prev) {
											if (prev === 'progress') {
													$prgress.hide().width(0);
											} else if (prev === 'queued') {
													$li.off('mouseenter mouseleave');
													$btns.remove();
											}

											// 成功
											if (cur === 'error' || cur === 'invalid') {
													console.log(file.statusText);
													showError(file.statusText);
													percentages[file.id][1] = 1;
											} else if (cur === 'interrupt') {
													showError('interrupt');
											} else if (cur === 'queued') {
													percentages[file.id][1] = 0;
											} else if (cur === 'progress') {
													$info.remove();
													$prgress.css('display', 'block');
											} else if (cur === 'complete') {
													$li.addClass("active").append('<span class="success"></span>');
											}

											$li.removeClass('state-' + prev).addClass('state-' + cur);
									});

									$li.on('mouseenter', function () {
											$btns.stop().animate({ height: 30 });
									});

									$li.on('mouseleave', function () {
											$btns.stop().animate({ height: 0 });
									});

									$btns.on('click', 'span', function () {
											var index = $(this).index(),
											    deg;

											switch (index) {
													case 0:
															uploader.removeFile(file);
															return;

													case 1:
															file.rotation += 90;
															break;

													case 2:
															file.rotation -= 90;
															break;
											}

											if (supportTransition) {
													deg = 'rotate(' + file.rotation + 'deg)';
													$wrap.css({
															'-webkit-transform': deg,
															'-mos-transform': deg,
															'-o-transform': deg,
															'transform': deg
													});
											} else {
													$wrap.css('filter', 'progid:DXImageTransform.Microsoft.BasicImage(rotation=' + ~~(file.rotation / 90 % 4 + 4) % 4 + ')');
											}
									});

									$li.appendTo($queue);
							}

							// 负责view的销毁
							function removeFile(file) {
									var $li = $('#' + file.id);

									delete percentages[file.id];
									updateTotalProgress();
									$li.off().find('.file-panel').off().end().remove();
							}

							function updateTotalProgress() {
									var loaded = 0,
									    total = 0,
									    spans = $progress.children(),
									    percent;

									$.each(percentages, function (k, v) {
											total += v[0];
											loaded += v[0] * v[1];
									});

									percent = total ? loaded / total : 0;

									spans.eq(0).text(Math.round(percent * 100) + '%');
									spans.eq(1).css('width', Math.round(percent * 100) + '%');
									updateStatus();
							}

							function updateStatus() {
									var text = '',
									    stats;

									if (state === 'ready') {
											text = '选中' + fileCount + '张图片，共' + WebUploader.formatSize(fileSize) + '。';
									} else if (state === 'confirm') {
											stats = uploader.getStats();
											if (stats.uploadFailNum) {
													text = '已成功上传' + stats.successNum + '张照片至XX相册，' + stats.uploadFailNum + '张照片上传失败，<a class="retry" href="#">重新上传</a>失败图片或<a class="ignore" href="#">忽略</a>';
											}
									} else {
											stats = uploader.getStats();
											text = '共' + fileCount + '张（' + WebUploader.formatSize(fileSize) + '），已上传' + stats.successNum + '张';

											if (stats.uploadFailNum) {
													text += '，失败' + stats.uploadFailNum + '张';
											}
									}

									$info.html(text);
							}

							function setState(val) {
									var file, stats;

									if (val === state) {
											return;
									}

									$upload.removeClass('state-' + state);
									$upload.addClass('state-' + val);
									state = val;

									switch (state) {
											case 'pedding':
													$placeHolder.removeClass('element-invisible');
													$queue.parent().removeClass('filled');
													$queue.hide();
													$statusBar.addClass('element-invisible');
													//uploader.refresh();
													break;

											case 'ready':
													$placeHolder.addClass('element-invisible');
													$('#filePicker2').removeClass('element-invisible');
													$queue.parent().addClass('filled');
													$queue.show();
													$statusBar.removeClass('element-invisible');
													uploader.refresh();
													break;

											case 'uploading':
													//$( '#filePicker2' ).addClass( 'element-invisible' );
													$progress.show();
													$upload.text('暂停上传');
													break;

											case 'paused':
													$progress.show();
													$upload.text('继续上传');
													break;

											case 'confirm':
													$progress.hide();
													$upload.text('开始上传');
													//.addClass( 'disabled' );

													stats = uploader.getStats();
													if (stats.successNum && !stats.uploadFailNum) {
															setState('finish');
															return;
													}
													break;
											case 'finish':
													stats = uploader.getStats();

													if (stats.successNum) {
															alert('上传成功');
													} else {
															// 没有成功的图片，重设
															state = 'done';
															location.reload();
													}
													break;
									}

									updateStatus();
							}

							uploader.onUploadProgress = function (file, percentage) {
									var $li = $('#' + file.id),
									    $percent = $li.find('.progress span');

									$percent.css('width', percentage * 100 + '%');
									percentages[file.id][1] = percentage;
									updateTotalProgress();
							};

							uploader.onFileQueued = function (file) {
									fileCount++;
									fileSize += file.size;

									if (fileCount === 1) {
											$placeHolder.addClass('element-invisible');
											$statusBar.show();
									}

									addFile(file);
									setState('ready');
									updateTotalProgress();
							};

							uploader.onFileDequeued = function (file) {
									fileCount--;
									fileSize -= file.size;

									if (!fileCount) {
											setState('pedding');
									}

									removeFile(file);
									updateTotalProgress();
							};

							uploader.on('all', function (type) {
									var stats;
									switch (type) {
											case 'uploadFinished':
													setState('confirm');
													break;

											case 'startUpload':
													setState('uploading');
													break;

											case 'stopUpload':
													setState('paused');
													break;

									}
							});

							uploader.onError = function (code) {
									alert('Eroor: ' + code);
							};

							$upload.on('click', function () {
									if ($(this).hasClass('disabled')) {
											return false;
									}

									if (state === 'ready') {
											uploader.upload();
									} else if (state === 'paused') {
											uploader.upload();
									} else if (state === 'uploading') {
											uploader.stop();
									}
							});

							$info.on('click', '.retry', function () {
									uploader.retry();
							});

							$info.on('click', '.ignore', function () {
									alert('todo');
							});

							$upload.addClass('state-' + state);
							updateTotalProgress();
							this.$upload = $upload;
					}
					return function ($scope, options) {
							if (_.isNull($scope) || _.isUndefined($scope)) {
									return Service;
							} else {
									Service.call(this, $scope, options);
									return this;
							}
					};
			}]);
	};

/***/ }),
/* 104 */
/***/ (function(module, exports) {

	module.exports = "<div id=\"uploader\"> \r\n    <ul class=\"modular-upload-tab\">\r\n        <li class=\"active\"><a href=\"javascript:;\">我的图片</a></li>\r\n        <li><a href=\"javascript:;\">素材库</a></li>\r\n    </ul>\r\n    <div  class=\"wu-example\">    \r\n        <div class=\"statusBar\" style=\"display:none;\">\r\n            <div class=\"progress\">\r\n                <span class=\"text\">0%</span>\r\n                <span class=\"percentage\"></span>\r\n            </div><div class=\"info\"></div>\r\n            <div class=\"btns\">\r\n                <div id=\"filePicker2\"></div><div class=\"uploadBtn\">开始上传</div>\r\n            </div>\r\n        </div>\r\n        <div class=\"queueList\">\r\n            <div id=\"dndArea\" class=\"placeholder\">\r\n                <div id=\"filePicker\"></div>\r\n                <p>或将照片拖到这里，单次最多可选300张</p>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <div class=\"modular-upload-list\">   \r\n        <label>已选图片</label>\r\n        <p class=\"img\" data-ng-repeat=\"data in item\" ><img src=\"{{data.url}}\" alt=\"\"></p>\r\n    </div>\r\n    <div class=\"modular-upload-bottom\">\r\n        <div class=\"btns\">\r\n                <a class=\"webuploader-pick\">取消添加</a><a class=\"uploadBtn\">确认添加</a>\r\n            </div>\r\n    </div>\r\n</div>";

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _lodash = __webpack_require__(94);

	var _ = _interopRequireWildcard(_lodash);

	var _Redux = __webpack_require__(93);

	function _interopRequireWildcard(obj) {
		if (obj && obj.__esModule) {
			return obj;
		} else {
			var newObj = {};if (obj != null) {
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
				}
			}newObj.default = obj;return newObj;
		}
	}

	exports.default = function () {
		var app = (0, _Redux.readRedux)({
			type: "APP"
		});

		app.directive('modularSimditor', ["$timeout", "$uibModal", "$log", "$document", "$rootScope", '$sce', function ($timeout, $uibModal, $log, $document, $rootScope, $sce) {
			return {
				restrict: 'AE',
				scope: {
					blur: "=blur",
					model: "=model"
				},
				template: "",
				require: '^ngModel',
				link: function link($scope, iElement, iAttrs, ngModel) {
					var Eid = "Eid" + Math.round(Math.random() * 1000);
					$(iElement).attr("id", Eid);
					var E = window.wangEditor;
					var editor = new E("#" + Eid);

					// 或者 var editor = new E( document.getElementById('editor') )
					editor.customConfig.menus = ['head', // 标题
					'bold', // 粗体
					'italic', // 斜体
					'underline', // 下划线
					'strikeThrough', // 删除线
					'foreColor', // 文字颜色
					'backColor', // 背景颜色
					'link', // 插入链接
					// 'list',  // 列表
					'justify', // 对齐方式
					// 'quote',  // 引用
					// 'emoticon',  // 表情
					'image'];
					editor.customConfig.colors = ['#000000', '#333333', '#666666', '#999999', '#cccccc', '#dddddd', '#eeeeee', '#ffffff', '#1c487f', '#4d80bf', '#c24f4a', '#8baa4a', '#7b5ba1', '#46acc8', '#f9963b', '#337ab7'];

					editor.customConfig.zIndex = 1;

					editor.customConfig.onchange = function (html) {
						// 设置视图和调用 apply$sce
						$scope.$apply(function () {
							ngModel.$setViewValue(html);
						});
					};
					editor.customConfig.onblur = function (html) {
						$scope.blur('内容编辑');
					};
					editor.create();

					$scope.$watch("model", function () {
						editor.txt.html(ngModel.$viewValue);
					});
				}
			};
		}]);
	};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
		return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
		return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	var _lodash = __webpack_require__(94);

	var _ = _interopRequireWildcard(_lodash);

	var _Redux = __webpack_require__(93);

	var _index = __webpack_require__(107);

	var _index2 = _interopRequireDefault(_index);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _interopRequireWildcard(obj) {
		if (obj && obj.__esModule) {
			return obj;
		} else {
			var newObj = {};if (obj != null) {
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
				}
			}newObj.default = obj;return newObj;
		}
	}

	exports.default = function () {
		var app = (0, _Redux.readRedux)({ type: "APP" });
		app.factory('directive.modular.services', ["$http", "$log", "$timeout", "directive.modular.ui", "$sce", function ($http, $log, $timeout, $modularUi, $sce) {
			function Service($scope, options) {

				// 续集模板编辑api
				var pmcApi = _index2.default.phpApi.API.com.php.pmc.IndexController($http);

				var _$scope = $scope;
				var _options = options;
				var _this = this;

				// 解决追加薪组件与切换组件位置重复应用BUG
				var centerAnchor = true;

				// 设置默认数据/提交数据接口
				_$scope.eidtItem = [];

				// 右侧from编辑数据
				_$scope.eidtForm = false;

				// 历史记录存储
				_$scope.locationbar = [];

				// 表示左边拖动数据
				_.forEach(_$scope.item, function (val, key) {
					val.tagging = true;
				});

				/*
	    * 拉取数据默认数据
	    */
				pmcApi.getModularViewList(50, function (data) {
					_$scope.eidtItem = data.item;
				});

				/*
	    * 拖拽插件
	    */
				_this.$setOnDrop = function () {

					// 追加组件提交
					_$scope.onDropComplete = function (data, evt) {
						// console.log("127", "$scope", "onDropComplete", data, evt);
						if (!data) return false;
						var index = _$scope.eidtItem.indexOf(data);

						$timeout(function () {
							var copyData = angular.copy(data);
							if (copyData.tagging && centerAnchor) {
								delete copyData.tagging;
								_$scope.eidtItem.push(copyData);
								_$scope.onDropEditForm(_.last(_$scope.eidtItem));
								_$scope.getLocationbar('新增模块【' + copyData.name + '】');
							}
							centerAnchor = true;
						}, 10);
					};

					// 选择编辑对象
					_$scope.onDropEditForm = function (data) {
						_$scope.eidtForm = false;
						_$scope.eidtForm = data;
						if (data.active) {
							data.active = true;
							//_$scope.onDropEidtFormHide();
						} else {
							_.each(_$scope.eidtItem, function (value, key) {
								delete value.active;
							});
							data.active = true;
						}
					};

					// 删除数据
					_$scope.onDropRemove = function (data) {
						_.remove(_$scope.eidtItem, function (n) {
							return n == data;
						});
						if (_$scope.eidtForm == data) {
							_$scope.onDropEidtFormHide();
						}
						_$scope.getLocationbar('删除模块【' + data.name + '】');
					};

					// 消耗编辑数据
					_$scope.onDropEidtFormHide = function () {

						_.each(_$scope.eidtItem, function (value, key) {
							delete value.active;
						});

						_$scope.eidtForm = false;
					};
				};

				/*
	    *	绑定拖拽状态与事件
	    */
				_this.$setOnDrag = function () {

					// 位置切换成功回调
					_$scope.onDragSuccess = function (index, data, evt) {
						// console.log("133", "_$scope", "onDragSuccess", "", evt);
						centerAnchor = false;
						if (data.tagging) {
							data = angular.copy(data);
							delete data.tagging;
							_$scope.eidtItem.splice(index, 0, data);
							_$scope.onDropEditForm(_$scope.eidtItem[index]);
						} else {
							var otherdata = _$scope.eidtItem[index];
							var otherIndex = _$scope.eidtItem.indexOf(data);
							_$scope.eidtItem[index] = data;
							_$scope.eidtItem[otherIndex] = otherdata;

							_$scope.onDropEditForm(_$scope.eidtItem[index]);
						}

						_$scope.getLocationbar('位置移动【' + data.name + '<=>' + _$scope.eidtItem[index].name + '】');
					};

					// 绑定拖拽状态与事件
					var onDraggableEvent = function onDraggableEvent(evt, data) {

						switch (evt.name) {
							case 'draggable:move':
								// console.log("128", "onDraggableEvent", evt, data);
								$(data.element).addClass('drag-move').parent().addClass('drag-move');
								break;
							case 'draggable:end':
								$(data.element).addClass('drag-move').parent().removeClass('drag-move');
								break;
							default:
								// statements_def
								break;
						}
					};

					_$scope.$on('draggable:start', onDraggableEvent);
					_$scope.$on('draggable:move', onDraggableEvent);
					_$scope.$on('draggable:end', onDraggableEvent);
				};

				/*
	    *
	    */
				_this.$setDetailContent = function () {
					$scope.detailContent = function (content) {
						return $sce.trustAsHtml(content);
					};
				};

				//历史记录
				_this.$setLocationbar = function () {

					// 存储初始化数据
					var locatTtem = angular.copy(_$scope.eidtItem);
					_$scope.isfallback = true;
					_$scope.isforward = true;
					// 设置历史记录
					var _$setLocationbar = function _$setLocationbar(data, key2) {
						_$scope.eidtItem = data;
						// 回显示已经选中的元素
						_.forEach(_$scope.eidtItem, function (val, key) {
							if (val.active) {
								_$scope.onDropEditForm(val);
							}
						});
						// 写入历史进退按钮状态
						_$scope.isfallback = key2 <= 0;
						_$scope.isforward = key2 >= _$scope.locationbar.length - 1;
					};

					// 数据比对递归算法
					var _$isLoctionbarRet = true;
					var _$isLoctionbar = function _$isLoctionbar(data1, data2) {

						_.forEach(data1, function (val, key) {
							if (!_$isLoctionbarRet) return false;
							if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == "object") {
								_$isLoctionbar(val, data2[key]);
							} else if (val == data2[key] || key == "radio") {
								_$isLoctionbarRet = true;
							} else {
								_$isLoctionbarRet = false;
							}
						});
						return _$isLoctionbarRet;
					};

					// 写入历史记录
					_$scope.getLocationbar = function (typeName) {
						if (_$scope.eidtItem != []) {
							var isRadio = false;

							if (_$scope.locationbar.length > 0) {
								_$isLoctionbarRet = true;
								if (_$isLoctionbar(_.last(_$scope.locationbar).data, angular.copy(_$scope.eidtItem))) {
									return false;
								}
							}

							_.forEach(_$scope.locationbar, function (val, key) {
								isRadio = val.radio ? true : isRadio;
								if (val.radio) {
									_.remove(_$scope.locationbar, function (n, k) {
										return k > key;
									});
									delete val.radio;
									return false;
								}
							});

							_$scope.locationbar.push({
								$index: _$scope.locationbar.length,
								typeName: typeName || "数据修改",
								time: new Date(),
								data: angular.copy(_$scope.eidtItem),
								radio: true
							});

							_$scope.isfallback = false;
							_$scope.isforward = true;
						}
					};

					// 后退
					_$scope.onLocatFallback = function () {
						var $ret = true;
						_.forEach(_$scope.locationbar, function (val, key) {
							if (val.radio) {
								delete val.radio;
								$ret = key - 1 <= 0 ? 0 : key - 1;
								_$scope.locationbar[$ret].radio = true;
								_$setLocationbar(_$scope.locationbar[$ret].data, $ret);
								return false;
							}
						});
					};

					// 前进
					_$scope.onLocatForward = function () {
						var $ret = true;
						_.forEach(_$scope.locationbar, function (val, key) {
							if (val.radio) {
								delete val.radio;
								$ret = key + 1 >= _$scope.locationbar.length - 1 ? _$scope.locationbar.length - 1 : key + 1;
								_$scope.locationbar[$ret].radio = true;
								_$setLocationbar(_$scope.locationbar[$ret].data, $ret);
								return false;
							}
						});
					};

					// 选中历史记录
					_$scope.onLocatSelected = function (data) {
						$modularUi.locatOpen(_$scope.locationbar, _$scope.eidtItem).result.then(function (selectedItem) {
							_$scope.locationbar = selectedItem;
							$timeout(function () {
								_.forEach(_$scope.locationbar, function (val, key) {
									if (val.radio) {
										_$setLocationbar(val.data, key);
									};
								});
							}, 300);
						});
					};
				};
			};

			return function ($scope, options) {
				if (_.isNull($scope) || _.isUndefined($scope)) {
					return Service;
				} else {
					Service.call(this, $scope, options);
					return this;
				}
			};
		}]);
	};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.ServicePhpApi = exports.Constant = undefined;

	var _lwjServicesPhpApi = __webpack_require__(108);

	var _lwjServicesPhpApi2 = _interopRequireDefault(_lwjServicesPhpApi);

	var _constant = __webpack_require__(109);

	var _constant2 = _interopRequireDefault(_constant);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	exports.default = {
		phpApi: _lwjServicesPhpApi2.default,
		constant: _constant2.default
	};
	exports.Constant = _constant2.default;
	exports.ServicePhpApi = _lwjServicesPhpApi2.default;

/***/ }),
/* 108 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var APP = {};
	APP.API = APP.API || {};
	APP.API.com = APP.API.com || {};
	APP.API.com.php = APP.API.com.php || {};
	APP.API.com.php.home = APP.API.com.php.home || {};

	APP.API.com.php.pmc = APP.API.com.php.pmc || {};

	APP.API.com.php.home.IndexController = function ($http) {
	    return {
	        getStoreDetail: function getStoreDetail(id, successCallBack, errorCallBack) {
	            http($http, '/cms/andaren/content/detail/' + id, {}, successCallBack, errorCallBack, "GET");
	        }
	    };
	};

	// 可视化编辑交互地址
	APP.API.com.php.pmc.IndexController = function ($http) {
	    return {
	        getModularList: function getModularList(id, successCallBack, errorCallBack) {
	            http($http, 'api/modular/list', {}, successCallBack, errorCallBack, "GET");
	        },
	        getModularViewList: function getModularViewList(id, successCallBack, errorCallBack) {
	            http($http, 'api/modular/view/list', {}, successCallBack, errorCallBack, "POST");
	        }
	    };
	};
	exports.default = APP;

	/**
	 * 发起HTTP请求
	 * @param $http
	 * @param url
	 * @param data
	 * @param successCallBack
	 * @param errorCallBack
	 * @param method
	 */

	function http($http, url, data, successCallBack, errorCallBack, method) {
	    method = method || 'PUT';
	    var params = {
	        method: method.toUpperCase(),
	        // 配置api代理
	        url: "http://result.eolinker.com/B7hctqTb702bbc604f0da172f3daace6519bd929e93fae2?uri=" + url
	    };

	    if (params.method === 'GET') {
	        params.params = data;
	    } else {
	        params.data = data;
	    }

	    $http(params).success(function (data) {
	        if (data.code > 0) {
	            if (typeof errorCallBack === 'function') {
	                errorCallBack(data);
	            } else {
	                defaultErrorCall(data, $modal);
	            }
	        } else {
	            if (typeof successCallBack === 'function') {
	                successCallBack(data);
	            } else {
	                defaultCall(data);
	            }
	        }
	    }).error(function (data) {

	        if (typeof errorCallBack === 'function') {
	            errorCallBack(data);
	        } else {
	            defaultErrorCall(data, $modal);
	        }
	    });
	}

	// 默认提示
	var defaultErrorCall = function defaultErrorCall(data) {
	    alert(data);
	};
	// 默认提示
	var defaultCall = function defaultCall(data) {
	    alert(data);
	};

/***/ }),
/* 109 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	/*
	 * 列表分页配置
	 * 分页配置	
	*/
	exports.default = function ($app) {
		$app.constant('pageNationConfig', {
			page: 1,
			limit: 30,
			firstRecord: 1,
			sort: 'id',
			order: 'ASC',
			limitArray: [10, 20, 30, 50]
		});
	};

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Home = __webpack_require__(111);

	var _Home2 = _interopRequireDefault(_Home);

	var _News = __webpack_require__(115);

	var _News2 = _interopRequireDefault(_News);

	var _Unit = __webpack_require__(118);

	var _Unit2 = _interopRequireDefault(_Unit);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	exports.default = function (lwj) {
	  (0, _Home2.default)(lwj);
	  // News(lwj);
	  // Unit(lwj);
	}; /*
	    *	@tql 2017/12/08
	    *	在这里注入所有页面的控制器于服务
	    */

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _controller = __webpack_require__(112);

	var _controller2 = _interopRequireDefault(_controller);

	var _services = __webpack_require__(114);

	var _services2 = _interopRequireDefault(_services);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	function _toConsumableArray(arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }return arr2;
	  } else {
	    return Array.from(arr);
	  }
	} /*
	   *	@tql 2017/12/08
	   *	这里是当前页面的控制器与服务集成
	   */

	exports.default = function (lwj) {
	  var _lwj$controller;

	  return (_lwj$controller = lwj.controller.apply(lwj, _toConsumableArray(_controller2.default))).factory.apply(_lwj$controller, _toConsumableArray(_services2.default));
	};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _index = __webpack_require__(107);

	var _index2 = _interopRequireDefault(_index);

	var _func = __webpack_require__(113);

	var _func2 = _interopRequireDefault(_func);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	/*
	 *	@tql 2017/12/08
	 *	首页控制器
	 */
	exports.default = ["module.home.controler", ['$scope', "$http", "$uibModal", "$location", "pageNationConfig", function ($scope, $http, $uibModal, $location, pageNationConfig) {
		// 续集api
		var ServiceApi = _index2.default.phpApi.API.com.php.pmc.IndexController($http);
		ServiceApi.getModularList(1, function (data) {
			console.log("请求成功！", data);
			$scope.modularData = data.item;
		}, function (data) {
			console.log("请求失败！");
		});
		$scope.promption = "This is home";
	}]];

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.updateFunc = exports.gridFunc = undefined;

	var _lodash = __webpack_require__(94);

	var _ = _interopRequireWildcard(_lodash);

	function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	        return obj;
	    } else {
	        var newObj = {};if (obj != null) {
	            for (var key in obj) {
	                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	            }
	        }newObj.default = obj;return newObj;
	    }
	}

	var lwj = {}; /**
	               * Created by liyi on 15/10/20.
	               */

	lwj.IdentityCodeValid = function (code) {
	    var city = {
	        11: "北京",
	        12: "天津",
	        13: "河北",
	        14: "山西",
	        15: "内蒙古",
	        21: "辽宁",
	        22: "吉林",
	        23: "黑龙江 ",
	        31: "上海",
	        32: "江苏",
	        33: "浙江",
	        34: "安徽",
	        35: "福建",
	        36: "江西",
	        37: "山东",
	        41: "河南",
	        42: "湖北 ",
	        43: "湖南",
	        44: "广东",
	        45: "广西",
	        46: "海南",
	        50: "重庆",
	        51: "四川",
	        52: "贵州",
	        53: "云南",
	        54: "西藏 ",
	        61: "陕西",
	        62: "甘肃",
	        63: "青海",
	        64: "宁夏",
	        65: "新疆",
	        71: "台湾",
	        81: "香港",
	        82: "澳门",
	        91: "国外 "
	    };
	    var tip = "";
	    var pass = true;

	    if (!code || !/^[1-9][0-9]{5}(19[0-9]{2}|200[0-9]|2010)(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])[0-9]{3}[0-9xX]$/i.test(code)) {
	        tip = "身份证号格式错误";
	        pass = false;
	    } else if (!city[code.substr(0, 2)]) {
	        tip = "身份证地址编码错误";
	        pass = false;
	    } else {
	        //18位身份证需要验证最后一位校验位

	        if (code.length == 18) {
	            code = code.split(''); //∑(ai×Wi)(mod 11)
	            //加权因子
	            var factor = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
	            //校验位
	            var parity = [1, 0, 'X', 9, 8, 7, 6, 5, 4, 3, 2];
	            var sum = 0;
	            var ai = 0;
	            var wi = 0;
	            for (var i = 0; i < 17; i++) {
	                ai = code[i];
	                wi = factor[i];
	                sum += ai * wi;
	            }
	            var last = parity[sum % 11];
	            if (parity[sum % 11] != code[17]) {
	                tip = "身份证校验位错误";
	                pass = false;
	            }
	        }
	    }
	    return {
	        'pass': pass,
	        'msg': tip
	    };
	};

	lwj.getDownloadFilePath = function (resultUrl, callback, scope, $http, $modal) {
	    if (!$.trim(resultUrl)) {
	        return;
	    }

	    this.common = {};
	    lwj.API.com.php.common.FileController.call(this.common, $http, $modal);

	    var cutStyle = scope.cutStyle || 'x-oss-process=image/resize,m_fixed,h_100,w_100';
	    var param = ['returnType=url', '_lxwxjt=' + $.cookie('LX-WXSRF-JTOKEN'), 'filepath=' + resultUrl];

	    var url = param.join('&');
	    this.common.getFilePath('fileDownload?' + _.trimStart(url, '&'), function (src) {
	        if (!$.trim(src)) {
	            return;
	        }
	        var sourceSrc = src,
	            targetSrc = src;

	        if (src.indexOf(lwj.appScopeMain.DOMAIN_ALI_OSS) >= 0) {
	            sourceSrc = src.substr(0, src.indexOf('?'));
	            targetSrc = sourceSrc + (sourceSrc.indexOf('?') >= 0 ? '&' : '?') + cutStyle;
	        }
	        callback(sourceSrc, targetSrc, resultUrl);
	    });
	};

	lwj.getNextNMonth = function (date, n) {
	    var arr = date.split('-');
	    var year = arr[0]; //获取当前日期的年份
	    var month = arr[1]; //获取当前日期的月份
	    var day = arr[2]; //获取当前日期的日

	    var year2 = year;
	    var month2 = parseInt(month) + n;
	    if (month2 > 12) {
	        year2 = parseInt(year2) + 1;
	        month2 = 1;
	    }

	    var day2 = day;
	    var days2 = new Date(year2, month2, 0);
	    days2 = days2.getDate();
	    if (day2 > days2) {
	        // 日期按照最终的月份为最大值
	        day2 = days2;
	    }

	    if (month2 < 10) {
	        month2 = '0' + parseInt(month2);
	    }
	    if (day2 < 10) {
	        day2 = '0' + parseInt(day2);
	    }

	    return year2 + '-' + month2 + '-' + day2;
	};

	lwj.openDatePicker = function ($scope, $event, opened) {
	    $event.preventDefault();
	    $event.stopPropagation();
	    $scope[opened] = true;
	};

	lwj.openSuccessAlertDialog = function ($scope, $modal, title, message) {
	    return $modal.open({
	        templateUrl: 'app/views/pages/success.html',
	        controller: 'dialog.simple.ctrl',
	        $scope: $scope.$new ? $scope.$new(true) : {},
	        backdrop: true,
	        resolve: {
	            resolve: function resolve() {
	                return {
	                    title: title,
	                    message: message
	                };
	            }
	        }
	    });
	};

	lwj.openErrorAlertDialog = function ($scope, $modal, title, message, confirmText, cancelText) {
	    return $modal.open({
	        templateUrl: 'app/views/pages/error.html',
	        controller: 'dialog.simple.ctrl',
	        backdrop: true,
	        $scope: $scope.$new ? $scope.$new(true) : {},
	        resolve: {
	            resolve: function resolve() {
	                return {
	                    title: title,
	                    message: message,
	                    confirmText: confirmText,
	                    cancelText: cancelText
	                };
	            }
	        }
	    });
	};

	lwj.serverErrorAlertFunc = function ($scope, $modal, data) {
	    var msg = data.messages;
	    if (msg.serverInternal) {
	        return lwj.openErrorAlertDialog($scope, $modal, "服务器返回错误", msg.serverInternal.$srvmessage);
	    } else {
	        var serverErrorMessages = [];
	        angular.forEach(data.messages, function (value, key) {
	            serverErrorMessages.push(value.$srvmessage);
	        });
	        return lwj.openErrorAlertDialog($scope, $modal, "服务器返回错误", serverErrorMessages.join(';'));
	    }
	};

	/**
	 * [loading description]
	 * @param  {[type]} $msg    [description]
	 * @param  {[type]} $status [description]
	 * @return {[type]}         [description]
	 */
	lwj.loading = function (content) {
	    if ($("#layer_loading").length > 0) {
	        $("#layer_loading").remove();
	    } else {
	        var html = '';
	        if ($.trim(content)) {
	            html = '<span style="position: fixed; left:50%; top:50%; margin:20px 0 0 -4%; z-index:9999999999;">' + content + '</span>';
	        }
	        var tpl = '<div id="layer_loading" style="background:url(http://webimg.liweijia.com/plugin/layer/skin/default/loading-0.gif) center center no-repeat rgba(255,255,255,0.2); position: fixed; left:0; top:0; width:100%; height:100%; z-index:999999999; ">' + html + '</div>';
	        $("body").append(tpl);
	    }
	};

	lwj.openDialogConfirm = function ($scope, $modal, title, message, success) {
	    var modalInstance = $modal.open({
	        templateUrl: 'app/views/pages/dialog.confirm.html',
	        controller: 'dialog.simple.ctrl',
	        scope: $scope.$new(true),
	        backdrop: true,
	        resolve: {
	            resolve: function resolve() {
	                return {
	                    title: title,
	                    message: message
	                };
	            }
	        }
	    }).result.then(function (_resolve) {
	        success();
	    });

	    return modalInstance;
	};

	lwj.dialogConfirm = function ($scope, $modal, $http, options) {
	    var apiUrl = options.apiUrl ? options.apiUrl : '',
	        apiData = options.apiData ? options.apiData : '',
	        title = options.title ? options.title : '',
	        callback = options.callback ? options.callback : '',
	        message = options.message ? options.message : '',
	        apiMethod = options.apiMethod ? options.apiMethod : 'POST';

	    var modalInstance = $modal.open({
	        templateUrl: 'app/views/pages/dialog.confirm.html',
	        controller: 'dialog.simple.ctrl',
	        scope: $scope.$new(true),
	        backdrop: true,
	        resolve: {
	            resolve: function resolve() {
	                return {
	                    title: title,
	                    message: message
	                };
	            }
	        }
	    }).result.then(function (_resolve) {
	        $http({
	            method: apiMethod,
	            url: apiUrl,
	            data: apiData
	        }).success(function (data) {
	            if (typeof callback === 'function') {
	                callback(data);
	            }

	            var msg = data.messages;
	            if (data.code > 0) {
	                if (msg.serverInternal) {
	                    lwj.openErrorAlertDialog($scope, $modal, "服务器返回错误", msg.serverInternal.$srvmessage);
	                }
	            } else {
	                $scope.innerQuery();
	            }
	        });
	    });

	    return modalInstance;
	};

	lwj.splitImg = function (img) {
	    return img && img != 'null' ? img.split(';') : [];
	};
	lwj.joinImg = function (img) {
	    return img ? img.join(';') : '';
	};

	var gridFunc = function gridFunc($scope, $http, $location, $modal, pageNationConfig, options, $selectModalInstance, $selectResolve) {

	    var ths = {},


	    /**
	     * API的基地址
	     * 需要按照后台的规范进行编写
	     * GET  /entity/list
	     * PUT  /entity/create
	     * PUT  /entity/update
	     * POST /entity/delete
	     */
	    apiBaseUrl = options.apiBaseUrl.charAt(options.apiBaseUrl.length - 1) === '/' ? options.apiBaseUrl : options.apiBaseUrl + '/',


	    /**
	     * 页面跳转的基地址
	     * 需要按照前台的规范进行编写
	     * 查询结果列表页   /some_base/grid
	     * 创建新纪录页面   /some_base/create
	     * 更新纪录的页面   /some_base/update/:id
	     * 删除纪录，则需要弹出对话框给用户确认
	     */
	    viewBaseUrl = options.viewBaseUrl.charAt(options.viewBaseUrl.length - 1) === '/' ? options.viewBaseUrl : options.viewBaseUrl + '/',


	    /**
	     * 分页相关的配置，是options里配置的一个拷贝
	     */
	    $page = angular.copy(pageNationConfig),


	    /**
	     * 查询的相关配置
	     */
	    defaultQueryOption = [{
	        'field': 'userMobile',
	        'displayName': "手机号"
	    }],


	    /**
	     * 查询是的选项
	     * @type {*[]}
	     */
	    queryOptions = !options.queryOptions ? defaultQueryOption : options.queryOptions,


	    /**
	     * 查询列表绑定的模型名称
	     */
	    pageDataBindingName = !options.pageDataBindingName ? "data" : options.pageDataBindingName,


	    /**
	     * 按照什么字段查询
	     * @type {string}
	     */
	    queryBy = '',


	    /**
	     * 查询的关键字
	     * @type {string}
	     */
	    queryKey = '',


	    /**
	     * 区域查询
	     * @type {Array}
	     */
	    searchRegion = [],


	    /**
	     * 客户区域查询
	     * @type {Array}
	     */
	    searchUserRegion = [],


	    /**
	     * 模态对话框（用于删除确认对话框）
	     */
	    modalInstance,


	    /**
	     * 是否是多选
	     * @type {boolean}
	     */
	    multiSelect = $selectResolve ? !$selectResolve.multiSelect ? false : $selectResolve.multiSelect : false,


	    /**
	     * 上次选中的列的checkBox
	     */
	    lastSelectTarget,


	    /**
	     *自定义list查询接口名，如果未定义 使用默认接口名"list"
	     */
	    queryInterfaceName = options.queryInterfaceName,


	    /**
	     * 列表api的method
	     */
	    gridApiMethod = options.gridApiMethod ? options.gridApiMethod : 'POST',


	    /**
	     * 是否强制初始化列表
	     */
	    initList = !_.isUndefined(options.initList) ? options.initList : true;

	    $page.sort = !options.defaultSort ? 'id' : options.defaultSort;
	    $page.order = !options.defaultOrder ? 'ASC' : options.defaultOrder;
	    $scope.selectedValue = queryOptions[0].displayName;
	    $scope.queryBy = queryBy = queryOptions[0].field;
	    $scope.queryKey = queryKey;
	    $scope.$page = $page;
	    $scope.selectItems = $selectResolve ? $selectResolve.selectItems ? $selectResolve.selectItems : [] : [];
	    $scope.queryOptions = queryOptions;
	    $scope.searchRegion = searchRegion;
	    $scope.searchUserRegion = searchUserRegion;
	    $scope.currentQueryParam = options.currentQueryParam ? options.currentQueryParam : {};
	    $scope.multiSelect = multiSelect;

	    $scope.queryTaleOptions = options.queryTaleOptions ? options.queryTaleOptions : [];

	    $scope.queryByParam = function (queryBy, queryKey, config) {
	        if (config.displayType === 'select') {
	            /**
	             * 下拉选择 处理方式
	             */
	            _.each(config.queryParams, function (param, index) {
	                delete $scope.currentQueryParam[param.queryBy];
	            });
	            /**
	             * queryKey为undefined则清空组件当前的查询条件
	             */
	            if (queryKey !== 'undefined' && typeof queryKey !== "undefined") {
	                $scope.currentQueryParam[queryBy] = queryKey;
	            }
	        } else if (config.displayType === 'singleCheck') {
	            /**
	             *  单选是否 处理方式
	             */
	            if (typeof queryKey !== "undefined") {
	                $scope.currentQueryParam[queryBy] = queryKey;
	            } else {
	                delete $scope.currentQueryParam[queryBy];
	            }
	        }
	        $scope.innerQuery();
	    };

	    function orderPathFilter() {
	        /**
	         * //TODO 需要转移到m2-config里
	         * @type {string[]}
	         */
	        var apiBaseUrlArray = ['/services/order', '/services/saleOrder', '/services/designOrder', '/services/factoryOrder', '/services/financialOrder', '/services/financialRecord', '/services/financialSupplement', '/services/changeOrder', '/services/purchases', '/services/inStorage', '/services/outStorage', '/services/installOrder'];

	        var urls = _.reject(apiBaseUrlArray, function (url) {
	            return apiBaseUrl.indexOf(url) === 0;
	        });

	        return urls.length < apiBaseUrlArray.length;
	    }

	    if (orderPathFilter()) {
	        $scope.isGetBySelf = lwj.appScopeMain.isGetBySelf;
	    }

	    $scope.viewBaseUrl = viewBaseUrl;
	    /*列表排序组*/
	    $scope.orderKeys = options.orderKeys;

	    $scope.fixedListLimit = options.fixedListLimit;

	    $scope.tdColspan = options.tdColspan;

	    if ($selectModalInstance) {
	        $page.limit = 10;
	    }

	    /** 获取APIurl参数方法 **/
	    ths.getUrl = function (bUrl, method, params) {
	        var baseUrl = [bUrl];
	        baseUrl.push(method);
	        if (typeof params === 'string') {
	            baseUrl.push('/');
	            baseUrl.push('params');
	            return baseUrl.join('');
	        }
	        if (params instanceof Array) {
	            for (var i = 0; i < params.length; i++) {
	                baseUrl.push('/');
	                baseUrl.push(params[i]);
	            }
	        }
	        return baseUrl.join('');
	    };

	    /** 获取查询结果*/
	    $scope.list = function (url) {
	        if (!$scope.fixedListLimit) {
	            $scope.fixedListLimit = {};
	        }
	        if ($scope.searchRegion && $scope.searchRegion.length > 0) {
	            $scope.fixedListLimit.searchRegion = $scope.searchRegion;
	        } else {
	            delete $scope.fixedListLimit['searchRegion'];
	        }
	        if ($scope.searchUserRegion && $scope.searchUserRegion.length > 0) {
	            $scope.fixedListLimit.searchUserRegion = $scope.searchUserRegion;
	        } else {
	            delete $scope.fixedListLimit['searchUserRegion'];
	        }
	        var u = typeof url !== 'undefined' ? url : ths.getUrl(apiBaseUrl, options.queryInterfaceName ? options.queryInterfaceName : 'list', [$page.limit, $page.page, $page.sort, $page.order, 'complex']);
	        if ($scope.isGetBySelf === true || $scope.getBySelf) {
	            $scope.fixedListLimit.getBySelf = $scope.isGetBySelf || $scope.getBySelf;
	            $scope.fixedListLimit.isGetBySelf = $scope.fixedListLimit.getBySelf;
	        } else {
	            delete $scope.fixedListLimit['getBySelf'];
	            delete $scope.fixedListLimit['isGetBySelf'];
	        }
	        $scope.queryComplex({}, u);
	    };

	    $scope.queryComplex = function (event, url) {
	        var queryTarget = $scope.queryTarget || event.target;
	        if (!$scope.queryTarget) {
	            $scope.queryTarget = queryTarget;
	        }
	        /**
	         * 基于模版的，所以能够用parent('div').parent('form');
	         */
	        var searchParam = {};
	        if (queryTarget) {
	            var searchForm = $(queryTarget).parent('div').parent('form');
	            var inputs = $(searchForm[0]).find('input');
	            var selects = $(searchForm[0]).find('select');

	            _.each(inputs, function (value, index) {
	                var type = $(value).attr('type');
	                var fName = $(value).attr('name');
	                var fValue = $(value).val();
	                if (_.isEmpty(fValue)) {
	                    return;
	                }
	                if (fName.endsWith('TimeStart') > 0 || fName.endsWith('TimeEnd') > 0) {

	                    var date = new Date(fValue);
	                    fValue = date.getTime();
	                    fValue += date.getTimezoneOffset() * 60000;

	                    if (fName.endsWith('TimeEnd') > 0) {
	                        fValue += 24 * 3600 * 1000 - 1;
	                    }
	                }

	                if (type == 'checkbox') {
	                    if (!value.checked) {
	                        return true;
	                    }

	                    if (_.isUndefined(searchParam[fName])) {
	                        searchParam[fName] = [];
	                    }
	                    searchParam[fName].push(fValue);
	                } else {
	                    searchParam[fName] = fValue;
	                }
	            });

	            /**
	             * 查询条件为下拉框的处理
	             */
	            _.each(selects, function (value, index) {
	                var fName = $(value).attr('name');
	                if (!fName) {
	                    return;
	                }
	                var fValue = $(value).val();
	                if (!fValue || fValue.indexOf('undefined') >= 0) {
	                    return;
	                }
	                var split = fValue.split(':');
	                fValue = split[1];
	                if (fName === 'orderStatusSelect') {
	                    fName = fValue.split('.')[0];
	                    fValue = fValue.split('.')[1];
	                }
	                if (split[0] === 'number') {
	                    fValue = parseInt(fValue);
	                }
	                searchParam[fName] = fValue;
	            });
	        } else if (event.searchParam) {
	            searchParam = event.searchParam;
	        }

	        if ($scope.fixedListLimit && !_.isEmpty($scope.fixedListLimit)) {
	            searchParam = _.extend(angular.copy($scope.fixedListLimit), searchParam);
	        }
	        if ($scope.currentQueryParam && !_.isEmpty($scope.currentQueryParam)) {
	            searchParam = _.extend(searchParam, $scope.currentQueryParam);
	        }
	        $scope.sortOrder = $page.order === 'ASC' ? $page.sort : '-' + $page.sort;
	        var u = url || ths.getUrl(apiBaseUrl, queryInterfaceName ? queryInterfaceName : 'list', [$page.limit, $page.page, $page.sort, $page.order, 'complex']);

	        $http({
	            method: gridApiMethod,
	            url: u,
	            data: searchParam
	        }).success(function (data) {
	            delete $scope[pageDataBindingName];
	            $scope[pageDataBindingName] = data;
	            $scope.firstIndexOfPage = ($page.page - 1) * $page.limit + 1;
	            $page.totalCount = $scope[pageDataBindingName].totalCount;
	            $page.totalPages = $scope[pageDataBindingName].totalPages;
	            $page.slider = $scope[pageDataBindingName].slider;
	            if (typeof options.listCallback === 'function') {
	                options.listCallback(data);
	            }
	        });
	    };

	    /**  简单查询 */
	    $scope.query = function (q, qk) {
	        /**
	         * 如果是一个新的查询 页面跳转到第一页
	         */
	        if (q !== queryBy || qk !== queryKey) {
	            $page.page = 1;
	        }

	        queryBy = q || '';
	        queryKey = qk;

	        queryBy = queryBy.endsWith('Time') ? queryBy + 'Start' : queryBy;

	        if ($scope.queryTarget) {
	            $scope.queryComplex();
	        } else {
	            if (!queryKey || $.trim(queryKey) === '') {
	                //没有查询条件
	                $scope.list(ths.getUrl(apiBaseUrl, queryInterfaceName ? queryInterfaceName : 'list', [$page.limit, $page.page, $page.sort, $page.order, 'complex']));
	            } else {
	                var param = {};
	                param[queryBy] = queryKey;
	                $scope.queryComplex({
	                    'searchParam': param
	                });
	            }
	        }
	    };
	    $scope.innerQuery = function () {
	        $scope.query($scope.queryBy, $scope.queryKey);
	    };
	    $scope.getQueryBy = function () {
	        return queryBy;
	    };
	    $scope.getQueryKey = function () {
	        return queryKey;
	    };

	    /**  排序*/
	    $scope.orderBy = function (sort, order) {
	        $page.sort = sort.charAt(0) === '-' ? sort.substring(1, sort.length) : sort;
	        $page.order = order;
	        $scope.innerQuery();
	    };
	    $scope.goToPage = function ($event) {
	        var val = parseInt($($event.target).val());
	        if (val && $event.keyCode === 13 && angular.isNumber(val)) {
	            $scope.pageTo(val);
	        }
	    };
	    /** 切换页码 */
	    $scope.pageTo = function (pageNum) {
	        if ($page.totalPages < pageNum) {
	            return;
	        }
	        $page.page = pageNum;
	        $scope.innerQuery();
	    };

	    /** 每页显示 */
	    $scope.perPage = function () {
	        $page.page = Math.floor($scope.firstIndexOfPage / $page.limit) + 1;
	        $scope.innerQuery();
	    };
	    /** 查看详情 */
	    $scope.toggleRowDetail = function (index) {
	        if ($scope.showIndex === index) {
	            $scope.showIndex = -1;
	        } else {
	            $scope.showIndex = index;
	        }
	    };
	    /**  增*/
	    $scope.create = function (url) {
	        if (url) {
	            $location.path(url);
	            return;
	        }
	        $location.path(viewBaseUrl + 'create');
	    };
	    /**  改*/
	    $scope.update = function (id) {
	        $location.path(viewBaseUrl + 'update/' + id);
	    };
	    /** 详情*/
	    $scope.detail = function (id) {
	        $location.path(viewBaseUrl + 'detail/' + id);
	    };
	    /**  删*/
	    $scope.remove = function (id, version) {
	        modalInstance = $modal.open({
	            templateUrl: 'dialog.delete.confirm.html',
	            controller: 'dialog.simple.ctrl',
	            scope: $scope.$new(true),
	            backdrop: true,
	            resolve: {
	                resolve: function resolve() {
	                    return id;
	                }
	            }
	        }).result.then(function (id) {
	            $http({
	                method: 'post',
	                url: ths.getUrl(apiBaseUrl, 'delete', [id, version])
	            }).success(function (data) {
	                var msg = data.messages;
	                if (data.code > 0) {
	                    if (msg.serverInternal) {
	                        lwj.openErrorAlertDialog($scope, $modal, "服务器返回错误", msg.serverInternal.$srvmessage);
	                    }
	                } else {
	                    $scope.innerQuery();
	                }
	            });
	        });
	    };

	    $scope.selectAll = function (event) {
	        if (_.isUndefined($scope[pageDataBindingName])) {
	            return;
	        }
	        $scope.selectItems = [];
	        if (event.target.checked !== false) {
	            _.each($scope[pageDataBindingName].items, function (item, index) {
	                $scope.selectItems.push(item);
	            });
	        }
	    };

	    $scope.isSelectedAllItem = function () {
	        if (_.isUndefined($scope[pageDataBindingName])) {
	            return;
	        }
	        _.each($scope[pageDataBindingName].items, function (item, index) {
	            $scope.isSelectedItem(item);
	        });
	    };

	    $scope.select = function (obj, evn) {

	        if (evn.target.checked === false) {
	            $scope.selectItems = _.reject($scope.selectItems, function (item) {
	                return item['id'] === obj['id'];
	            });
	        } else {
	            if (multiSelect) {
	                $scope.selectItems = _.reject($scope.selectItems, function (item) {
	                    return item['id'] === obj['id'];
	                });
	                $scope.selectItems.push(obj);
	            } else {
	                $scope.selectItems[0] = obj;
	                if (lastSelectTarget) {
	                    lastSelectTarget.checked = false;
	                }
	            }
	        }
	        lastSelectTarget = evn.target;
	    };

	    $scope.isSelectedItem = function (obj) {
	        return _.find($scope.selectItems, {
	            id: obj['id']
	        });
	    };

	    $scope.ok = function () {
	        $selectModalInstance.close($scope.selectItems);
	    };
	    $scope.cancel = function () {
	        $selectModalInstance.dismiss("cancel");
	    };

	    if (options.noInitList) {
	        return;
	    }

	    if ((!modalInstance || options.selectInitList) && initList) {
	        $scope.list();
	    }
	};

	/***
	 *
	 *     封装  订单的增删改查的操作 */
	var updateFunc = function updateFunc($scope, $http, $location, options, $modal, $selectModalInstance) {

	    var
	    /**
	     * 表单数据绑定的名称
	     * @type {options.dataName|*}
	     */
	    dataName = options.dataName,


	    /**
	     * 编辑页面，需要展示其他列表的内容
	     */
	    viewId = !options.viewId ? '' : options.viewId,


	    /**
	     * [viewName description] 要暂时的view数据名称
	     * @type {[type]}
	     */
	    viewDataName = options.viewDataName,


	    /**
	     * 如果是修改，一般都需要数据的id，
	     * 如果是新建，则id为空
	     */
	    id = !options.id ? '' : options.id,


	    /**
	     * 根据url参数是否传递id值判断是更新还是创建实体
	     * @type {boolean}
	     */
	    isUpdate = id !== '',


	    /**
	     * 表单的名称
	     * @type {options.formName|*}
	     */
	    formName = options.formName ? options.formName : options.dataName + "Form",


	    /**
	     * 需要提交的字段
	     */
	    formFields = options.formFields,


	    /**
	     * API的基地址
	     * 需要按照后台的规范进行编写
	     * GET  /entity/list
	     * PUT  /entity/create
	     * PUT  /entity/update
	     * POST /entity/delete
	     */
	    apiBaseUrl = options.apiBaseUrl.charAt(options.apiBaseUrl.length - 1) === '/' ? options.apiBaseUrl : options.apiBaseUrl + '/',


	    /**
	     * 根据isUpdate生成表单提交地址
	     */
	    submitUrl,


	    /**
	     * 一份原始数据的拷贝，用于reset
	     * @type {{}}
	     */
	    master = {},
	        emptyDetail = options.emptyDetail,


	    /**
	     * 用于弹出对话框
	     *返回更新后的
	     */
	    resultItem = {},


	    /**
	     *自定义list查询接口名，如果未定义 使用默认接口名"list"
	     */
	    detailInterfaceName = options.detailInterfaceName,


	    /**
	     * api的method
	     */
	    viewApiMethod = options.viewApiMethod ? options.viewApiMethod : 'GET',
	        updateApiMethod = options.updateApiMethod ? options.updateApiMethod : 'POST',
	        detailApiMethod = options.detailApiMethod ? options.detailApiMethod : 'POST';

	    var _status = $location.path().match(/\/\d*\/(update|create)/g);
	    if (_status !== null) {
	        $scope.status = parseInt(_status[0].match(/\d*/g)[1]);
	    }

	    $scope.submiting = false;

	    $scope.resultItem = resultItem;

	    $scope.openDatePicker = lwj.openDatePicker;

	    $scope.reset = function () {
	        angular.copy(master, $scope[dataName]);
	    };

	    if (typeof options.appendProgress === 'function') {
	        options.appendProgress($scope, $http, options);
	    }

	    $scope.isUnchanged = function (module) {
	        return angular.equals(module, master);
	    };

	    $scope.setFormDirty = function () {
	        if ($scope[formName]) {
	            $scope[formName].$setDirty();
	        }
	    };

	    $scope.canSubmit = function () {
	        if (!$scope[formName]) {
	            return false;
	        }
	        //            console.log({'valid': $scope[formName].$valid,
	        //                        'submiting': $scope.submiting,
	        //                        'changed': !$scope.isUnchanged($scope[dataName]),
	        //                        '$dirty': $scope[formName].$dirty});
	        return $scope[formName].$valid && !$scope.submiting && !$scope.isUnchanged($scope[dataName]) && $scope[formName].$dirty;
	    };

	    $scope.detail = function () {
	        if (emptyDetail) {
	            $scope[dataName] = {};
	            angular.copy({}, master);
	            return;
	        }

	        $http({
	            method: detailApiMethod,
	            url: apiBaseUrl + (detailInterfaceName ? detailInterfaceName : "detail") + "/" + id
	        }).success(function (_data) {
	            var data = _data.result ? _data.result : _data;
	            // 先赋值给scope
	            $scope[dataName] = data;

	            if (typeof options.formatDetailData === 'function') {
	                options.formatDetailData(data);
	            }

	            data = _.omit(data, function (value, key, object) {
	                if (key.endsWith('Time')) {
	                    return !value || value === '0' || value === 0 || value < 0 || value === '1970-01-01';
	                } else {
	                    return false;
	                }
	            });

	            if (typeof data.status !== 'undefined') {
	                if ($scope.status != parseInt(data.status)) {
	                    var path = $location.path();
	                    path = path.replace(/\/\d{1,2}\//g, '/' + parseInt(data.status) + '/');
	                    $location.path(path).replace();
	                }
	            }

	            angular.copy(data, master);
	        });
	    };

	    var getViewData = function getViewData(viewId, viewDataName) {
	        $http({
	            method: viewApiMethod,
	            url: options.viewDataUrl + (detailInterfaceName ? detailInterfaceName : "detail") + "/" + viewId
	        }).success(function (_data) {
	            var data = _data.result;
	            if (typeof options.initViewData === 'function') {
	                options.initViewData(data);
	            }

	            data = _.omit(data, function (value, key, object) {
	                if (key.endsWith('Time')) {
	                    return !value || value === '0' || value === 0 || value < 0 || value === '1970-01-01';
	                } else {
	                    return false;
	                }
	            });

	            if (typeof data.status !== 'undefined') {
	                if ($scope.status != parseInt(data.status)) {
	                    var path = $location.path();
	                    path = path.replace(/\/\d{1,2}\//g, '/' + parseInt(data.status) + '/');
	                    $location.path(path).replace();
	                }
	            }
	            $scope[viewDataName] = data;
	        });
	    };

	    if (viewId) {
	        getViewData(viewId, viewDataName);
	    }

	    if (isUpdate) {
	        $scope.isUpdate = true;
	        $scope.detail();
	        if (typeof options.updateApiBaseUrl === 'function') {
	            submitUrl = options.updateApiBaseUrl() + "update";
	        } else {
	            submitUrl = apiBaseUrl + "update";
	        }
	    } else {
	        $scope.isUpdate = false;
	        $scope[dataName] = {};

	        if (typeof options.formatDetailData === 'function') {
	            options.formatDetailData($scope[dataName]);
	        }

	        // 添加一个初始化表单值得方法
	        if (typeof options.initFormData === 'function') {
	            options.initFormData($scope[dataName]);
	        }

	        angular.copy($scope[dataName], master);

	        if (typeof options.createApiUrl === 'function') {
	            submitUrl = options.createApiUrl();
	        } else {
	            if (typeof options.createApiBaseUrl === 'function') {
	                submitUrl = options.createApiBaseUrl() + "create";
	            } else {
	                submitUrl = apiBaseUrl + "create";
	            }
	        }
	    }

	    /**
	     * 如果返回的是Success则刷新该页面；
	     * 一般的如果返回的都是更新实体的ID
	     * @param data
	     */
	    $scope.onSuccessResultStringHandler = function (data) {
	        if (data.result === "Success") {
	            $location.path($location.path() + "/").replace();
	        } else {
	            if (typeof options.getRediectUrl === 'function') {
	                updateUrl = options.getRediectUrl();
	            } else {
	                /*去更新页面*/
	                var updateUrl = $location.path().replace(/create/g, 'update');
	                var lastChar = updateUrl.charAt(updateUrl.length - 1);
	                updateUrl = lastChar === '/' ? updateUrl : updateUrl + '/';
	                updateUrl = updateUrl + data.result;
	            }
	            $location.path(updateUrl).replace();
	        }
	    };

	    $scope.onSuccessResultObjectHasIdHandler = function (data) {
	        if ($selectModalInstance) {
	            angular.copy(data['result'], resultItem);
	            $scope.ok();
	        } else {
	            $scope.onSuccessResultStringHandler({
	                result: data.result['id']
	            });
	        }
	    };

	    $scope.ok = function (obj) {
	        if (obj) {
	            $selectModalInstance.close(obj);
	        } else {
	            $selectModalInstance.close(resultItem);
	        }
	    };
	    $scope.cancel = function () {
	        $selectModalInstance.dismiss("cancel");
	    };
	    $scope.checkPermission = function () {
	        var checked = false;
	        _.each(arguments, function (val) {
	            if (lwj.appScopeMain.checkPermission(val)) {
	                checked = true;
	            }
	        });
	        return checked;
	    };
	    /**
	     *提交修改或添加
	     **/
	    $scope.submit = function (formData) {

	        var submitData = {};

	        $scope.submiting = true;

	        var formatedFormData = angular.copy(formData);

	        if (typeof options.beforeSubmit === 'function') {
	            var can = options.beforeSubmit(formatedFormData);
	            if (!can) {
	                $scope.submiting = false;
	                return;
	            }
	        }

	        if (typeof options.formatSubmitData === 'function') {
	            options.formatSubmitData(formatedFormData);
	        }

	        _.each(formFields, function (value) {
	            var theVal = formatedFormData[value];
	            if (!_.isNaN(theVal) && !_.isNull(theVal) && !_.isUndefined(theVal)) {
	                submitData[value] = theVal;
	            }
	        });

	        if (_.isEmpty(submitData)) {
	            return;
	        }

	        if (typeof options.getSubmitUrl === 'function') {
	            submitUrl = options.getSubmitUrl(submitUrl);
	        }
	        if (submitUrl && submitUrl.indexOf('update') > -1 && submitUrl.indexOf('?status=') < 0) {
	            //submitUrl += "?status=" + $scope.status;
	        }
	        $http({
	            method: updateApiMethod,
	            url: submitUrl,
	            data: submitData,
	            headers: {
	                'Content-Type': 'application/json;charset=UTF-8'
	            }
	        }).success(function (data) {
	            if (data.code > 0) {
	                $scope.submiting = false;
	                var form = $scope[formName];
	                /**
	                 * 后台服务专门为angularjs返回的结果对象
	                 * 便于在页面上呈现
	                 * 但必须给每个input一个name
	                 */
	                angular.forEach(data.messages, function (value, key) {
	                    if (!form || !form[key]) {} else {
	                        form[key].$valid = value.$valid;
	                        form[key].$invalid = value.$invalid;
	                        form[key].$errorCode = value.$errorCode;
	                        form[key].$setValidity('$srverror', value.$srverror);
	                        form[key].$srvmessage = value.$srvmessage;
	                        /*纪录已经有过的错误*/
	                        if (!form[key].$errorValues) {
	                            form[key].$errorValues = [];
	                        }
	                        form[key].$errorValues.push(formData[key]);
	                    }
	                });
	                /**
	                 * 服务器错误回调函数
	                 */
	                if (typeof options.onError === 'function') {
	                    options.onError($scope, data);
	                } else {
	                    lwj.serverErrorAlertFunc($scope, $modal, data);
	                    if (typeof options.onErrorAlert === 'function') {
	                        options.onErrorAlert($scope, data);
	                    }
	                }
	            } else {
	                if (typeof submitData.version !== 'undefined') {
	                    submitData.version++;
	                }
	                /**
	                 * 服务调用成功的回调函数
	                 */
	                if (typeof options.onSuccess === 'function') {
	                    options.onSuccess($scope, data, submitData);
	                } else {
	                    if (_.isString(data.result)) {
	                        $scope.onSuccessResultStringHandler(data);
	                    } else if (_.isEmpty(data.result) || _.isNaN(data.result) || _.isNull(data.result) || _.isUndefined(data.result)) {
	                        lwj.openSuccessAlertDialog($scope, $modal, '操作成功', '服务器没有更多返回信息');
	                    } else if (_.isObject(data.result) && _.isString(data.result['id'])) {
	                        $scope.onSuccessResultObjectHasIdHandler(data);
	                    } else {
	                        //TODO:
	                        lwj.openSuccessAlertDialog($scope, $modal, '操作成功', angular.toJson(data.result));
	                    }
	                }
	            }
	        }).error(function (request) {
	            /**
	             * 服务器异常，通常都是 404，403，500
	             * @type {boolean}
	             */
	            $scope.submiting = false;
	            if (typeof options.onException === 'function') {
	                options.onException(scope, request);
	            } else {
	                console.log("server return exception:" + request);
	            }
	        });
	        //让服务器返回的异常能偶有机会得到刷新
	        var form = $scope[formName];
	        _.each(formFields, function (field) {
	            if (typeof $scope[dataName][field] !== 'undefined') {
	                var exp = dataName + '.' + field;
	                $scope.$watch(exp, function (newVal, oldVal) {
	                    if (!form[field]) {
	                        return;
	                    }
	                    if ($.inArray(newVal, form[field].$errorValues) >= 0) {
	                        //还有错
	                        form[field].$setValidity('$srverror', false);
	                        return;
	                    }
	                    if (!$scope[dataName] || !$scope[dataName][field] || newVal !== oldVal) {
	                        if (typeof form[field].$error.$srverror !== 'undefined') {
	                            form[field].$setValidity('$srverror', true);
	                        }
	                    }
	                });
	            }
	        });
	    };
	};

	exports.default = { gridFunc: gridFunc, updateFunc: updateFunc };
	exports.gridFunc = gridFunc;
	exports.updateFunc = updateFunc;

/***/ }),
/* 114 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*
	 *	@tql 2017/12/08
	 *	首页服务
	 */
	exports.default = ['module.home.services', ["$http", function ($http) {
	  return {};
	}]];

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _controller = __webpack_require__(116);

	var _controller2 = _interopRequireDefault(_controller);

	var _services = __webpack_require__(117);

	var _services2 = _interopRequireDefault(_services);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _toConsumableArray(arr) {
		if (Array.isArray(arr)) {
			for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
				arr2[i] = arr[i];
			}return arr2;
		} else {
			return Array.from(arr);
		}
	} /*
	   *	@tql 2017/12/08
	   *	这里是当前页面的控制器与服务集成
	   */

	//import newsServices2 from '../Home/services';


	exports.default = function (lwj) {
		var _lwj$controller;

		console.log(lwj);
		return (_lwj$controller = lwj.controller.apply(lwj, _toConsumableArray(_controller2.default))).factory.apply(_lwj$controller, _toConsumableArray(_services2.default));
		//factory(...newsServices2);
	};

/***/ }),
/* 116 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*
	 *	@tql 2017/12/08
	 *	首页控制器
	 */
	exports.default = ["module.news.controler.grid", ['$scope', "$http", 'module.news.services', function ($scope, $http, services) {
	  $scope.promption = "This is news";
	}]];

/***/ }),
/* 117 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*
	 *	@tql 2017/12/08
	 *	首页服务
	 */
	exports.default = ['module.news.services', ["$http", function ($http) {
	  return {};
	}]];

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _list = __webpack_require__(119);

	var _list2 = _interopRequireDefault(_list);

	var _update = __webpack_require__(120);

	var _update2 = _interopRequireDefault(_update);

	var _unit = __webpack_require__(124);

	var _unit2 = _interopRequireDefault(_unit);

	var _routes = __webpack_require__(125);

	var _routes2 = _interopRequireDefault(_routes);

	var _Redux = __webpack_require__(93);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _toConsumableArray(arr) {
		if (Array.isArray(arr)) {
			for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
				arr2[i] = arr[i];
			}return arr2;
		} else {
			return Array.from(arr);
		}
	} /*
	   *	@tql 2017/12/08
	   *	这里是当前页面的控制器与服务集成
	   */

	exports.default = function (lwj) {
		var _app$controller$contr, _app$controller;

		var app = (0, _Redux.readRedux)({
			type: "APP"
		});
		return (_app$controller$contr = (_app$controller = app.controller.apply(app, _toConsumableArray(_list2.default))).controller.apply(_app$controller, _toConsumableArray(_update2.default))).factory.apply(_app$controller$contr, _toConsumableArray(_unit2.default));
		(0, _routes2.default)();
	};

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _index = __webpack_require__(107);

	var _index2 = _interopRequireDefault(_index);

	var _func = __webpack_require__(113);

	var _func2 = _interopRequireDefault(_func);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	/*
	 *	@tql 2017/12/08
	 *	首页控制器
	 */
	console.log(_index2.default);
	exports.default = ["module.unit.grid.controler", ['$scope', "$http", "$ionicLoading", "$location", "pageNationConfig", function ($scope, $http, $ionicLoading, $location, pageNationConfig) {
	  var queryItems = {
	    'name': {
	      field: 'name',
	      displayName: '单位名称'
	    },
	    'unit': {
	      field: 'unit',
	      displayName: '单位符号'
	    },
	    'unit_type': {
	      field: 'unit_type',
	      displayName: '单位类型',
	      type: "select",
	      selectOptions: [{
	        name: '全部', value: undefined
	      }, {
	        name: '整数', value: 1
	      }, {
	        name: '小数', value: 2
	      }]
	    }
	  };

	  var defaultOptions = {
	    pageDataBindingName: 'data',
	    viewBaseUrl: "commodity/unit",
	    apiBaseUrl: "http://shopadmin-local.andaren.com/api/commodity/unit",
	    defaultSort: 'created_at',
	    defaultOrder: 'DESC',
	    queryTaleOptions: [[queryItems['name'], queryItems['unit'], queryItems['unit_type']]],
	    fixedListLimit: {},
	    gridApiMethod: 'GET',
	    listCallback: function listCallback(data) {}
	  };

	  var gridOptions = angular.copy(defaultOptions);
	  gridOptions.viewBaseUrl = '/product';
	  gridOptions.pageDataBindingName = 'productList';

	  gridOptions.queryTaleOptions = [[queryItems['productName']]];

	  _func2.default.gridFunc($scope, $http, $location, $ionicLoading, pageNationConfig, gridOptions, null, {
	    'multiSelect': true
	  });

	  // 续集api
	  var ServiceApi = _index2.default.phpApi.API.com.php.home.IndexController($http);
	  console.log(ServiceApi, "续集API成功，开始发送请求！");
	  $ionicLoading.show({
	    template: '续集API成功，开始发送请求！'
	  });
	  ServiceApi.getStoreDetail(1, function (data) {
	    console.log("请求成功！");
	    $ionicLoading.hide();
	  }, function (data) {
	    console.log("请求失败！");
	    $ionicLoading.hide();
	  });
	  $scope.promption = "unit";
	}]];

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _index = __webpack_require__(121);

	var _index2 = _interopRequireDefault(_index);

	var _func = __webpack_require__(113);

	var _func2 = _interopRequireDefault(_func);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}

	/*
	 *	@tql 2017/12/08
	 *	首页控制器
	 */
	exports.default = ["module.unit.update.controler", ['$scope', "$http", "$ionicLoading", "$location", "pageNationConfig", "$routeParams", function ($scope, $http, $ionicLoading, $location, pageNationConfig, $routeParams) {

	    $scope.unitTypeArr = [{ "name": "请选择", "value": undefined }, { "name": "整数", "value": "1" }, { "name": "小数", "value": "2" }];
	    var editOptions = {
	        id: $routeParams.id,
	        dataName: "item",
	        formName: "formData",
	        formFields: ["name", "unit", "unit_type"],
	        apiBaseUrl: defaultOptions.apiBaseUrl,
	        formatSubmitData: function formatSubmitData(data) {
	            data = data || {};
	        },
	        formatDetailData: function formatDetailData(data) {
	            data = data || {};
	        },
	        onSuccess: function onSuccess($scope, data, submitData) {
	            $location.path('commodity/unit/grid');
	            lwj.openSuccessAlertDialog($scope, $modal, '操作提示', '操作成功');
	        }
	    };
	    _func2.default.updateFunc($scope, $http, $location, editOptions, $modal);
	}]];

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.ServicePhpApi = exports.Constant = undefined;

	var _lwjServicesPhpApi = __webpack_require__(122);

	var _lwjServicesPhpApi2 = _interopRequireDefault(_lwjServicesPhpApi);

	var _constant = __webpack_require__(123);

	var _constant2 = _interopRequireDefault(_constant);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	exports.default = {
		phpApi: _lwjServicesPhpApi2.default,
		constant: _constant2.default
	};
	exports.Constant = _constant2.default;
	exports.ServicePhpApi = _lwjServicesPhpApi2.default;

/***/ }),
/* 122 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var APP = {};
	APP.API = APP.API || {};
	APP.API.com = APP.API.com || {};
	APP.API.com.php = APP.API.com.php || {};
	APP.API.com.php.home = APP.API.com.php.home || {};

	APP.API.com.php.pmc = APP.API.com.php.pmc || {};

	APP.API.com.php.home.IndexController = function ($http) {
	    return {
	        getStoreDetail: function getStoreDetail(id, successCallBack, errorCallBack) {
	            http($http, '/cms/andaren/content/detail/' + id, {}, successCallBack, errorCallBack, "GET");
	        }
	    };
	};

	// 可视化编辑交互地址
	APP.API.com.php.pmc.IndexController = function ($http) {
	    return {
	        getModularList: function getModularList(id, successCallBack, errorCallBack) {
	            http($http, 'api/modular/list', {}, successCallBack, errorCallBack, "GET");
	        },
	        getModularViewList: function getModularViewList(id, successCallBack, errorCallBack) {
	            http($http, 'api/modular/view/list', {}, successCallBack, errorCallBack, "POST");
	        }
	    };
	};
	exports.default = APP;

	/**
	 * 发起HTTP请求
	 * @param $http
	 * @param url
	 * @param data
	 * @param successCallBack
	 * @param errorCallBack
	 * @param method
	 */

	function http($http, url, data, successCallBack, errorCallBack, method) {
	    method = method || 'PUT';
	    var params = {
	        method: method.toUpperCase(),
	        // 配置api代理
	        url: "http://result.eolinker.com/B7hctqTb702bbc604f0da172f3daace6519bd929e93fae2?uri=" + url
	    };

	    if (params.method === 'GET') {
	        params.params = data;
	    } else {
	        params.data = data;
	    }

	    $http(params).success(function (data) {
	        if (data.code > 0) {
	            if (typeof errorCallBack === 'function') {
	                errorCallBack(data);
	            } else {
	                defaultErrorCall(data, $modal);
	            }
	        } else {
	            if (typeof successCallBack === 'function') {
	                successCallBack(data);
	            } else {
	                defaultCall(data);
	            }
	        }
	    }).error(function (data) {

	        if (typeof errorCallBack === 'function') {
	            errorCallBack(data);
	        } else {
	            defaultErrorCall(data, $modal);
	        }
	    });
	}

	// 默认提示
	var defaultErrorCall = function defaultErrorCall(data) {
	    alert(data);
	};
	// 默认提示
	var defaultCall = function defaultCall(data) {
	    alert(data);
	};

/***/ }),
/* 123 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	/*
	 * 列表分页配置
	 * 分页配置	
	*/
	exports.default = function ($app) {
		$app.constant('pageNationConfig', {
			page: 1,
			limit: 30,
			firstRecord: 1,
			sort: 'id',
			order: 'ASC',
			limitArray: [10, 20, 30, 50]
		});
	};

/***/ }),
/* 124 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*
	 *	@tql 2017/12/08
	 *	首页服务
	 */
	exports.default = ['module.home.services', ["$http", function ($http) {
	  return {};
	}]];

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _form = __webpack_require__(126);

	var _form2 = _interopRequireDefault(_form);

	var _grid = __webpack_require__(127);

	var _grid2 = _interopRequireDefault(_grid);

	var _Redux = __webpack_require__(93);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	var state = [['unit_grid', {
	  url: '/unit/grid',
	  template: _grid2.default,
	  controller: 'module.unit.grid.controler'
	}], ['unit_update', {
	  url: '/unit/update/:id',
	  template: _form2.default,
	  controller: 'module.unit.update.controler'
	}]];

	// 存储路由数据
	exports.default = (0, _Redux.getRedux)(state, { type: "ROUTES" });

/***/ }),
/* 126 */
/***/ (function(module, exports) {

	module.exports = "<ion-view title=\"'Home'\">\r\n    <!--头部-->\r\n    <ion-header-bar align-title=\"center\" class=\"bar-positive\">\r\n        <h1 class=\"title  title-center\">home!</h1>\r\n        <!--<div class=\"buttons\">-->\r\n            <button class=\"button\">form</button>\r\n        <!--</div>-->\r\n    </ion-header-bar>\r\n\r\n    <!--中间内容-->\r\n    <ion-content>\r\n        <!-- 页面的内容 -->\r\n        <br><br><br><br><br>\r\n        <a class=\"button icon icon-right ion-chevron-right\" href=\"#/news\">{{ promption }}</a>\r\n    </ion-content>\r\n    <ion-footer-bar align-title=\"center\" class=\"bar-positive\">\r\n        <h1 class=\"title  title-center\">底部!</h1>\r\n    </ion-footer-bar>\r\n</ion-view>";

/***/ }),
/* 127 */
/***/ (function(module, exports) {

	module.exports = "<ion-view title=\"'Home'\">\r\n    <!--头部-->\r\n    <ion-header-bar align-title=\"center\" class=\"bar-positive\">\r\n        <h1 class=\"title  title-center\">home!</h1>\r\n        <!--<div class=\"buttons\">-->\r\n            <button class=\"button\">下一页</button>\r\n        <!--</div>-->\r\n    </ion-header-bar>\r\n\r\n    <!--中间内容-->\r\n    <ion-content>\r\n        <!-- 页面的内容 -->\r\n        <br><br><br><br><br>\r\n        <a class=\"button icon icon-right ion-chevron-right\" href=\"#/news\">{{ promption }}</a>\r\n    </ion-content>\r\n    <ion-footer-bar align-title=\"center\" class=\"bar-positive\">\r\n        <h1 class=\"title  title-center\">底部!</h1>\r\n    </ion-footer-bar>\r\n</ion-view>";

/***/ })
/******/ ]);